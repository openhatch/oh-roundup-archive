From 18e8e71ad331fbc3bfb57967cf5ba84294ae16b3 Mon Sep 17 00:00:00 2001
From: Jack Grigg <me@jackgrigg.com>
Date: Sun, 11 Jul 2010 22:27:40 +0000
Subject: [PATCH 01/13] Mostly complete generator setup for creating tracker-specific sub-classes.
 Just missing bug project name gener and a few minor details.

---
 mysite/customs/bugtrackers/bugzilla.py |  147 ++++++++++++++++++++++++++++++++
 1 files changed, 147 insertions(+), 0 deletions(-)

diff --git a/mysite/customs/bugtrackers/bugzilla.py b/mysite/customs/bugtrackers/bugzilla.py
index af7e0a6..718bb89 100644
--- a/mysite/customs/bugtrackers/bugzilla.py
+++ b/mysite/customs/bugtrackers/bugzilla.py
@@ -276,6 +276,153 @@ class BugzillaBugTracker(object):
         self.refresh_all_bugs()
 
 ############################################################
+# Function that creates classes for individual trackers
+def bugzilla_tracker_factory(params):
+    # Create '__init__' method
+    def __init__(self):
+        BugzillaBugTracker.__init__(self,
+                                    base_url=params['base_url'],
+                                    project_name=params['project_name'],
+                                    bug_project_name_format=params.get('bug_project_name_format', ''))
+
+    if not (params.get('bug_queries') and params.get('tracker_bug_url')):
+        raise ValueError('Either bug_queries or tracker_bug_url must be defined.')
+
+    #Create 'generate_current_bug_xml' method
+    def generate_current_bug_xml(self):
+        queries = params.get('bug_queries')
+        return self.generate_bug_xml_from_queries(queries)
+
+    # Create 'get_current_bug_id_list' method
+    def get_current_bug_id_list(self):
+        return mysite.customs.bugtrackers.bugzilla.tracker_bug2bug_ids(params.get('tracker_bug_url'))
+
+    # Create 'extract_tracker_specific_data' method
+    @staticmethod
+    def extract_tracker_specific_data(xml_data, ret_dict):
+        # Make modifications to ret_dict using provided metadata
+        # Get keywords first since used in multiple checks
+        keywords_text = mysite.customs.bugtrackers.bugzilla.get_tag_text_from_xml(xml_data, 'keywords')
+        keywords = map(lambda s: s.strip(),
+                       keywords_text.split(','))
+
+        # Bitesized bug checks
+        # Check for the bitesized keyword if it exists
+        if params.get('bitesized_keyword'):
+            ret_dict['good_for_newcomers'] = (params['bitesized_keyword'] in keywords)
+            ret_dict['bite_size_tag_name'] = params['bitesized_keyword']
+        # No keyword. Check for the bitsized whiteboard tag if it exists
+        elif params.get('bitesized_whiteboard_tag'):
+            whiteboard_text = mysite.customs.bugtrackers.bugzilla.get_tag_text_from_xml(xml_data, 'status_whiteboard')
+            ret_dict['good_for_newcomers'] = (whiteboard_text == params['bitesized_whiteboard_tag'])
+            ret_dict['bite_size_tag_name'] = params['bitesized_whiteboard_tag']
+
+        # Documentation bug checks
+        # Check for the documentation keyword if it exists
+        if params.get('documentation_keyword'):
+            ret_dict['concerns_just_documentation'] = (params['documentation_keyword'] in keywords)
+        # No keyword. Check for the documentation component if it exists
+        elif params.get('documentation_component'):
+            component = mysite.customs.bugtrackers.bugzilla.get_tag_text_from_xml(xml_data, 'component')
+            ret_dict['concerns_just_documentation'] = (component == params['documentation_component'])
+        # No component. Check for the documentation product if it exists
+        elif params.get('documentation_product'):
+            product = mysite.customs.bugtrackers.bugzilla.get_tag_text_from_xml(xml_data, 'product')
+            ret_dict['concerns_just_documentation'] = (product == params['documentation_product'])
+
+        # Distribution tag
+        if params.get('as_appears_in_distribution'):
+            ret_dict['as_appears_in_distribution'] = params['as_appears_in_distribution']
+
+        # Tracker-specific stuff e.g. stripping 'JJ:' from KDE bug titles.
+        # FIXME: How do we efficiently implement this?
+
+        # Then pass ret_dict back
+        return ret_dict
+
+    # Create 'generate_bug_project_name' method
+    # FIXME: Implement this properly.
+    def generate_bug_project_name(self, bb):
+        return params['project_name']
+
+    # Generate class dictionary
+    # All sub-classes have '__init__' and 'extract_tracker_specific_data' methods
+    class_dict = {'__init__': __init__,
+                  'extract_tracker_specific_data': extract_tracker_specific_data}
+
+    # A sub-class will have either a 'generate_current_bug_xml' method or
+    # a 'get_current_bug_id_list' method.
+    if params.get('bug_queries'):
+        class_dict['generate_current_bug_xml'] = generate_current_bug_xml
+    else:
+        class_dict['get_current_bug_id_list'] = get_current_bug_id_list
+
+    # A sub-class will only overload the 'generate_bug_project_name' method
+    # if the 'bug_project_name_format' parameter is not used.
+    if not params.get('bug_project_name_format'):
+        class_dict['generate_bug_project_name'] = generate_bug_project_name
+
+    # Return the generated sub-class.
+    sub-class_name = '%sBugzilla' % params['project_name'].replace(' ', '')
+    return type(sub-class_name, (BugzillaBugTracker,), class_dict)
+
+############################################################
+# Generator of sub-classes from data
+
+def generate_bugzilla_tracker_classes(tracker_name=None):
+    # List of data for the trackers.
+    # FIXME: This should be replaced by a database.
+    tracker_params = {
+            'Miro':
+                {
+                    'project_name':
+                        'Miro',
+                    'base_url':
+                        'http://bugzilla.pculture.org/',
+                    'bug_project_name_format':
+                        '{project}',
+                    'bug_queries':
+                        {
+                            'Easy bugs':
+                                'http://bugzilla.pculture.org/buglist.cgi?bug_status=NEW&bug_status=ASSIGNED&bug_status=REOPENED&field-1-0-0=bug_status&field-1-1-0=product&field-1-2-0=keywords&keywords=bitesized&product=Miro&query_format=advanced&remaction=&type-1-0-0=anyexact&type-1-1-0=anyexact&type-1-2-0=anywords&value-1-0-0=NEW%2CASSIGNED%2CREOPENED&value-1-1-0=Miro&value-1-2-0=bitesized',
+                        },
+                    'bitesized_keyword':
+                        'bitesized'
+                },
+            'KDE':
+                {
+                    'project_name':
+                        'KDE',
+                    'base_url':
+                        'https://bugs.kde.org/',
+                    'bug_queries':
+                        {
+                            'Easy bugs':
+                                'https://bugs.kde.org/buglist.cgi?query_format=advanced&keywords=junior-jobs&resolution=---',
+                            'Documentation bugs':
+                                'https://bugs.kde.org/buglist.cgi?query_format=advanced&product=docs&resolution=---'
+                        },
+                    'bitesized_keyword':
+                        'junior-jobs',
+                    'documentation_product':
+                        'docs'
+                    # FIXME: Once generate_bug_project_name is implemented, there
+                    # will be parameters here related to bug project naming.
+                }
+            }
+
+    # If a tracker name was passed in then returnb the
+    # specific sub-class for that tracker.
+    if tracker_name:
+        params = tracker_params[tracker_name]
+        return bugzilla_tracker_factory(params)
+    else:
+        # Create a generator that yields all sub-classes.
+        for tracker in tracker_params:
+            params = tracker_params[tracker]
+            yield bugzilla_tracker_factory(params)
+
+############################################################
 # Specific sub-classes for individual bug trackers
 
 class MiroBugzilla(BugzillaBugTracker):
-- 
1.7.1


From 655f4af947a76d5856e438ebbeed7336763c2e2b Mon Sep 17 00:00:00 2001
From: Jack Grigg <me@jackgrigg.com>
Date: Wed, 14 Jul 2010 02:48:30 +0000
Subject: [PATCH 02/13] Comment out generate_bug_project_name overloading in abstraction of
 Bugzilla sub-classes - trackers that require it will be special
 cases for now and remain at the bottom of the file.

---
 mysite/customs/bugtrackers/bugzilla.py |   12 ++++++++----
 1 files changed, 8 insertions(+), 4 deletions(-)

diff --git a/mysite/customs/bugtrackers/bugzilla.py b/mysite/customs/bugtrackers/bugzilla.py
index 718bb89..f02ab8e 100644
--- a/mysite/customs/bugtrackers/bugzilla.py
+++ b/mysite/customs/bugtrackers/bugzilla.py
@@ -341,9 +341,10 @@ def bugzilla_tracker_factory(params):
         return ret_dict
 
     # Create 'generate_bug_project_name' method
-    # FIXME: Implement this properly.
-    def generate_bug_project_name(self, bb):
-        return params['project_name']
+    # FIXME: Implement this properly. Until this is done, trackers that overload
+    # this function will remain as special cases.
+    #def generate_bug_project_name(self, bb):
+        #return params['project_name']
 
     # Generate class dictionary
     # All sub-classes have '__init__' and 'extract_tracker_specific_data' methods
@@ -360,7 +361,10 @@ def bugzilla_tracker_factory(params):
     # A sub-class will only overload the 'generate_bug_project_name' method
     # if the 'bug_project_name_format' parameter is not used.
     if not params.get('bug_project_name_format'):
-        class_dict['generate_bug_project_name'] = generate_bug_project_name
+        # FIXME: Once implemented properly this will be uncommented.
+        # For now, error out.
+        #class_dict['generate_bug_project_name'] = generate_bug_project_name
+        raise ValueError('bug_project_name_format must be defined - overloading not supported at this time.')
 
     # Return the generated sub-class.
     sub-class_name = '%sBugzilla' % params['project_name'].replace(' ', '')
-- 
1.7.1


From cb154ba26e9dd18b938e875aa982c3df4b4615a9 Mon Sep 17 00:00:00 2001
From: Jack Grigg <me@jackgrigg.com>
Date: Wed, 14 Jul 2010 03:49:54 +0000
Subject: [PATCH 03/13] First version of BugzillaTracker model.

---
 mysite/customs/models.py |   33 +++++++++++++++++++++++++++++++++
 1 files changed, 33 insertions(+), 0 deletions(-)

diff --git a/mysite/customs/models.py b/mysite/customs/models.py
index ac79f44..7a372bd 100644
--- a/mysite/customs/models.py
+++ b/mysite/customs/models.py
@@ -54,3 +54,36 @@ class WebResponse(models.Model):
     def create_from_http_error(error):
         return None
 
+class BugzillaTracker(models.Model)
+    '''This model stores the data for individual Bugzilla trackers.'''
+    project_name = models.CharField(max_length=200, unique=True,
+                                    blank=False, null=False)
+    base_url = models.URLField(max_length=200, unique=True,
+                               blank=False, null=False)
+    bug_project_name_format = models.CharField(max_length=200)
+    QUERY_URL_TYPES = (
+            ('xml', 'Bug XML query'),
+            ('tracker', 'Tracker bug URL')
+            )
+    query_url_type = models.CharField(max_length=20, choices=QUERY_URL_TYPES)
+    # FIXME: Need to be able to store more than one URL for some XML queries.
+    query_url = models.URLField(max_length=200, unique=True,
+                                blank=False, null=False)
+    BITESIZED_TYPES = (
+            (None, 'None'),
+            ('key', 'Keyword'),
+            ('wboard', 'Whiteboard tag')
+            )
+    bitesized_type = models.CharField(max_length=10, choices=BITESIZED_TYPES)
+    bitesized_text = models.CharField(max_length=200, blank=True, default='')
+    DOCUMENTATION_TYPES = (
+            (None, 'None'),
+            ('key', 'Keyword'),
+            ('comp', 'Component'),
+            ('prod', 'Product')
+            )
+    documentation_type = models.CharField(max_length=10, choices=DOCUMENTATION_TYPES)
+    documentation_text = models.CharField(max_length=200, blank=True, default='')
+    as_appears_in_distribution = models.CharField(max_length=200, blank=True, default='')
+
+    all_trackers = models.Manager()
-- 
1.7.1


From daf1154f941dc4ec82c7198c2c1dc8ab731d700a Mon Sep 17 00:00:00 2001
From: Jack Grigg <me@jackgrigg.com>
Date: Wed, 14 Jul 2010 23:36:21 +0000
Subject: [PATCH 04/13] Hopefully a solution to query_url issue in BugzillaTracker Model.

---
 mysite/customs/models.py |   28 +++++++++++++++++++++++++---
 1 files changed, 25 insertions(+), 3 deletions(-)

diff --git a/mysite/customs/models.py b/mysite/customs/models.py
index 7a372bd..7498a01 100644
--- a/mysite/customs/models.py
+++ b/mysite/customs/models.py
@@ -54,6 +54,29 @@ class WebResponse(models.Model):
     def create_from_http_error(error):
         return None
 
+class SeparatedValuesField(models.TextField):
+    '''As exemplified on www.davidcramer.net'''
+    __metaclass__ = models.SubfieldBase
+
+    def __init__(self, *args, **kwargs):
+        self.token = kwargs.pop('token', ',')
+        super(SeparatedValuesField, self).__init__(*args, **kwargs)
+
+    def to_python(self, value):
+        if not value: return
+        if isinstance(value, list):
+            return value
+        return value.split(self.token)
+
+    def get_db_prep_value(self, value):
+        if not value: return
+        assert(isinstance(value, list) or isinstance(value, tuple))
+        return self.token.join([unicode(s) for s in value])
+
+    def value_to_string(self, obj):
+        value = self._get_val_from_obj(obj)
+        return self.get_db_prep_value(value)
+
 class BugzillaTracker(models.Model)
     '''This model stores the data for individual Bugzilla trackers.'''
     project_name = models.CharField(max_length=200, unique=True,
@@ -66,9 +89,8 @@ class BugzillaTracker(models.Model)
             ('tracker', 'Tracker bug URL')
             )
     query_url_type = models.CharField(max_length=20, choices=QUERY_URL_TYPES)
-    # FIXME: Need to be able to store more than one URL for some XML queries.
-    query_url = models.URLField(max_length=200, unique=True,
-                                blank=False, null=False)
+    query_url = models.SeparatedValuesField(max_length=200, unique=True,
+                                            blank=False, null=False)
     BITESIZED_TYPES = (
             (None, 'None'),
             ('key', 'Keyword'),
-- 
1.7.1


From f3d851b8834d0b2c4d0e8f0a209f605eac6668e4 Mon Sep 17 00:00:00 2001
From: Jack Grigg <me@jackgrigg.com>
Date: Thu, 15 Jul 2010 00:49:21 +0000
Subject: [PATCH 05/13] Bugfixes to BugzillaTracker model.

---
 mysite/customs/models.py |    6 +++---
 1 files changed, 3 insertions(+), 3 deletions(-)

diff --git a/mysite/customs/models.py b/mysite/customs/models.py
index 7498a01..465820d 100644
--- a/mysite/customs/models.py
+++ b/mysite/customs/models.py
@@ -77,19 +77,19 @@ class SeparatedValuesField(models.TextField):
         value = self._get_val_from_obj(obj)
         return self.get_db_prep_value(value)
 
-class BugzillaTracker(models.Model)
+class BugzillaTracker(models.Model):
     '''This model stores the data for individual Bugzilla trackers.'''
     project_name = models.CharField(max_length=200, unique=True,
                                     blank=False, null=False)
     base_url = models.URLField(max_length=200, unique=True,
                                blank=False, null=False)
-    bug_project_name_format = models.CharField(max_length=200)
+    bug_project_name_format = models.CharField(max_length=200, blank=False)
     QUERY_URL_TYPES = (
             ('xml', 'Bug XML query'),
             ('tracker', 'Tracker bug URL')
             )
     query_url_type = models.CharField(max_length=20, choices=QUERY_URL_TYPES)
-    query_url = models.SeparatedValuesField(max_length=200, unique=True,
+    query_url = SeparatedValuesField(max_length=200, unique=True,
                                             blank=False, null=False)
     BITESIZED_TYPES = (
             (None, 'None'),
-- 
1.7.1


From 908ae530b6d51e035f750178589b4dee6e042374 Mon Sep 17 00:00:00 2001
From: Jack Grigg <me@jackgrigg.com>
Date: Thu, 15 Jul 2010 00:50:04 +0000
Subject: [PATCH 06/13] Modify cusoms.bugtrackers.bugzilla to use BugzillaTracker model.

---
 mysite/customs/bugtrackers/bugzilla.py |  118 ++++++++++----------------------
 1 files changed, 36 insertions(+), 82 deletions(-)

diff --git a/mysite/customs/bugtrackers/bugzilla.py b/mysite/customs/bugtrackers/bugzilla.py
index f02ab8e..4e73d54 100644
--- a/mysite/customs/bugtrackers/bugzilla.py
+++ b/mysite/customs/bugtrackers/bugzilla.py
@@ -277,25 +277,26 @@ class BugzillaBugTracker(object):
 
 ############################################################
 # Function that creates classes for individual trackers
-def bugzilla_tracker_factory(params):
+def bugzilla_tracker_factory(bt):
     # Create '__init__' method
     def __init__(self):
         BugzillaBugTracker.__init__(self,
-                                    base_url=params['base_url'],
-                                    project_name=params['project_name'],
-                                    bug_project_name_format=params.get('bug_project_name_format', ''))
+                                    base_url=bt.base_url,
+                                    project_name=bt.project_name
+                                    bug_project_name_format=bt.bug_project_name_format
 
-    if not (params.get('bug_queries') and params.get('tracker_bug_url')):
-        raise ValueError('Either bug_queries or tracker_bug_url must be defined.')
+    # Create bug query methods. It doesn't matter what type of query url
+    # is stored, since the incorrectly generated method will not be used
+    # anyway when bt.query_url_type is checked later.
 
-    #Create 'generate_current_bug_xml' method
+    # Create 'generate_current_bug_xml' method
     def generate_current_bug_xml(self):
-        queries = params.get('bug_queries')
+        queries = bt.query_url
         return self.generate_bug_xml_from_queries(queries)
 
     # Create 'get_current_bug_id_list' method
     def get_current_bug_id_list(self):
-        return mysite.customs.bugtrackers.bugzilla.tracker_bug2bug_ids(params.get('tracker_bug_url'))
+        return mysite.customs.bugtrackers.bugzilla.tracker_bug2bug_ids(bt.query_url)
 
     # Create 'extract_tracker_specific_data' method
     @staticmethod
@@ -308,31 +309,31 @@ def bugzilla_tracker_factory(params):
 
         # Bitesized bug checks
         # Check for the bitesized keyword if it exists
-        if params.get('bitesized_keyword'):
-            ret_dict['good_for_newcomers'] = (params['bitesized_keyword'] in keywords)
-            ret_dict['bite_size_tag_name'] = params['bitesized_keyword']
+        if bt.bitesized_type == 'key'::
+            ret_dict['good_for_newcomers'] = (bt.bitesized_text in keywords)
+            ret_dict['bite_size_tag_name'] = bt.bitesized_text
         # No keyword. Check for the bitsized whiteboard tag if it exists
-        elif params.get('bitesized_whiteboard_tag'):
+        elif bt.bitesized_type == 'wboard':
             whiteboard_text = mysite.customs.bugtrackers.bugzilla.get_tag_text_from_xml(xml_data, 'status_whiteboard')
-            ret_dict['good_for_newcomers'] = (whiteboard_text == params['bitesized_whiteboard_tag'])
-            ret_dict['bite_size_tag_name'] = params['bitesized_whiteboard_tag']
+            ret_dict['good_for_newcomers'] = (whiteboard_text == bt.bitesized_text)
+            ret_dict['bite_size_tag_name'] = bt.bitesized_text
 
         # Documentation bug checks
         # Check for the documentation keyword if it exists
-        if params.get('documentation_keyword'):
-            ret_dict['concerns_just_documentation'] = (params['documentation_keyword'] in keywords)
+        if bt.documentation_type == 'key':
+            ret_dict['concerns_just_documentation'] = (bt.documentation_text in keywords)
         # No keyword. Check for the documentation component if it exists
-        elif params.get('documentation_component'):
+        elif bt.documentation_type == 'comp':
             component = mysite.customs.bugtrackers.bugzilla.get_tag_text_from_xml(xml_data, 'component')
-            ret_dict['concerns_just_documentation'] = (component == params['documentation_component'])
+            ret_dict['concerns_just_documentation'] = (component == bt.documentation_text)
         # No component. Check for the documentation product if it exists
-        elif params.get('documentation_product'):
+        elif bt.documentation_type == 'prod':
             product = mysite.customs.bugtrackers.bugzilla.get_tag_text_from_xml(xml_data, 'product')
-            ret_dict['concerns_just_documentation'] = (product == params['documentation_product'])
+            ret_dict['concerns_just_documentation'] = (product == bt.documentation_text)
 
-        # Distribution tag
-        if params.get('as_appears_in_distribution'):
-            ret_dict['as_appears_in_distribution'] = params['as_appears_in_distribution']
+        # Distribution tag. We can always set this, as the Bug model uses
+        # '' as default anyway, and we default to that for blank answers.
+        ret_dict['as_appears_in_distribution'] = bt.as_appears_in_distribution
 
         # Tracker-specific stuff e.g. stripping 'JJ:' from KDE bug titles.
         # FIXME: How do we efficiently implement this?
@@ -344,7 +345,7 @@ def bugzilla_tracker_factory(params):
     # FIXME: Implement this properly. Until this is done, trackers that overload
     # this function will remain as special cases.
     #def generate_bug_project_name(self, bb):
-        #return params['project_name']
+        #return bt.project_name
 
     # Generate class dictionary
     # All sub-classes have '__init__' and 'extract_tracker_specific_data' methods
@@ -353,78 +354,31 @@ def bugzilla_tracker_factory(params):
 
     # A sub-class will have either a 'generate_current_bug_xml' method or
     # a 'get_current_bug_id_list' method.
-    if params.get('bug_queries'):
+    if bt.query_url_type = 'xml':
         class_dict['generate_current_bug_xml'] = generate_current_bug_xml
     else:
         class_dict['get_current_bug_id_list'] = get_current_bug_id_list
 
-    # A sub-class will only overload the 'generate_bug_project_name' method
-    # if the 'bug_project_name_format' parameter is not used.
-    if not params.get('bug_project_name_format'):
-        # FIXME: Once implemented properly this will be uncommented.
-        # For now, error out.
-        #class_dict['generate_bug_project_name'] = generate_bug_project_name
-        raise ValueError('bug_project_name_format must be defined - overloading not supported at this time.')
-
     # Return the generated sub-class.
-    sub-class_name = '%sBugzilla' % params['project_name'].replace(' ', '')
+    sub-class_name = '%sBugzilla' % bt.project_name.replace(' ', '')
     return type(sub-class_name, (BugzillaBugTracker,), class_dict)
 
 ############################################################
 # Generator of sub-classes from data
 
 def generate_bugzilla_tracker_classes(tracker_name=None):
-    # List of data for the trackers.
-    # FIXME: This should be replaced by a database.
-    tracker_params = {
-            'Miro':
-                {
-                    'project_name':
-                        'Miro',
-                    'base_url':
-                        'http://bugzilla.pculture.org/',
-                    'bug_project_name_format':
-                        '{project}',
-                    'bug_queries':
-                        {
-                            'Easy bugs':
-                                'http://bugzilla.pculture.org/buglist.cgi?bug_status=NEW&bug_status=ASSIGNED&bug_status=REOPENED&field-1-0-0=bug_status&field-1-1-0=product&field-1-2-0=keywords&keywords=bitesized&product=Miro&query_format=advanced&remaction=&type-1-0-0=anyexact&type-1-1-0=anyexact&type-1-2-0=anywords&value-1-0-0=NEW%2CASSIGNED%2CREOPENED&value-1-1-0=Miro&value-1-2-0=bitesized',
-                        },
-                    'bitesized_keyword':
-                        'bitesized'
-                },
-            'KDE':
-                {
-                    'project_name':
-                        'KDE',
-                    'base_url':
-                        'https://bugs.kde.org/',
-                    'bug_queries':
-                        {
-                            'Easy bugs':
-                                'https://bugs.kde.org/buglist.cgi?query_format=advanced&keywords=junior-jobs&resolution=---',
-                            'Documentation bugs':
-                                'https://bugs.kde.org/buglist.cgi?query_format=advanced&product=docs&resolution=---'
-                        },
-                    'bitesized_keyword':
-                        'junior-jobs',
-                    'documentation_product':
-                        'docs'
-                    # FIXME: Once generate_bug_project_name is implemented, there
-                    # will be parameters here related to bug project naming.
-                }
-            }
-
-    # If a tracker name was passed in then returnb the
+    # If a tracker name was passed in then return the
     # specific sub-class for that tracker.
     if tracker_name:
-        params = tracker_params[tracker_name]
-        return bugzilla_tracker_factory(params)
+        try:
+            bt = customs.models.BugzillaTracker.all_trackers.get(project_name=tracker_name)
+            return bugzilla_tracker_factory(bt)
+        except mysite.customs.models.BugzillaTracker.DoesNotExist:
+            return None
     else:
         # Create a generator that yields all sub-classes.
-        for tracker in tracker_params:
-            params = tracker_params[tracker]
-            yield bugzilla_tracker_factory(params)
+        for bt in mysite.customs.models.BugzillaTracker.all_trackers.all():
+            yield bugzilla_tracker_factory(bt)
 
 ############################################################
 # Specific sub-classes for individual bug trackers
-- 
1.7.1


From e71830e1eb30158f0ef047d4496ad2e96f167daf Mon Sep 17 00:00:00 2001
From: Jack Grigg <me@jackgrigg.com>
Date: Thu, 15 Jul 2010 05:10:24 +0000
Subject: [PATCH 07/13] Modified BugzillaTracker model to use a separate model to store
 query or tracker bug URLs, and modified bugzilla importer to
 match this.

---
 mysite/customs/bugtrackers/bugzilla.py |   21 ++++++++++++++++-----
 mysite/customs/models.py               |   31 ++++++-------------------------
 2 files changed, 22 insertions(+), 30 deletions(-)

diff --git a/mysite/customs/bugtrackers/bugzilla.py b/mysite/customs/bugtrackers/bugzilla.py
index 4e73d54..ddf19d2 100644
--- a/mysite/customs/bugtrackers/bugzilla.py
+++ b/mysite/customs/bugtrackers/bugzilla.py
@@ -192,6 +192,12 @@ class BugzillaBugTracker(object):
             for bug_xml in query_xml.xpath('bug'):
                 yield bug_xml
 
+    def get_bug_id_list_from_tracker_bug_urls(self, tracker_bug_urls):
+        bug_ids = []
+        for tracker_bug_url in tracker_bug_urls:
+            bug_ids += mysite.customs.bugtrackers.bugzilla.tracker_bug2bug_ids(tracker_bug_url)
+        return list(set(bug_ids))
+
     def generate_bug_project_name(self, bb):
         return self.bug_project_name_format.format(
                 project = self.project_name,
@@ -291,12 +297,15 @@ def bugzilla_tracker_factory(bt):
 
     # Create 'generate_current_bug_xml' method
     def generate_current_bug_xml(self):
-        queries = bt.query_url
-        return self.generate_bug_xml_from_queries(queries)
+        queries = bt.bugzillaurl_set.all()
+        query_urls = [query.url for query in queries]
+        return self.generate_bug_xml_from_queries(query_urls)
 
     # Create 'get_current_bug_id_list' method
     def get_current_bug_id_list(self):
-        return mysite.customs.bugtrackers.bugzilla.tracker_bug2bug_ids(bt.query_url)
+        tracker_bugs = bt.bugzillaurl_set.all()
+        tracker_bug_urls = [tb.url for tb in tracker_bugs]
+        return self.get_bug_id_list_from_tracker_bugs(tracker_bug_urls)
 
     # Create 'extract_tracker_specific_data' method
     @staticmethod
@@ -664,8 +673,10 @@ class FedoraBugzilla(BugzillaBugTracker):
                                     bug_id_list_only=True)
 
     def get_current_bug_id_list(self):
-        return mysite.customs.bugtrackers.bugzilla.tracker_bug2bug_ids(
-                'https://bugzilla.redhat.com/show_bug.cgi?ctype=xml&id=509829')
+        tracker_bug_urls = [
+                'https://bugzilla.redhat.com/show_bug.cgi?ctype=xml&id=509829'
+                ]
+        return self.get_bug_id_list_from_tracker_bug_urls(tracker_bug_urls)
 
     @staticmethod
     def extract_tracker_specific_data(xml_data, ret_dict):
diff --git a/mysite/customs/models.py b/mysite/customs/models.py
index 465820d..7a3d053 100644
--- a/mysite/customs/models.py
+++ b/mysite/customs/models.py
@@ -54,29 +54,6 @@ class WebResponse(models.Model):
     def create_from_http_error(error):
         return None
 
-class SeparatedValuesField(models.TextField):
-    '''As exemplified on www.davidcramer.net'''
-    __metaclass__ = models.SubfieldBase
-
-    def __init__(self, *args, **kwargs):
-        self.token = kwargs.pop('token', ',')
-        super(SeparatedValuesField, self).__init__(*args, **kwargs)
-
-    def to_python(self, value):
-        if not value: return
-        if isinstance(value, list):
-            return value
-        return value.split(self.token)
-
-    def get_db_prep_value(self, value):
-        if not value: return
-        assert(isinstance(value, list) or isinstance(value, tuple))
-        return self.token.join([unicode(s) for s in value])
-
-    def value_to_string(self, obj):
-        value = self._get_val_from_obj(obj)
-        return self.get_db_prep_value(value)
-
 class BugzillaTracker(models.Model):
     '''This model stores the data for individual Bugzilla trackers.'''
     project_name = models.CharField(max_length=200, unique=True,
@@ -89,8 +66,6 @@ class BugzillaTracker(models.Model):
             ('tracker', 'Tracker bug URL')
             )
     query_url_type = models.CharField(max_length=20, choices=QUERY_URL_TYPES)
-    query_url = SeparatedValuesField(max_length=200, unique=True,
-                                            blank=False, null=False)
     BITESIZED_TYPES = (
             (None, 'None'),
             ('key', 'Keyword'),
@@ -109,3 +84,9 @@ class BugzillaTracker(models.Model):
     as_appears_in_distribution = models.CharField(max_length=200, blank=True, default='')
 
     all_trackers = models.Manager()
+
+class BugzillaURL(models.Model):
+    '''This model stores query or tracker URLs for BugzillaTracker objects.'''
+    url = models.URLField(max_length=300, unique=True,
+                          blank=False, null=False)
+    bugzilla_tracker = models.ForeignKey(BugzillaTracker)
-- 
1.7.1


From dc864e353a8c8ae5111d5b7a827d9e3dd8b046c9 Mon Sep 17 00:00:00 2001
From: Jack Grigg <me@jackgrigg.com>
Date: Thu, 15 Jul 2010 05:20:00 +0000
Subject: [PATCH 08/13] Modify generate_bug_xml_from_queries and get_bug_id_list_from_tracker_bug_urls
 in Bugzilla importer to support both lists and dictionaries.

---
 mysite/customs/bugtrackers/bugzilla.py |    9 +++++++--
 1 files changed, 7 insertions(+), 2 deletions(-)

diff --git a/mysite/customs/bugtrackers/bugzilla.py b/mysite/customs/bugtrackers/bugzilla.py
index ddf19d2..71e2815 100644
--- a/mysite/customs/bugtrackers/bugzilla.py
+++ b/mysite/customs/bugtrackers/bugzilla.py
@@ -181,8 +181,10 @@ class BugzillaBugTracker(object):
         self.bug_id_list_only = bug_id_list_only
 
     def generate_bug_xml_from_queries(self, queries):
-        for query_name in queries:
-            query_url = queries[query_name]
+        # If a dictionary has been passed in, convert it to a list.
+        if type(queries) == type({}):
+            queries = [queries[query_name] for query_name in queries]
+        for query_url in queries:
             # Check if this url has been accessed in the last day
             if url_is_more_fresh_than_one_day(query_url):
                 # Sweet, ignore this one and go on.
@@ -193,6 +195,9 @@ class BugzillaBugTracker(object):
                 yield bug_xml
 
     def get_bug_id_list_from_tracker_bug_urls(self, tracker_bug_urls):
+        # If a dictionary has been passed in, convert it to a list.
+        if type(tracker_bug_urls) == type({}):
+            tracker_bug_urls = [tracker_bug_urls[tracker_bug_name] for tracker_bug_name in tracker_bug_urls]
         bug_ids = []
         for tracker_bug_url in tracker_bug_urls:
             bug_ids += mysite.customs.bugtrackers.bugzilla.tracker_bug2bug_ids(tracker_bug_url)
-- 
1.7.1


From 41e508e2076dad5853888f3cdf7f646a2472e2eb Mon Sep 17 00:00:00 2001
From: Jack Grigg <me@jackgrigg.com>
Date: Thu, 15 Jul 2010 05:21:45 +0000
Subject: [PATCH 09/13] The running server tells me that you can't have URLs that are both
 unique and longer than 255 chars in a model. Fixed.

---
 mysite/customs/models.py |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/mysite/customs/models.py b/mysite/customs/models.py
index 7a3d053..6c35762 100644
--- a/mysite/customs/models.py
+++ b/mysite/customs/models.py
@@ -87,6 +87,6 @@ class BugzillaTracker(models.Model):
 
 class BugzillaURL(models.Model):
     '''This model stores query or tracker URLs for BugzillaTracker objects.'''
-    url = models.URLField(max_length=300, unique=True,
+    url = models.URLField(max_length=200, unique=True,
                           blank=False, null=False)
     bugzilla_tracker = models.ForeignKey(BugzillaTracker)
-- 
1.7.1


From b039cc04d1443cc442dc50585786bb4eadae1eff Mon Sep 17 00:00:00 2001
From: Jack Grigg <me@jackgrigg.com>
Date: Thu, 15 Jul 2010 05:51:49 +0000
Subject: [PATCH 10/13] Various bugfixes for changes in my last few commits.

---
 mysite/customs/bugtrackers/bugzilla.py |   18 ++++++++++--------
 1 files changed, 10 insertions(+), 8 deletions(-)

diff --git a/mysite/customs/bugtrackers/bugzilla.py b/mysite/customs/bugtrackers/bugzilla.py
index 71e2815..7865ec9 100644
--- a/mysite/customs/bugtrackers/bugzilla.py
+++ b/mysite/customs/bugtrackers/bugzilla.py
@@ -293,8 +293,8 @@ def bugzilla_tracker_factory(bt):
     def __init__(self):
         BugzillaBugTracker.__init__(self,
                                     base_url=bt.base_url,
-                                    project_name=bt.project_name
-                                    bug_project_name_format=bt.bug_project_name_format
+                                    project_name=bt.project_name,
+                                    bug_project_name_format=bt.bug_project_name_format)
 
     # Create bug query methods. It doesn't matter what type of query url
     # is stored, since the incorrectly generated method will not be used
@@ -323,7 +323,7 @@ def bugzilla_tracker_factory(bt):
 
         # Bitesized bug checks
         # Check for the bitesized keyword if it exists
-        if bt.bitesized_type == 'key'::
+        if bt.bitesized_type == 'key':
             ret_dict['good_for_newcomers'] = (bt.bitesized_text in keywords)
             ret_dict['bite_size_tag_name'] = bt.bitesized_text
         # No keyword. Check for the bitsized whiteboard tag if it exists
@@ -368,14 +368,14 @@ def bugzilla_tracker_factory(bt):
 
     # A sub-class will have either a 'generate_current_bug_xml' method or
     # a 'get_current_bug_id_list' method.
-    if bt.query_url_type = 'xml':
+    if bt.query_url_type == 'xml':
         class_dict['generate_current_bug_xml'] = generate_current_bug_xml
     else:
         class_dict['get_current_bug_id_list'] = get_current_bug_id_list
 
     # Return the generated sub-class.
-    sub-class_name = '%sBugzilla' % bt.project_name.replace(' ', '')
-    return type(sub-class_name, (BugzillaBugTracker,), class_dict)
+    subclass_name = '%sBugzilla' % bt.project_name.replace(' ', '')
+    return type(subclass_name, (BugzillaBugTracker,), class_dict)
 
 ############################################################
 # Generator of sub-classes from data
@@ -386,9 +386,11 @@ def generate_bugzilla_tracker_classes(tracker_name=None):
     if tracker_name:
         try:
             bt = customs.models.BugzillaTracker.all_trackers.get(project_name=tracker_name)
-            return bugzilla_tracker_factory(bt)
+            bt_class = bugzilla_tracker_factory(bt)
         except mysite.customs.models.BugzillaTracker.DoesNotExist:
-            return None
+            bt_class = None
+        yield bt_class
+        return
     else:
         # Create a generator that yields all sub-classes.
         for bt in mysite.customs.models.BugzillaTracker.all_trackers.all():
-- 
1.7.1


From 6c5d618872dfaa4dc1a9c241980d9bb03c78c151 Mon Sep 17 00:00:00 2001
From: Jack Grigg <me@jackgrigg.com>
Date: Fri, 16 Jul 2010 00:41:41 +0000
Subject: [PATCH 11/13] Copied current Bugzilla tests using Miro and updated them to use the
 abstract subclass generator. The old tests can be left there until
 the old Miro format is removed. (KDE tests can stay since KDE will
 be one of the special cases.)

---
 mysite/customs/tests.py |  253 +++++++++++++++++++++++++++++++++++++++++++++-
 1 files changed, 247 insertions(+), 6 deletions(-)

diff --git a/mysite/customs/tests.py b/mysite/customs/tests.py
index 792fe3b..27100e2 100644
--- a/mysite/customs/tests.py
+++ b/mysite/customs/tests.py
@@ -322,7 +322,7 @@ class BugzillaTests(django.test.TestCase):
         self.assertEqual(bug.submitter_realname, '')
 
     @mock.patch("mysite.customs.bugtrackers.bugzilla.url2bug_data")
-    def test_miro_bug_object(self, mock_xml_opener):
+    def test_old_miro_bug_object(self, mock_xml_opener):
         # Parse XML document as if we got it from the web
         mock_xml_opener.return_value = lxml.etree.XML(open(os.path.join(
             settings.MEDIA_ROOT, 'sample-data', 'miro-2294-2009-08-06.xml')).read())
@@ -350,7 +350,7 @@ Keywords: Torrent unittest""")
         self.assert_(bug.good_for_newcomers)
 
     @mock.patch("mysite.customs.bugtrackers.bugzilla.url2bug_data")
-    def test_full_grab_miro_bugs(self, mock_xml_opener):
+    def test_old_full_grab_miro_bugs(self, mock_xml_opener):
         mock_xml_opener.return_value = lxml.etree.XML(open(os.path.join(
             settings.MEDIA_ROOT, 'sample-data', 'miro-2294-2009-08-06.xml')).read())
 
@@ -368,7 +368,7 @@ Keywords: Torrent unittest""")
 
 
     @mock.patch("mysite.customs.bugtrackers.bugzilla.url2bug_data")
-    def test_miro_bugzilla_detects_closedness(self, mock_xml_opener):
+    def test_old_miro_bugzilla_detects_closedness(self, mock_xml_opener):
         cooked_xml = open(os.path.join(
             settings.MEDIA_ROOT, 'sample-data',
             'miro-2294-2009-08-06.xml')).read().replace(
@@ -388,7 +388,7 @@ Keywords: Torrent unittest""")
         self.assertEqual(Bug.open_ones.all().count(), 0)
 
     @mock.patch("mysite.customs.bugtrackers.bugzilla.url2bug_data")
-    def test_full_grab_resolved_miro_bug(self, mock_xml_opener):
+    def test_old_full_grab_resolved_miro_bug(self, mock_xml_opener):
         mock_xml_opener.return_value = lxml.etree.XML(open(os.path.join(
             settings.MEDIA_ROOT, 'sample-data', 'miro-2294-2009-08-06-RESOLVED.xml')).read())
 
@@ -402,7 +402,7 @@ Keywords: Torrent unittest""")
         self.assert_(bug.looks_closed)
 
     @mock.patch("mysite.customs.bugtrackers.bugzilla.url2bug_data")
-    def test_full_grab_miro_bugs_refreshes_older_bugs(self, mock_xml_opener):
+    def test_old_full_grab_miro_bugs_refreshes_older_bugs(self, mock_xml_opener):
         mock_xml_opener.return_value = lxml.etree.XML(open(os.path.join(
             settings.MEDIA_ROOT, 'sample-data', 'miro-2294-2009-08-06.xml')).read())
         miro = mysite.customs.bugtrackers.bugzilla.MiroBugzilla()
@@ -427,7 +427,7 @@ Keywords: Torrent unittest""")
 
     @mock.patch("mysite.customs.bugtrackers.bugzilla.url2bug_data")
     @mock.patch("mysite.customs.bugtrackers.bugzilla.MiroBugzilla.generate_current_bug_xml")
-    def test_regrab_miro_bugs_refreshes_older_bugs_even_when_missing_from_csv(self, mock_xml_bug_tree, mock_xml_opener):
+    def test_old_regrab_miro_bugs_refreshes_older_bugs_even_when_missing_from_csv(self, mock_xml_bug_tree, mock_xml_opener):
         mock_xml_opener.return_value = lxml.etree.XML(open(os.path.join(
             settings.MEDIA_ROOT, 'sample-data', 'miro-2294-2009-08-06.xml')).read())
 
@@ -457,6 +457,247 @@ Keywords: Torrent unittest""")
         bug = all_bugs[0]
         self.assertEqual(bug.people_involved, 5)
 
+    # Tests below are for the new abstracted importer. The original
+    # versions of the tests are left above until this is integrated.
+
+    @mock.patch("mysite.customs.bugtrackers.bugzilla.url2bug_data")
+    def test_miro_bug_object(self, mock_xml_opener):
+        # Parse XML document as if we got it from the web
+        mock_xml_opener.return_value = lxml.etree.XML(open(os.path.join(
+            settings.MEDIA_ROOT, 'sample-data', 'miro-2294-2009-08-06.xml')).read())
+
+        miro_tracker = mysite.customs.models.BugzillaTracker(
+                project_name='Miro',
+                base_url='http://bugzilla.pculture.org/',
+                bug_project_name_format='{project}',
+                query_url_type='xml',
+                bitesized_type='key',
+                bitesized_text='bitesized'
+                )
+        miro_tracker.save()
+        miro_tracker_query_url = mysite.customs.models.BugzillaURL(
+                url='http://bugzilla.pculture.org/buglist.cgi?bug_status=NEW&bug_status=ASSIGNED&bug_status=REOPENED&field-1-0-0=bug_status&field-1-1-0=product&field-1-2-0=keywords&keywords=bitesized&product=Miro&query_format=advanced&remaction=&type-1-0-0=anyexact&type-1-1-0=anyexact&type-1-2-0=anywords&value-1-0-0=NEW%2CASSIGNED%2CREOPENED&value-1-1-0=Miro&value-1-2-0=bitesized',
+                bugzilla_tracker=miro_tracker
+                )
+        miro_tracker_query_url.save()
+        gen_miro = mysite.customs.bugtrackers.bugzilla.generate_bugzilla_tracker_classes(tracker_name='Miro')
+        miro = gen_miro.next()
+        self.assert_(issubclass(miro, mysite.customs.bugtrackers.bugzilla.BugzillaBugTracker))
+        miro_instance = miro()
+        miro_instance.update()
+        all_bugs = Bug.all_bugs.all()
+        self.assertEqual(len(all_bugs), 1)
+        bug = all_bugs[0]
+        self.assertEqual(bug.project.name, 'Miro')
+        self.assertEqual(bug.title, "Add test for torrents that use gzip'd urls")
+        self.assertEqual(bug.description, """This broke. We should make sure it doesn't break again.
+Trac ticket id: 2294
+Owner: wguaraldi
+Reporter: nassar
+Keywords: Torrent unittest""")
+        self.assertEqual(bug.status, 'NEW')
+        self.assertEqual(bug.importance, 'normal')
+        self.assertEqual(bug.people_involved, 5)
+        self.assertEqual(bug.date_reported, datetime.datetime(2006, 6, 9, 12, 49))
+        self.assertEqual(bug.last_touched, datetime.datetime(2008, 6, 11, 23, 56, 27))
+        self.assertEqual(bug.submitter_username, 'nassar@pculture.org')
+        self.assertEqual(bug.submitter_realname, 'Nick Nassar')
+        self.assertEqual(bug.canonical_bug_link, 'http://bugzilla.pculture.org/show_bug.cgi?id=2294')
+        self.assert_(bug.good_for_newcomers)
+
+    @mock.patch("mysite.customs.bugtrackers.bugzilla.url2bug_data")
+    def test_full_grab_miro_bugs(self, mock_xml_opener):
+        mock_xml_opener.return_value = lxml.etree.XML(open(os.path.join(
+            settings.MEDIA_ROOT, 'sample-data', 'miro-2294-2009-08-06.xml')).read())
+
+        miro_tracker = mysite.customs.models.BugzillaTracker(
+                project_name='Miro',
+                base_url='http://bugzilla.pculture.org/',
+                bug_project_name_format='{project}',
+                query_url_type='xml',
+                bitesized_type='key',
+                bitesized_text='bitesized'
+                )
+        miro_tracker.save()
+        miro_tracker_query_url = mysite.customs.models.BugzillaURL(
+                url='http://bugzilla.pculture.org/buglist.cgi?bug_status=NEW&bug_status=ASSIGNED&bug_status=REOPENED&field-1-0-0=bug_status&field-1-1-0=product&field-1-2-0=keywords&keywords=bitesized&product=Miro&query_format=advanced&remaction=&type-1-0-0=anyexact&type-1-1-0=anyexact&type-1-2-0=anywords&value-1-0-0=NEW%2CASSIGNED%2CREOPENED&value-1-1-0=Miro&value-1-2-0=bitesized',
+                bugzilla_tracker=miro_tracker
+                )
+        miro_tracker_query_url.save()
+        gen_miro = mysite.customs.bugtrackers.bugzilla.generate_bugzilla_tracker_classes(tracker_name='Miro')
+        miro = gen_miro.next()
+        self.assert_(issubclass(miro, mysite.customs.bugtrackers.bugzilla.BugzillaBugTracker))
+        miro_instance = miro()
+        miro_instance.update()
+        all_bugs = Bug.all_bugs.all()
+        self.assertEqual(len(all_bugs), 1)
+        bug = all_bugs[0]
+        self.assertEqual(bug.canonical_bug_link,
+                         'http://bugzilla.pculture.org/show_bug.cgi?id=2294')
+        self.assertFalse(bug.looks_closed)
+
+        # And the new manager does find it
+        self.assertEqual(Bug.open_ones.all().count(), 1)
+
+
+    @mock.patch("mysite.customs.bugtrackers.bugzilla.url2bug_data")
+    def test_miro_bugzilla_detects_closedness(self, mock_xml_opener):
+        cooked_xml = open(os.path.join(
+            settings.MEDIA_ROOT, 'sample-data',
+            'miro-2294-2009-08-06.xml')).read().replace(
+            'NEW', 'CLOSED')
+        mock_xml_opener.return_value = lxml.etree.XML(cooked_xml)
+
+        miro_tracker = mysite.customs.models.BugzillaTracker(
+                project_name='Miro',
+                base_url='http://bugzilla.pculture.org/',
+                bug_project_name_format='{project}',
+                query_url_type='xml',
+                bitesized_type='key',
+                bitesized_text='bitesized'
+                )
+        miro_tracker.save()
+        miro_tracker_query_url = mysite.customs.models.BugzillaURL(
+                url='http://bugzilla.pculture.org/buglist.cgi?bug_status=NEW&bug_status=ASSIGNED&bug_status=REOPENED&field-1-0-0=bug_status&field-1-1-0=product&field-1-2-0=keywords&keywords=bitesized&product=Miro&query_format=advanced&remaction=&type-1-0-0=anyexact&type-1-1-0=anyexact&type-1-2-0=anywords&value-1-0-0=NEW%2CASSIGNED%2CREOPENED&value-1-1-0=Miro&value-1-2-0=bitesized',
+                bugzilla_tracker=miro_tracker
+                )
+        miro_tracker_query_url.save()
+        gen_miro = mysite.customs.bugtrackers.bugzilla.generate_bugzilla_tracker_classes(tracker_name='Miro')
+        miro = gen_miro.next()
+        self.assert_(issubclass(miro, mysite.customs.bugtrackers.bugzilla.BugzillaBugTracker))
+        miro_instance = miro()
+        miro_instance.update()
+        all_bugs = Bug.all_bugs.all()
+        self.assertEqual(len(all_bugs), 1)
+        bug = all_bugs[0]
+        self.assertEqual(bug.canonical_bug_link,
+                         'http://bugzilla.pculture.org/show_bug.cgi?id=2294')
+        self.assert_(bug.looks_closed)
+
+        # And the new manager successfully does NOT find it!
+        self.assertEqual(Bug.open_ones.all().count(), 0)
+
+    @mock.patch("mysite.customs.bugtrackers.bugzilla.url2bug_data")
+    def test_full_grab_resolved_miro_bug(self, mock_xml_opener):
+        mock_xml_opener.return_value = lxml.etree.XML(open(os.path.join(
+            settings.MEDIA_ROOT, 'sample-data', 'miro-2294-2009-08-06-RESOLVED.xml')).read())
+
+        miro_tracker = mysite.customs.models.BugzillaTracker(
+                project_name='Miro',
+                base_url='http://bugzilla.pculture.org/',
+                bug_project_name_format='{project}',
+                query_url_type='xml',
+                bitesized_type='key',
+                bitesized_text='bitesized'
+                )
+        miro_tracker.save()
+        miro_tracker_query_url = mysite.customs.models.BugzillaURL(
+                url='http://bugzilla.pculture.org/buglist.cgi?bug_status=NEW&bug_status=ASSIGNED&bug_status=REOPENED&field-1-0-0=bug_status&field-1-1-0=product&field-1-2-0=keywords&keywords=bitesized&product=Miro&query_format=advanced&remaction=&type-1-0-0=anyexact&type-1-1-0=anyexact&type-1-2-0=anywords&value-1-0-0=NEW%2CASSIGNED%2CREOPENED&value-1-1-0=Miro&value-1-2-0=bitesized',
+                bugzilla_tracker=miro_tracker
+                )
+        miro_tracker_query_url.save()
+        gen_miro = mysite.customs.bugtrackers.bugzilla.generate_bugzilla_tracker_classes(tracker_name='Miro')
+        miro = gen_miro.next()
+        self.assert_(issubclass(miro, mysite.customs.bugtrackers.bugzilla.BugzillaBugTracker))
+        miro_instance = miro()
+        miro_instance.update()
+        all_bugs = Bug.all_bugs.all()
+        self.assertEqual(len(all_bugs), 1)
+        bug = all_bugs[0]
+        self.assertEqual(bug.canonical_bug_link,
+                         'http://bugzilla.pculture.org/show_bug.cgi?id=2294')
+        self.assert_(bug.looks_closed)
+
+    @mock.patch("mysite.customs.bugtrackers.bugzilla.url2bug_data")
+    def test_full_grab_miro_bugs_refreshes_older_bugs(self, mock_xml_opener):
+        mock_xml_opener.return_value = lxml.etree.XML(open(os.path.join(
+            settings.MEDIA_ROOT, 'sample-data', 'miro-2294-2009-08-06.xml')).read())
+        miro_tracker = mysite.customs.models.BugzillaTracker(
+                project_name='Miro',
+                base_url='http://bugzilla.pculture.org/',
+                bug_project_name_format='{project}',
+                query_url_type='xml',
+                bitesized_type='key',
+                bitesized_text='bitesized'
+                )
+        miro_tracker.save()
+        miro_tracker_query_url = mysite.customs.models.BugzillaURL(
+                url='http://bugzilla.pculture.org/buglist.cgi?bug_status=NEW&bug_status=ASSIGNED&bug_status=REOPENED&field-1-0-0=bug_status&field-1-1-0=product&field-1-2-0=keywords&keywords=bitesized&product=Miro&query_format=advanced&remaction=&type-1-0-0=anyexact&type-1-1-0=anyexact&type-1-2-0=anywords&value-1-0-0=NEW%2CASSIGNED%2CREOPENED&value-1-1-0=Miro&value-1-2-0=bitesized',
+                bugzilla_tracker=miro_tracker
+                )
+        miro_tracker_query_url.save()
+        gen_miro = mysite.customs.bugtrackers.bugzilla.generate_bugzilla_tracker_classes(tracker_name='Miro')
+        miro = gen_miro.next()
+        self.assert_(issubclass(miro, mysite.customs.bugtrackers.bugzilla.BugzillaBugTracker))
+        miro_instance = miro()
+        miro_instance.update()
+
+        # Pretend there's old data lying around:
+        bug = Bug.all_bugs.get()
+        bug.people_involved = 1
+        bug.last_polled = datetime.datetime.now() - datetime.timedelta(days = 2)
+        bug.save()
+
+        mock_xml_opener.return_value = lxml.etree.XML(open(os.path.join(
+            settings.MEDIA_ROOT, 'sample-data', 'miro-2294-2009-08-06.xml')).read())
+
+        # Now refresh
+        miro_instance.update()
+
+        # Now verify there is only one bug, and its people_involved is 5
+        bug = Bug.all_bugs.get()
+        self.assertEqual(bug.people_involved, 5)
+
+
+    @mock.patch("mysite.customs.bugtrackers.bugzilla.url2bug_data")
+    @mock.patch("mysite.customs.bugtrackers.bugzilla.MiroBugzilla.generate_current_bug_xml")
+    def test_regrab_miro_bugs_refreshes_older_bugs_even_when_missing_from_csv(self, mock_xml_bug_tree, mock_xml_opener):
+        mock_xml_opener.return_value = lxml.etree.XML(open(os.path.join(
+            settings.MEDIA_ROOT, 'sample-data', 'miro-2294-2009-08-06.xml')).read())
+
+        # Situation: Assume there are zero bitesized bugs today.
+        # Desire: We re-get old bugs that don't show up in the xml bug list.
+
+        # Prereq: We have some bug with lame data:
+        bug = Bug()
+        bug.people_involved = 1
+        bug.canonical_bug_link = 'http://bugzilla.pculture.org/show_bug.cgi?id=2294'
+        bug.date_reported = datetime.datetime.now()
+        bug.last_touched = datetime.datetime.now()
+        bug.last_polled = datetime.datetime.now() - datetime.timedelta(days = 2)
+        bug.project, _ = Project.objects.get_or_create(name='Miro')
+        bug.save()
+
+        # Prepare an empty generator
+        mock_xml_bug_tree.return_value = iter([])
+
+        # Now, do a crawl and notice that we updated the bug even
+        # though the xml bug list is empty
+        
+        miro_tracker = mysite.customs.models.BugzillaTracker(
+                project_name='Miro',
+                base_url='http://bugzilla.pculture.org/',
+                bug_project_name_format='{project}',
+                query_url_type='xml',
+                bitesized_type='key',
+                bitesized_text='bitesized'
+                )
+        miro_tracker.save()
+        miro_tracker_query_url = mysite.customs.models.BugzillaURL(
+                url='http://bugzilla.pculture.org/buglist.cgi?bug_status=NEW&bug_status=ASSIGNED&bug_status=REOPENED&field-1-0-0=bug_status&field-1-1-0=product&field-1-2-0=keywords&keywords=bitesized&product=Miro&query_format=advanced&remaction=&type-1-0-0=anyexact&type-1-1-0=anyexact&type-1-2-0=anywords&value-1-0-0=NEW%2CASSIGNED%2CREOPENED&value-1-1-0=Miro&value-1-2-0=bitesized',
+                bugzilla_tracker=miro_tracker
+                )
+        miro_tracker_query_url.save()
+        gen_miro = mysite.customs.bugtrackers.bugzilla.generate_bugzilla_tracker_classes(tracker_name='Miro')
+        miro = gen_miro.next()
+        self.assert_(issubclass(miro, mysite.customs.bugtrackers.bugzilla.BugzillaBugTracker))
+        miro_instance = miro()
+        miro_instance.update()
+        all_bugs = Bug.all_bugs.all()
+        self.assertEqual(len(all_bugs), 1)
+        bug = all_bugs[0]
+        self.assertEqual(bug.people_involved, 5)
+
 class BlogCrawl(django.test.TestCase):
     def test_summary2html(self):
         yo_eacute = mysite.customs.feed.summary2html('Yo &eacute;')
-- 
1.7.1


From b6b902effb7baa8380d834e8d0bced4b8bbff632 Mon Sep 17 00:00:00 2001
From: Jack Grigg <me@jackgrigg.com>
Date: Fri, 16 Jul 2010 00:43:10 +0000
Subject: [PATCH 12/13] A few small bugfixes.

---
 mysite/customs/bugtrackers/bugzilla.py |    4 ++--
 1 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/mysite/customs/bugtrackers/bugzilla.py b/mysite/customs/bugtrackers/bugzilla.py
index 7865ec9..45731ea 100644
--- a/mysite/customs/bugtrackers/bugzilla.py
+++ b/mysite/customs/bugtrackers/bugzilla.py
@@ -375,7 +375,7 @@ def bugzilla_tracker_factory(bt):
 
     # Return the generated sub-class.
     subclass_name = '%sBugzilla' % bt.project_name.replace(' ', '')
-    return type(subclass_name, (BugzillaBugTracker,), class_dict)
+    return type(subclass_name.encode('ascii'), (BugzillaBugTracker,), class_dict)
 
 ############################################################
 # Generator of sub-classes from data
@@ -385,7 +385,7 @@ def generate_bugzilla_tracker_classes(tracker_name=None):
     # specific sub-class for that tracker.
     if tracker_name:
         try:
-            bt = customs.models.BugzillaTracker.all_trackers.get(project_name=tracker_name)
+            bt = mysite.customs.models.BugzillaTracker.all_trackers.get(project_name=tracker_name)
             bt_class = bugzilla_tracker_factory(bt)
         except mysite.customs.models.BugzillaTracker.DoesNotExist:
             bt_class = None
-- 
1.7.1


From 978100ff68d14db136417aa6200016d3e1c03ab0 Mon Sep 17 00:00:00 2001
From: Jack Grigg <me@jackgrigg.com>
Date: Fri, 16 Jul 2010 01:44:32 +0000
Subject: [PATCH 13/13] Use the abstracted subclass generator for the Bugzilla importer in
 the customs_daily_tasks class aggregator.

---
 .../management/commands/customs_daily_tasks.py     |    6 ++++--
 1 files changed, 4 insertions(+), 2 deletions(-)

diff --git a/mysite/customs/management/commands/customs_daily_tasks.py b/mysite/customs/management/commands/customs_daily_tasks.py
index 1f59145..d58022b 100644
--- a/mysite/customs/management/commands/customs_daily_tasks.py
+++ b/mysite/customs/management/commands/customs_daily_tasks.py
@@ -74,9 +74,11 @@ class Command(BaseCommand):
             instantiated.update()
 
     def find_and_update_enabled_bugzilla_instances(self):
-        enabled_bugzilla_instances = []
+        ### First, the "generate" step
+        enabled_bugzilla_instances = [subclass for subclass in
+                mysite.customs.bugtrackers.bugzilla.generate_bugzilla_tracker_classes()]
 
-        ### First, the "find" step
+        ### Second, the "find" step
         for thing_name in dir(mysite.customs.bugtrackers.bugzilla):
             thing = getattr(mysite.customs.bugtrackers.bugzilla,
                             thing_name)
-- 
1.7.1

