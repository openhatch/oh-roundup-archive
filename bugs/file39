From 6037dcd7d7fd044514d5cdab22820d9b45904b55 Mon Sep 17 00:00:00 2001
From: Jack Grigg <me@jackgrigg.com>
Date: Mon, 21 Jun 2010 06:12:55 +0000
Subject: [PATCH 01/12] Removed old unused imports from bugzilla_instances

---
 mysite/search/tasks/bugzilla_instances.py |    4 +---
 1 files changed, 1 insertions(+), 3 deletions(-)

diff --git a/mysite/search/tasks/bugzilla_instances.py b/mysite/search/tasks/bugzilla_instances.py
index 6136668..59dc9a2 100644
--- a/mysite/search/tasks/bugzilla_instances.py
+++ b/mysite/search/tasks/bugzilla_instances.py
@@ -1,9 +1,7 @@
 import datetime
 import logging
+
 import mysite.search.models
-import mysite.customs.models
-from celery.task import Task
-from celery.registry import tasks
 
 def look_at_one_fedora_bug(bug_id):
     logging.info("Was asked to look at bug %d in Fedora" % bug_id)
-- 
1.7.1


From 4e13e67976e44937fa9a5fa5b59b3a98b2624b21 Mon Sep 17 00:00:00 2001
From: Jack Grigg <me@jackgrigg.com>
Date: Fri, 25 Jun 2010 13:09:19 +0000
Subject: [PATCH 02/12] Code for the new format Bugzilla importer in the style of Trac and Roundup

---
 mysite/customs/bugtrackers/bugzilla.py             |  148 ++++++++
 .../management/commands/search_daily_tasks.py      |   18 +
 mysite/search/tasks/bugzilla_instances.py          |  384 ++++++++++++++++++++
 3 files changed, 550 insertions(+), 0 deletions(-)
 create mode 100644 mysite/customs/bugtrackers/bugzilla.py

diff --git a/mysite/customs/bugtrackers/bugzilla.py b/mysite/customs/bugtrackers/bugzilla.py
new file mode 100644
index 0000000..fd6c062
--- /dev/null
+++ b/mysite/customs/bugtrackers/bugzilla.py
@@ -0,0 +1,148 @@
+import csv
+import datetime
+
+import lxml.etree
+
+import mysite.base.helpers
+from mysite.base.decorators import cached_property
+import mysite.customs.ohloh
+
+def find_ctype_xml_form_number(forms):
+    for n, form in enumerate(forms):
+        try:
+            value = form.get_value('ctype')
+            if value == 'xml':
+                return n
+        except:
+            pass
+    raise ValueError, "Could not find the right form."
+
+def url2bug_data(url):
+    # If we are looking at a single bug then get the XML link
+    if url.find('show_bug.cgi?id=') >= 0:
+        b = mysite.customs.ohloh.mechanize_get(
+                url + '&ctype=xml')
+    else:
+        # We are looking at a page of bugs.
+
+        # Get the page of bugs
+        b = mysite.customs.ohloh.mechanize_get(url)
+
+        # Find the one form with ctype XML
+        ctype_xml_form_no = find_ctype_xml_form_number(b.forms())
+
+        # Click ze button
+        b.select_form(nr=ctype_xml_form_no)
+        b.submit()
+
+    # Get a bunch of XML back
+    bug_data = lxml.etree.XML(b.response().read())
+
+    # Return bunch of XML
+    return bug_data
+
+def tracker_bug2bug_ids(tracker_bug_url):
+    b = mysite.customs.ohloh.mechanize_get(tracker_bug_url)
+    xml = lxml.etree.XML(b.response().read())
+    depends = xml.findall('bug/dependson')
+    depends_bug_ids = [int(depend.text) for depend in depends]
+    return depends_bug_ids
+
+def get_tag_text_from_xml(xml_doc, tag_name, index = 0):
+    """Given an object representing <bug><tag>text</tag></bug>,
+    and tag_name = 'tag', returns 'text'."""
+    tags = xml_doc.xpath(tag_name)
+    try:
+        return tags[index].text
+    except IndexError:
+        return ''
+    assert False, "You should not get here."
+
+class BugzillaBug:
+    @staticmethod
+    def from_url(url):
+        base, ending = url.rsplit('/', 1)
+        show_bug, num = ending.rsplit('=', 1)
+        bug_id = int(num)
+        assert show_bug == 'show_bug.cgi?id'
+        return BugzillaBug(bug_id=bug_id,
+                           BASE_URL=base + '/')
+
+    def __init__(self, BASE_URL, bug_id=None, bug_data=None):
+        self._bug_specific_xml_data = bug_data
+        # If bug_id is not provided, try to extract it from bug_data
+        if bug_id is None:
+            if self._bug_specific_xml_data is not None:
+                self.bug_id = self._bug_id_from_bug_data()
+            else:
+                raise ValueError("bug_id must not be None if bug_data is None")
+        else:
+            self.bug_id = int(bug_id)
+        if not BASE_URL.endswith('/'):
+            BASE_URL += '/'
+        self.BASE_URL = BASE_URL
+
+    def _bug_id_from_bug_data(self):
+        return int(get_tag_text_from_xml(self.get_bug_xml_data(), 'bug_id'))
+
+    @staticmethod
+    def _who_tag_to_username_and_realname(who_tag):
+        username = who_tag.text
+        realname = who_tag.attrib.get('name', '')
+        return username, realname
+
+    @cached_property
+    def product(self):
+        return get_tag_text_from_xml(self.get_bug_xml_data(), 'product')
+
+    @cached_property
+    def component(self):
+        return get_tag_text_from_xml(self.get_bug_xml_data(), 'component')
+
+    def as_bug_specific_url(self):
+        return self.BASE_URL + 'show_bug.cgi?id=%d' % self.bug_id
+
+    def get_bug_xml_data(self):
+        # BugzillaBug object could have been created with or without data.
+        # So if no bug data in object, fill first before returning.
+        if self._bug_specific_xml_data is None:
+            self._bug_specific_xml_data = url2bug_data(self.as_bug_specific_url()).xpath('bug')[0]
+        return self._bug_specific_xml_data
+
+    @staticmethod
+    def bugzilla_count_people_involved(xml_doc):
+        """Strategy: Create a set of all the listed text values
+        inside a <who ...>(text)</who> tag
+        Return the length of said set."""
+        everyone = [tag.text for tag in xml_doc.xpath('.//who')]
+        return len(set(everyone))
+
+    @staticmethod
+    def bugzilla_date_to_datetime(date_string):
+        return mysite.base.helpers.string2naive_datetime(date_string)
+
+    def as_data_dict_for_bug_object(self, extract_tracker_specific_data):
+        xml_data = self.get_bug_xml_data()
+
+        date_reported_text = get_tag_text_from_xml(xml_data, 'creation_ts')
+        last_touched_text = get_tag_text_from_xml(xml_data, 'delta_ts')
+        u, r = self._who_tag_to_username_and_realname(xml_data.xpath('.//reporter')[0])
+        status = get_tag_text_from_xml(xml_data, 'bug_status')
+        looks_closed = status in ('RESOLVED', 'WONTFIX', 'CLOSED', 'ASSIGNED')
+
+        ret_dict = {
+            'title': get_tag_text_from_xml(xml_data, 'short_desc'),
+            'description': (get_tag_text_from_xml(xml_data, 'long_desc/thetext') or
+                           '(Empty description)'),
+            'status': status,
+            'importance': get_tag_text_from_xml(xml_data, 'bug_severity'),
+            'people_involved': self.bugzilla_count_people_involved(xml_data),
+            'date_reported': self.bugzilla_date_to_datetime(date_reported_text),
+            'last_touched': self.bugzilla_date_to_datetime(last_touched_text),
+            'submitter_username': u,
+            'submitter_realname': r,
+            'canonical_bug_link': self.as_bug_specific_url(),
+            'looks_closed': looks_closed
+            }
+        ret_dict = extract_tracker_specific_data(xml_data, ret_dict)
+        return ret_dict
diff --git a/mysite/search/management/commands/search_daily_tasks.py b/mysite/search/management/commands/search_daily_tasks.py
index ca8fd4c..5eb8b97 100644
--- a/mysite/search/management/commands/search_daily_tasks.py
+++ b/mysite/search/management/commands/search_daily_tasks.py
@@ -115,6 +115,23 @@ class Command(BaseCommand):
             instantiated = thing()
             instantiated.update()
 
+    def find_and_update_enabled_bugzilla_instances(self):
+        enabled_bugzilla_instances = []
+
+        ### First, the "find" step
+        for thing_name in dir(mysite.search.tasks.bugzilla_instances):
+            thing = getattr(mysite.search.tasks.bugzilla_instances,
+                            thing_name)
+            if hasattr(thing, 'enabled'):
+                if getattr(thing, 'enabled'):
+                    enabled_bugzilla_instances.append(thing)
+
+        ### Okay, now update!
+        for thing in enabled_bugzilla_instances:
+            logging.info("[Bugzilla] About to update %s" % thing)
+            instantiated = thing()
+            instantiated.update()
+
     def update_launchpad_hosted_projects(self):
         ### For Launchpad:
         # First, we ask the projects' bug trackers if there are new bugs we should know about
@@ -131,5 +148,6 @@ class Command(BaseCommand):
         self.find_and_update_enabled_trac_instances()
         self.find_and_update_enabled_roundup_trackers()
         self.update_bugzilla_trackers()
+        #self.find_and_update_enabled_bugzilla_instances()
         
 
diff --git a/mysite/search/tasks/bugzilla_instances.py b/mysite/search/tasks/bugzilla_instances.py
index 59dc9a2..ea06540 100644
--- a/mysite/search/tasks/bugzilla_instances.py
+++ b/mysite/search/tasks/bugzilla_instances.py
@@ -2,6 +2,7 @@ import datetime
 import logging
 
 import mysite.search.models
+import mysite.customs.bugtrackers.bugzilla
 
 def look_at_one_fedora_bug(bug_id):
     logging.info("Was asked to look at bug %d in Fedora" % bug_id)
@@ -54,3 +55,386 @@ def refresh_all_fedora_fit_and_finish_bugs():
             BUG_URL_PREFIX=mysite.customs.bugtrackers.fedora_fitfinish.BUG_URL_PREFIX)
         look_at_one_fedora_bug(bug_id=bug_id)
 
+class BugzillaBugTracker(object):
+    def __init__(self, base_url, project_name, bug_project_name_format, bug_id_list_only=False):
+        self.base_url = base_url
+        self.project_name = project_name
+        self.bug_project_name_format = bug_project_name_format
+        self.bug_id_list_only = bug_id_list_only
+
+    def generate_bug_project_name(self, bb):
+        return self.bug_project_name_format.format(
+                project = self.project_name,
+                component = bb.component)
+
+    def create_or_refresh_one_bugzilla_bug(self, bb):
+        bug_id = bb.bug_id
+        bug_url = bb.as_bug_specific_url()
+
+        try:
+            bug = mysite.search.models.Bug.all_bugs.get(
+                    canonical_bug_link=bug_url)
+            # Found an existing bug. Does it need refreshing?
+            if bug.data_is_more_fresh_than_one_day():
+                logging.info("[Bugzilla] Bug %d from %s is fresh. Doing nothing!" % (bug_id, self.project_name))
+                return False # sweet
+        except mysite.search.models.Bug.DoesNotExist:
+            # This is a new bug
+            bug = mysite.search.models.Bug(canonical_bug_link = bug_url)
+
+        # Looks like we have some refreshing to do.
+        logging.info("[Bugzilla] Refreshing bug %d from %s." % (bug_id, self.project_name))
+        # Get the dictionary of data to put into the bug. The function for
+        # obtaining tracker-specific data is passed in.
+        data = bb.as_data_dict_for_bug_object(self.extract_tracker_specific_data)
+
+        # Fill that bug!
+        for key in data:
+            value = data[key]
+            setattr(bug, key, value)
+
+        # Find or create the project for the bug and save it
+        bug_project_name = self.generate_bug_project_name(bb)
+        if bug_project_name == '':
+            raise ValueError("Can't have bug_project_name as ''")
+        project_from_name, _ = mysite.search.models.Project.objects.get_or_create(name=bug_project_name)
+        if bug.project_id != project_from_name.id:
+            bug.project = project_from_name
+        bug.last_polled = datetime.datetime.utcnow()
+        bug.save()
+        logging.info("[Bugzilla] Finished with %d from %s." % (bug_id, self.project_name))
+        return True
+
+    def refresh_all_bugs(self):
+        for bug in mysite.search.models.Bug.all_bugs.filter(
+                canonical_bug_link__contains=self.base_url):
+            bb = mysite.customs.bugtrackers.bugzilla.BugzillaBug.from_url(
+                    bug.canonical_bug_link)
+            self.create_or_refresh_one_bugzilla_bug(bb=bb)
+
+    def update(self):
+        logging.info("[Bugzilla] Started refreshing all %s bugs" % self.project_name)
+
+        # First, go through and create or refresh all the bugs that
+        # we are configured to track. This will add new bugs and
+        # update current ones. Bugzilla doesn't return a nice
+        # CSV list of bug ids, but instead gives an entire XML tree
+        # of bug data for the bugs matching the query. To save on
+        # network traffic, the bug data will be passed to the refresher.
+        if self.bug_id_list_only:
+            # If we have a tracking bug, then we can't get an xml tree
+            # of bug data. Instead we have to use the bug ids pulled
+            # from the dependencies of the tracking bug.
+            current_bug_id_list = self.get_current_bug_id_list()
+            for bug_id in current_bug_id_list:
+                bb = mysite.customs.bugtrackers.bugzilla.BugzillaBug(
+                        BASE_URL=self.base_url,
+                        bug_id=bug_id)
+                self.create_or_refresh_one_bugzilla_bug(bb=bb)
+        else:
+            logging.info("[Bugzilla] Fetching XML data for bugs in tracker...")
+            current_xml_bug_tree = self.get_current_xml_bug_tree()
+            for bug_data in current_xml_bug_tree.xpath('bug'):
+                bb = mysite.customs.bugtrackers.bugzilla.BugzillaBug(
+                        BASE_URL=self.base_url,
+                        bug_data=bug_data)
+                self.create_or_refresh_one_bugzilla_bug(bb=bb)
+
+        # Then refresh all the bugs we have from this tracker. This
+        # should skip over all the bugs except the ones that didn't
+        # appear in the above query. Usually this is closed bugs.
+        self.refresh_all_bugs()
+
+class MiroBugzilla(BugzillaBugTracker):
+    enabled = True
+
+    def __init__(self):
+        BugzillaBugTracker.__init__(self,
+                                    base_url='http://bugzilla.pculture.org/',
+                                    project_name='Miro',
+                                    bug_project_name_format='{project}')
+
+    def get_current_xml_bug_tree(self):
+        return mysite.customs.bugtrackers.bugzilla.url2bug_data(
+                'http://bugzilla.pculture.org/buglist.cgi?bug_status=NEW&bug_status=ASSIGNED&bug_status=REOPENED&field-1-0-0=bug_status&field-1-1-0=product&field-1-2-0=keywords&keywords=bitesized&product=Miro&query_format=advanced&remaction=&type-1-0-0=anyexact&type-1-1-0=anyexact&type-1-2-0=anywords&value-1-0-0=NEW%2CASSIGNED%2CREOPENED&value-1-1-0=Miro&value-1-2-0=bitesized')
+
+    @staticmethod
+    def extract_tracker_specific_data(xml_data, ret_dict):
+        # Make modifications to ret_dict using provided xml data
+        keywords_text = mysite.customs.bugtrackers.bugzilla.get_tag_text_from_xml(xml_data, 'keywords')
+        keywords = map(lambda s: s.strip(),
+                       keywords_text.split(','))
+        ret_dict['good_for_newcomers'] = ('bitesized' in keywords)
+        # Then pass ret_dict back
+        return ret_dict
+
+class KDEBugzilla(BugzillaBugTracker):
+    enabled = True
+
+    def __init__(self):
+        BugzillaBugTracker.__init__(self,
+                                    base_url='https://bugs.kde.org/',
+                                    project_name='KDE',
+                                    bug_project_name_format='')
+
+    def get_current_xml_bug_tree(self):
+        return mysite.customs.bugtrackers.bugzilla.url2bug_data(
+                'https://bugs.kde.org/buglist.cgi?query_format=advanced&short_desc_type=allwordssubstr&short_desc=&long_desc_type=allwordssubstr&long_desc=&bug_file_loc_type=allwordssubstr&bug_file_loc=&keywords_type=allwords&keywords=junior-jobs&bug_status=UNCONFIRMED&bug_status=NEW&bug_status=REOPENED&bug_status=NEEDSINFO&bug_status=VERIFIED&resolution=---&emailtype1=substring&email1=&emailtype2=substring&email2=&bugidtype=include&bug_id=&votes=&chfieldfrom=&chfieldto=Now&chfieldvalue=&cmdtype=doit&order=Reuse+same+sort+as+last+time&field0-0-0=noop&type0-0-0=noop&value0-0-0=')
+
+    @staticmethod
+    def extract_tracker_specific_data(xml_data, ret_dict):
+        # Make modifications to ret_dict using provided metadata
+        keywords_text = mysite.customs.bugtrackers.bugzilla.get_tag_text_from_xml(xml_data, 'keywords')
+        keywords = map(lambda s: s.strip(),
+                       keywords_text.split(','))
+        ret_dict['good_for_newcomers'] = ('junior-jobs' in keywords)
+        # Remove 'JJ:' from title if present
+        if ret_dict['title'].startswith("JJ:"):
+            ret_dict['title'] = ret_dict['title'][3:].strip()
+        # Set 'concerns_just_documentation' if needed
+        product = mysite.customs.bugtrackers.bugzilla.get_tag_text_from_xml(xml_data, 'product')
+        if product == 'docs':
+            ret_dict['concerns_just_documentation'] = True
+        # Then pass ret_dict back
+        return ret_dict
+
+    def generate_bug_project_name(self, bb):
+        product = bb.product
+        reasonable_products = set([
+            'Akonadi',
+            'Phonon'
+            'kmail',
+            'Rocs',
+            'akregator',
+            'amarok',
+            'ark',
+            'cervisia',
+            'k3b',
+            'kappfinder',
+            'kbabel',
+            'kdeprint',
+            'kdesktop',
+            'kfile',
+            'kfourinline',
+            'khotkeys',
+            'kio',
+            'kmail',
+            'kmplot',
+            'koffice',
+            'kompare',
+            'konqueror',
+            'kopete',
+            'kpat',
+            'kphotoalbum',
+            'krita',
+            'ksmserver',
+            'kspread',
+            'ksysguard',
+            'ktimetracker',
+            'kwin',
+            'kword',
+            'marble',
+            'okular',
+            'plasma',
+            'printer-applet',
+            'rsibreak',
+            'step',
+            'systemsettings',
+            'kdelibs',
+            'kcontrol',
+            'korganizer',
+            'kipiplugins',
+            'Phonon',
+            'dolphin',
+            'umbrello']
+            )
+        products_to_be_renamed = {
+            'digikamimageplugins': 'digikam image plugins',
+            'Network Management': 'KDE Network Management',
+            'telepathy': 'telepathy for KDE',
+            'docs': 'KDE documentation',
+            }
+        component = bb.component
+        things = (product, component)
+
+        if product in reasonable_products:
+            bug_project_name = product
+        else:
+            if product in products_to_be_renamed:
+                bug_project_name = products_to_be_renamed[product]
+            else:
+                logging.info("Guessing on KDE subproject name. Found %s" %  repr(things))
+                bug_project_name = product
+        return bug_project_name
+
+class MediaWikiBugzilla(BugzillaBugTracker):
+    enabled = True
+
+    def __init__(self):
+        BugzillaBugTracker.__init__(self,
+                                    base_url='https://bugzilla.wikimedia.org/',
+                                    project_name='MediaWiki',
+                                    bug_project_name_format='')
+
+    def get_current_xml_bug_tree(self):
+        return mysite.customs.bugtrackers.bugzilla.url2bug_data(
+                'https://bugzilla.wikimedia.org/buglist.cgi?keywords=easy&query_format=advanced&keywords_type=allwords&bug_status=NEW&bug_status=ASSIGNED&bug_status=REOPENED&bug_status=VERIFIED&resolution=LATER&resolution=---')
+
+    @staticmethod
+    def extract_tracker_specific_data(xml_data, ret_dict):
+        # Make modifications to ret_dict using provided metadata
+        # Check for the bitesized keyword
+        keywords_text = mysite.customs.bugtrackers.bugzilla.get_tag_text_from_xml(xml_data, 'keywords')
+        keywords = map(lambda s: s.strip(),
+                       keywords_text.split(','))
+        ret_dict['good_for_newcomers'] = ('easy' in keywords)
+        # Then pass ret_dict back
+        return ret_dict
+
+    def generate_bug_project_name(self, bb):
+        product = bb.product
+        if product == 'MediaWiki extensions':
+            bug_project_name = bb.component
+            if bug_project_name in ('FCKeditor', 'Gadgets'):
+                bug_project_name += ' for MediaWiki'
+        else:
+            bug_project_name = product
+        return bug_project_name
+
+class GnomeBugzilla(BugzillaBugTracker):
+    enabled = True
+
+    def __init__(self):
+        BugzillaBugTracker.__init__(self,
+                                    base_url='https://bugzilla.gnome.org/',
+                                    project_name='Gnome',
+                                    bug_project_name_format='')
+
+    def get_current_xml_bug_tree(self):
+        return mysite.customs.bugtrackers.bugzilla.url2bug_data(
+                'https://bugzilla.gnome.org/buglist.cgi?columnlist=id&keywords=gnome-love&query_format=advanced&resolution=---')
+
+    @staticmethod
+    def extract_tracker_specific_data(xml_data, ret_dict):
+        # Make modifications to ret_dict using provided metadata
+        # Check for the bitesized keyword
+        keywords_text = mysite.customs.bugtrackers.bugzilla.get_tag_text_from_xml(xml_data, 'keywords')
+        keywords = map(lambda s: s.strip(),
+                       keywords_text.split(','))
+        ret_dict['good_for_newcomers'] = ('gnome-love' in keywords)
+        # Then pass ret_dict back
+        return ret_dict
+
+    def generate_bug_project_name(self, bb):
+        bug_project_name = bb.product
+        gnome2openhatch = {'general': 'GNOME (general)',
+                           'website': 'GNOME (website)'}
+        if bug_project_name in gnome2openhatch:
+            bug_project_name=gnome2openhatch[bug_project_name]
+        return bug_project_name
+
+class MozillaBugzilla(BugzillaBugTracker):
+    enabled = True
+
+    def __init__(self):
+        BugzillaBugTracker.__init__(self,
+                                    base_url='https://bugzilla.mozilla.org/',
+                                    project_name='Mozilla',
+                                    bug_project_name_format='')
+
+    def get_current_xml_bug_tree(self):
+        return mysite.customs.bugtrackers.bugzilla.url2bug_data(
+                'https://bugzilla.mozilla.org/buglist.cgi?resolution=---;status_whiteboard_type=substring;query_format=advanced;status_whiteboard=[good%20first%20bug]')
+
+    @staticmethod
+    def extract_tracker_specific_data(xml_data, ret_dict):
+        # Make modifications to ret_dict using provided metadata
+        # Check for the bitesized keyword
+        whiteboard_text = mysite.customs.bugtrackers.bugzilla.get_tag_text_from_xml(xml_data, 'status_whiteboard')
+        ret_dict['good_for_newcomers'] = (whiteboard_text == '[good first bug]')
+        # Then pass ret_dict back
+        return ret_dict
+
+    def generate_bug_project_name(self, bb):
+        ### Special-case the project names we know about
+        mozilla2openhatch = {'Core': 'Mozilla Core',
+                             'Firefox': 'Firefox',
+                             'MailNews Core': 'Mozilla Messaging',
+                             'addons.mozilla.org': 'addons.mozilla.org',
+                             'Thunderbird': 'Thunderbird',
+                             'Testing': 'Mozilla automated testing',
+                             'Directory': 'Mozilla LDAP',
+                             'mozilla.org': 'mozilla.org',
+                             'SeaMonkey': 'SeaMonkey',
+                             'Toolkit': 'Mozilla Toolkit',
+                             'support.mozilla.com': 'support.mozilla.com',
+                             'Camino': 'Camino',
+                             'Calendar': 'Mozilla Calendar',
+                             'Mozilla Localizations': 'Mozilla Localizations',
+                             }
+        if bb.product == 'Other Applications':
+            bug_project_name = 'Mozilla ' + bb.component
+        else:
+            bug_project_name = mozilla2openhatch[bb.product]
+        return bug_project_name
+
+class FedoraBugzilla(BugzillaBugTracker):
+    enabled = True
+
+    def __init__(self):
+        BugzillaBugTracker.__init__(self,
+                                    base_url='https://bugzilla.redhat.com/',
+                                    project_name='Fedora',
+                                    bug_project_name_format='{component}',
+                                    bug_id_list_only=True)
+
+    def get_current_bug_id_list(self):
+        return mysite.customs.bugtrackers.bugzilla.tracker_bug2bug_ids(
+                'https://bugzilla.redhat.com/show_bug.cgi?ctype=xml&id=509829')
+
+    @staticmethod
+    def extract_tracker_specific_data(xml_data, ret_dict):
+        # Make modifications to ret_dict using provided metadata
+        # Check for the bitesized keyword
+        keywords_text = mysite.customs.bugtrackers.bugzilla.get_tag_text_from_xml(xml_data, 'keywords')
+        keywords = map(lambda s: s.strip(),
+                       keywords_text.split(','))
+        ret_dict['good_for_newcomers'] = True # Since they are 'fit and finish'
+        # Set the distribution tag
+        ret_dict['as_appears_in_distribution'] = 'Fedora'
+        # Then pass ret_dict back
+        return ret_dict
+
+# The generic class for Bugzilla trackers. Copy it.
+# If the project has a tracker bug for the bugs to be imported,
+# set bug_id_list_only=True in BugzillaBugTracker.__init__ and
+# replace get_current_xml_bug_tree with get_current_bug_id_list
+class GenBugzilla(BugzillaBugTracker):
+    enabled = False
+
+    def __init__(self):
+        BugzillaBugTracker.__init__(self,
+                                    base_url='',
+                                    project_name='',
+                                    bug_project_name_format='')
+
+    def get_current_xml_bug_tree(self):
+        return mysite.customs.bugtrackers.bugzilla.url2bug_data(
+                '')
+
+    @staticmethod
+    def extract_tracker_specific_data(xml_data, ret_dict):
+        # Make modifications to ret_dict using provided metadata
+        # Check for the bitesized keyword
+        keywords_text = mysite.customs.bugtrackers.bugzilla.get_tag_text_from_xml(xml_data, 'keywords')
+        keywords = map(lambda s: s.strip(),
+                       keywords_text.split(','))
+        ret_dict['good_for_newcomers'] = ('' in keywords)
+        # Then pass ret_dict back
+        return ret_dict
+
+    # The format string method for generating the project name can be
+    # overloaded by uncommenting the function below.
+    #def generate_bug_project_name(self, bb):
+        #return bug_project_name
+
-- 
1.7.1


From 3b73d6643b1db1a5d79747f88fe40dca09fff9ea Mon Sep 17 00:00:00 2001
From: Jack Grigg <me@jackgrigg.com>
Date: Fri, 25 Jun 2010 15:21:10 +0000
Subject: [PATCH 03/12] Cloned Bugzilla TestCase and modified it to test the new format importer.

---
 mysite/customs/tests.py |  166 +++++++++++++++++++++++++++++++++++++++++++++++
 1 files changed, 166 insertions(+), 0 deletions(-)

diff --git a/mysite/customs/tests.py b/mysite/customs/tests.py
index d1f44ac..8ac5688 100644
--- a/mysite/customs/tests.py
+++ b/mysite/customs/tests.py
@@ -439,6 +439,172 @@ Keywords: Torrent unittest""")
         bug = all_bugs[0]
         self.assertEqual(bug.people_involved, 5)
 
+class BugzillaNewFormatTests(django.test.TestCase):
+    fixtures = ['miro-project']
+    @mock.patch("mysite.customs.bugtrackers.bugzilla.url2bug_data")
+    def test_kde(self, mock_xml_opener):
+        p = Project.create_dummy(name='KDE')
+        mock_xml_opener.return_value = lxml.etree.XML(open(os.path.join(
+            settings.MEDIA_ROOT, 'sample-data', 'kde-117760-2010-04-09.xml')).read())
+        kde = mysite.search.tasks.bugzilla_instances.KDEBugzilla()
+        kde.update()
+        all_bugs = Bug.all_bugs.all()
+        self.assertEqual(len(all_bugs), 1)
+        bug = all_bugs[0]
+        self.assertEqual(bug.submitter_username, 'hasso kde org')
+        self.assertEqual(bug.submitter_realname, 'Hasso Tepper')
+
+    @mock.patch("mysite.customs.bugtrackers.bugzilla.url2bug_data")
+    def test_kde_harder_bug(self, mock_xml_opener):
+        p = Project.create_dummy(name='KDE')
+        mock_xml_opener.return_value = lxml.etree.XML(open(os.path.join(
+            settings.MEDIA_ROOT, 'sample-data', 'kde-182054-2010-04-09.xml')).read())
+        kde = mysite.search.tasks.bugzilla_instances.KDEBugzilla()
+        kde.update()
+        all_bugs = Bug.all_bugs.all()
+        self.assertEqual(len(all_bugs), 1)
+        bug = all_bugs[0]
+        self.assertEqual(bug.submitter_username, 'jedd progsoc org')
+        self.assertEqual(bug.submitter_realname, '')
+
+    @mock.patch("mysite.customs.bugtrackers.bugzilla.url2bug_data")
+    def test_miro_bug_object(self, mock_xml_opener):
+        # Parse XML document as if we got it from the web
+        mock_xml_opener.return_value = lxml.etree.XML(open(os.path.join(
+            settings.MEDIA_ROOT, 'sample-data', 'miro-2294-2009-08-06.xml')).read())
+
+        miro = mysite.search.tasks.bugzilla_instances.MiroBugzilla()
+        miro.update()
+        all_bugs = Bug.all_bugs.all()
+        self.assertEqual(len(all_bugs), 1)
+        bug = all_bugs[0]
+        self.assertEqual(bug.project.name, 'Miro')
+        self.assertEqual(bug.title, "Add test for torrents that use gzip'd urls")
+        self.assertEqual(bug.description, """This broke. We should make sure it doesn't break again.
+Trac ticket id: 2294
+Owner: wguaraldi
+Reporter: nassar
+Keywords: Torrent unittest""")
+        self.assertEqual(bug.status, 'NEW')
+        self.assertEqual(bug.importance, 'normal')
+        self.assertEqual(bug.people_involved, 5)
+        self.assertEqual(bug.date_reported, datetime.datetime(2006, 6, 9, 12, 49))
+        self.assertEqual(bug.last_touched, datetime.datetime(2008, 6, 11, 23, 56, 27))
+        self.assertEqual(bug.submitter_username, 'nassar@pculture.org')
+        self.assertEqual(bug.submitter_realname, 'Nick Nassar')
+        self.assertEqual(bug.canonical_bug_link, 'http://bugzilla.pculture.org/show_bug.cgi?id=2294')
+        self.assert_(bug.good_for_newcomers)
+
+    @mock.patch("mysite.customs.bugtrackers.bugzilla.url2bug_data")
+    def test_full_grab_miro_bugs(self, mock_xml_opener):
+        mock_xml_opener.return_value = lxml.etree.XML(open(os.path.join(
+            settings.MEDIA_ROOT, 'sample-data', 'miro-2294-2009-08-06.xml')).read())
+
+        miro = mysite.search.tasks.bugzilla_instances.MiroBugzilla()
+        miro.update()
+        all_bugs = Bug.all_bugs.all()
+        self.assertEqual(len(all_bugs), 1)
+        bug = all_bugs[0]
+        self.assertEqual(bug.canonical_bug_link,
+                         'http://bugzilla.pculture.org/show_bug.cgi?id=2294')
+        self.assertFalse(bug.looks_closed)
+
+        # And the new manager does find it
+        self.assertEqual(Bug.open_ones.all().count(), 1)
+
+
+    @mock.patch("mysite.customs.bugtrackers.bugzilla.url2bug_data")
+    def test_miro_bugzilla_detects_closedness(self, mock_xml_opener):
+        cooked_xml = open(os.path.join(
+            settings.MEDIA_ROOT, 'sample-data',
+            'miro-2294-2009-08-06.xml')).read().replace(
+            'NEW', 'CLOSED')
+        mock_xml_opener.return_value = lxml.etree.XML(cooked_xml)
+
+        miro = mysite.search.tasks.bugzilla_instances.MiroBugzilla()
+        miro.update()
+        all_bugs = Bug.all_bugs.all()
+        self.assertEqual(len(all_bugs), 1)
+        bug = all_bugs[0]
+        self.assertEqual(bug.canonical_bug_link,
+                         'http://bugzilla.pculture.org/show_bug.cgi?id=2294')
+        self.assert_(bug.looks_closed)
+
+        # And the new manager successfully does NOT find it!
+        self.assertEqual(Bug.open_ones.all().count(), 0)
+
+    @mock.patch("mysite.customs.bugtrackers.bugzilla.url2bug_data")
+    def test_full_grab_resolved_miro_bug(self, mock_xml_opener):
+        mock_xml_opener.return_value = lxml.etree.XML(open(os.path.join(
+            settings.MEDIA_ROOT, 'sample-data', 'miro-2294-2009-08-06-RESOLVED.xml')).read())
+
+        miro = mysite.search.tasks.bugzilla_instances.MiroBugzilla()
+        miro.update()
+        all_bugs = Bug.all_bugs.all()
+        self.assertEqual(len(all_bugs), 1)
+        bug = all_bugs[0]
+        self.assertEqual(bug.canonical_bug_link,
+                         'http://bugzilla.pculture.org/show_bug.cgi?id=2294')
+        self.assert_(bug.looks_closed)
+
+    @mock.patch("mysite.customs.bugtrackers.bugzilla.url2bug_data")
+    def test_full_grab_miro_bugs_refreshes_older_bugs(self, mock_xml_opener):
+        mock_xml_opener.return_value = lxml.etree.XML(open(os.path.join(
+            settings.MEDIA_ROOT, 'sample-data', 'miro-2294-2009-08-06.xml')).read())
+        miro = mysite.search.tasks.bugzilla_instances.MiroBugzilla()
+        miro.update()
+
+        # Pretend there's old data lying around:
+        bug = Bug.all_bugs.get()
+        bug.people_involved = 1
+        bug.save()
+
+        mock_xml_opener.return_value = lxml.etree.XML(open(os.path.join(
+            settings.MEDIA_ROOT, 'sample-data', 'miro-2294-2009-08-06.xml')).read())
+
+        # Now refresh
+        miro.update()
+
+        # Now verify there is only one bug, and its people_involved is 5
+        bug = Bug.all_bugs.get()
+        self.assertEqual(bug.people_involved, 5)
+
+
+    @mock.patch("mysite.customs.bugtrackers.bugzilla.url2bug_data")
+    @mock.patch("mysite.search.tasks.bugzilla_instances.MiroBugzilla.get_current_xml_bug_tree")
+    def test_regrab_miro_bugs_refreshes_older_bugs_even_when_missing_from_csv(self, mock_xml_bug_tree, mock_xml_opener):
+        mock_xml_opener.return_value = lxml.etree.XML(open(os.path.join(
+            settings.MEDIA_ROOT, 'sample-data', 'miro-2294-2009-08-06.xml')).read())
+
+        # Situation: Assume there are zero bitesized bugs today.
+        # Desire: We re-get old bugs that don't show up in the xml bug list.
+
+        # Prereq: We have some bug with lame data:
+        bug = Bug()
+        bug.people_involved = 1
+        bug.canonical_bug_link = 'http://bugzilla.pculture.org/show_bug.cgi?id=2294'
+        bug.date_reported = datetime.datetime.now()
+        bug.last_touched = datetime.datetime.now()
+        bug.last_polled = datetime.datetime.now()
+        bug.project, _ = Project.objects.get_or_create(name='Miro')
+        bug.save()
+
+        # Prepare a fake xml bug list that is empty
+        mock_xml_bug_tree.return_value = lxml.etree.XML('''\
+<bugzilla>
+</bugzilla>
+''')
+
+        # Now, do a crawl and notice that we updated the bug even
+        # though the xml bug list is empty
+        
+        miro = mysite.search.tasks.bugzilla_instances.MiroBugzilla()
+        miro.update()
+        all_bugs = Bug.all_bugs.all()
+        self.assertEqual(len(all_bugs), 1)
+        bug = all_bugs[0]
+        self.assertEqual(bug.people_involved, 5)
+
 class BlogCrawl(django.test.TestCase):
     def test_summary2html(self):
         yo_eacute = mysite.customs.feed.summary2html('Yo &eacute;')
-- 
1.7.1


From aa50c9ca65fcd325dd9e883a5673ecce005d790f Mon Sep 17 00:00:00 2001
From: Jack Grigg <me@jackgrigg.com>
Date: Fri, 25 Jun 2010 15:46:08 +0000
Subject: [PATCH 04/12] Corrected the new Bugzilla TestCase so that artificial Bug objects to be refreshed were actually created stale.

---
 mysite/customs/tests.py |    3 ++-
 1 files changed, 2 insertions(+), 1 deletions(-)

diff --git a/mysite/customs/tests.py b/mysite/customs/tests.py
index 8ac5688..4733cc6 100644
--- a/mysite/customs/tests.py
+++ b/mysite/customs/tests.py
@@ -557,6 +557,7 @@ Keywords: Torrent unittest""")
         # Pretend there's old data lying around:
         bug = Bug.all_bugs.get()
         bug.people_involved = 1
+        bug.last_polled = datetime.datetime.now() - datetime.timedelta(days = 2)
         bug.save()
 
         mock_xml_opener.return_value = lxml.etree.XML(open(os.path.join(
@@ -585,7 +586,7 @@ Keywords: Torrent unittest""")
         bug.canonical_bug_link = 'http://bugzilla.pculture.org/show_bug.cgi?id=2294'
         bug.date_reported = datetime.datetime.now()
         bug.last_touched = datetime.datetime.now()
-        bug.last_polled = datetime.datetime.now()
+        bug.last_polled = datetime.datetime.now() - datetime.timedelta(days = 2)
         bug.project, _ = Project.objects.get_or_create(name='Miro')
         bug.save()
 
-- 
1.7.1


From 8c9456c893ebfaf4fec92e07d64180826a7e22a4 Mon Sep 17 00:00:00 2001
From: Jack Grigg <me@jackgrigg.com>
Date: Fri, 25 Jun 2010 16:27:57 +0000
Subject: [PATCH 05/12] Chopped out old unnecessary Bugzilla importer code with a large axe.

---
 mysite/customs/bugtrackers/bugzilla_general.py     |   94 -------------
 mysite/customs/bugtrackers/fedora_fitfinish.py     |   54 --------
 mysite/customs/bugtrackers/gnome_love.py           |   93 -------------
 mysite/customs/bugtrackers/kde.py                  |  106 ---------------
 mysite/customs/bugtrackers/mozilla.py              |  110 ---------------
 mysite/customs/bugtrackers/wikimedia.py            |   44 ------
 mysite/customs/miro.py                             |  141 --------------------
 .../management/commands/search_daily_tasks.py      |   54 +-------
 mysite/search/tasks/__init__.py                    |    4 -
 mysite/search/tasks/bugzilla_instances.py          |   51 -------
 10 files changed, 4 insertions(+), 747 deletions(-)
 delete mode 100644 mysite/customs/bugtrackers/bugzilla_general.py
 delete mode 100644 mysite/customs/bugtrackers/fedora_fitfinish.py
 delete mode 100644 mysite/customs/bugtrackers/gnome_love.py
 delete mode 100644 mysite/customs/bugtrackers/kde.py
 delete mode 100644 mysite/customs/bugtrackers/mozilla.py
 delete mode 100644 mysite/customs/bugtrackers/wikimedia.py
 delete mode 100644 mysite/customs/miro.py

diff --git a/mysite/customs/bugtrackers/bugzilla_general.py b/mysite/customs/bugtrackers/bugzilla_general.py
deleted file mode 100644
index f67f642..0000000
--- a/mysite/customs/bugtrackers/bugzilla_general.py
+++ /dev/null
@@ -1,94 +0,0 @@
-import urllib2
-import logging
-import mechanize
-import lxml.etree
-
-import mysite.customs.miro
-import mysite.customs.ohloh
-import mysite.customs.models
-import mysite.search.models
-
-from itertools import chain
-
-def bug_url2bug_id(url, BUG_URL_PREFIX):
-    before, after = url.split(BUG_URL_PREFIX)
-    return int(after)
-
-def bug_id2bug_url(bug_id, BUG_URL_PREFIX):
-    return BUG_URL_PREFIX + str(bug_id)
-
-def get_remote_bug_ids_already_stored(BUG_URL_PREFIX):
-    for bug in mysite.search.models.Bug.all_bugs.filter(
-        canonical_bug_link__contains=BUG_URL_PREFIX):
-        yield bug_url2bug_id(
-            bug.canonical_bug_link, BUG_URL_PREFIX=BUG_URL_PREFIX)
-
-def find_ctype_xml_form_number(forms):
-    for n, form in enumerate(forms):
-        try:
-            value = form.get_value('ctype')
-            if value == 'xml':
-                return n
-        except:
-            pass
-    raise ValueError, "Could not find the right form."
-
-def query_url2bug_objects(BUG_URL_PREFIX,
-                          QUERY_URL,
-                          project_finder_plugin,
-                          detect_if_good_for_newcomers_plugin):
-    b = mysite.customs.ohloh.mechanize_get(QUERY_URL)
-
-    # find the one form with ctype XML
-    ctype_xml_form_no = find_ctype_xml_form_number(b.forms())
-
-    # Click ze button
-    b.select_form(nr=ctype_xml_form_no)
-    b.submit()
-
-    # Get a bunch of XML back
-    bugzila_elt = lxml.etree.XML(b.response().read())
-
-    ret = {}
-
-    for bug in bugzila_elt.xpath('bug'):
-        bug_obj = mysite.customs.miro.bug_elt2bug_object(
-            bug, canonical_bug_link_format_string=BUG_URL_PREFIX + '%d',
-            gen_project=project_finder_plugin
-            )
-        bug_id = mysite.customs.bugtrackers.bugzilla_general.bug_url2bug_id(
-            bug_obj.canonical_bug_link, BUG_URL_PREFIX=BUG_URL_PREFIX)
-        detect_if_good_for_newcomers_plugin(bug, bug_obj)
-        ret[bug_id] = bug_obj
-        
-    return ret
-
-def grab(current_bug_id2bug_objs,
-         BUG_URL_PREFIX):
-    bug_ids = chain(
-        current_bug_id2bug_objs.keys(),
-        get_remote_bug_ids_already_stored(BUG_URL_PREFIX))
-
-    for bug_id in set(bug_ids):
-        # Sometimes create_bug_object_for_remote_bug_id will fail to create
-        # a bug because it's somehow gone missing. For those cases:
-
-        # create canonical_bug_link in this function to avoid assuming the
-        # returned bug is not None.
-        canonical_bug_link = BUG_URL_PREFIX + str(bug_id)
-
-        # If there is already a bug with this canonical_bug_link in
-        # the DB, just delete it. Same story if the bug doens't 404!
-        bugs_this_one_replaces = mysite.search.models.Bug.all_bugs.filter(
-            canonical_bug_link=canonical_bug_link)
-        for delete_me in bugs_this_one_replaces:
-            delete_me.delete()
-
-        if bug_id not in current_bug_id2bug_objs:
-            continue # If the bug is not in the new data set, we're done here.
-
-        bug = current_bug_id2bug_objs[bug_id]
-
-        # Otherwise, print and save the sucker!
-        logging.info("Got a bug: %s" % bug)
-        bug.save()
diff --git a/mysite/customs/bugtrackers/fedora_fitfinish.py b/mysite/customs/bugtrackers/fedora_fitfinish.py
deleted file mode 100644
index 01e3a54..0000000
--- a/mysite/customs/bugtrackers/fedora_fitfinish.py
+++ /dev/null
@@ -1,54 +0,0 @@
-import urllib2
-import mysite.customs.miro
-import mechanize
-import mysite.customs.ohloh
-import lxml.etree
-import mysite.customs.models
-import mysite.search.models
-import mysite.customs.bugtrackers.bugzilla_general
-
-BUG_URL_PREFIX='https://bugzilla.redhat.com/show_bug.cgi?id='
-FIT_AND_FINISH_TRACKING_BUG='https://bugzilla.redhat.com/show_bug.cgi?ctype=xml&id=509829'
-
-def reload_bug_obj(bug_obj):
-    def project_finder_plugin(bug_elt):
-        component = bug_elt.find('component').text
-        p, _ = mysite.search.models.Project.objects.get_or_create(name=component)
-        # NOTE: If get_or_create() returns a new Project, we're not going
-        # to know the primary_language.
-        return p
-
-    bug_id = mysite.customs.bugtrackers.bugzilla_general.bug_url2bug_id(
-        bug_obj.canonical_bug_link,
-        BUG_URL_PREFIX=BUG_URL_PREFIX)
-    b = mysite.customs.ohloh.mechanize_get(BUG_URL_PREFIX + '%d&ctype=xml' % bug_id)
-    # Grab the bug_elt for this bug...
-    bug_elt = lxml.etree.XML(
-        b.response().read()).find('bug')
-    
-    # FIXME: Move bug_elt2bug_object into bugzilla_general
-    data = mysite.customs.miro.bug_elt2bug_dict(
-        bug_elt,
-        canonical_bug_link_format_string=BUG_URL_PREFIX + '%d',
-        gen_project=project_finder_plugin)
-
-    for key in data:
-        setattr(bug_obj, key, data[key])
-
-    # Bug is from Fedora
-    bug_obj.as_appears_in_distribution = 'Fedora'
-
-    # NOTE this makes it bitesized
-    # NOTE also that this is a bad place to determine something
-    # is good for newcomers.
-    bug_obj.good_for_newcomers=True
-    return bug_obj
-
-def current_fit_and_finish_bug_ids():
-    # This returns a list of bug IDs we should look at
-    # that's all the dependencies of this tracking bug. So:
-    b = mysite.customs.ohloh.mechanize_get(FIT_AND_FINISH_TRACKING_BUG)
-    xml = lxml.etree.XML(b.response().read())
-    depends = xml.findall('bug/dependson')
-    depends_bug_ids = [int(depend.text) for depend in depends]
-    return depends_bug_ids
diff --git a/mysite/customs/bugtrackers/gnome_love.py b/mysite/customs/bugtrackers/gnome_love.py
deleted file mode 100644
index 2aeee07..0000000
--- a/mysite/customs/bugtrackers/gnome_love.py
+++ /dev/null
@@ -1,93 +0,0 @@
-import urllib2
-import mysite.customs.miro
-import mechanize
-import mysite.customs.ohloh
-import lxml.etree
-import mysite.customs.models
-import mysite.search.models
-import mysite.customs.bugtrackers.bugzilla_general
-
-from itertools import chain
-
-GNOME_LOVE_QUERY='https://bugzilla.gnome.org/buglist.cgi?columnlist=id&keywords=gnome-love&query_format=advanced&resolution=---'
-BUG_URL_PREFIX = 'https://bugzilla.gnome.org/show_bug.cgi?id='
-
-def get_current_bug_id2bug_objs():
-    b = mysite.customs.ohloh.mechanize_get(GNOME_LOVE_QUERY)
-
-    # find the one form with ctype XML
-    ctype_xml_form_no = mysite.customs.bugtrackers.bugzilla_general.find_ctype_xml_form_number(
-        b.forms())
-
-    # Click ze button
-    b.select_form(nr=ctype_xml_form_no)
-    b.submit()
-
-    # Get a bunch of XML back
-    bugzila_elt = lxml.etree.XML(b.response().read())
-
-    ret = {}
-
-    def project_finder_plugin(bug_elt):
-        import mysite.search.models
-        project_name = bug_elt.xpath('product')[0].text
-
-        ### Special-case a few GNOME-y project names
-        gnome2openhatch = {'general': 'GNOME (general)',
-                           'website': 'GNOME (website)'}
-        if project_name in gnome2openhatch:
-            project_name=gnome2openhatch[project_name]
-        
-        project, _ = mysite.search.models.Project.objects.get_or_create(
-            name=project_name)
-        return project
-
-    for bug in bugzila_elt.xpath('bug'):
-        bug_obj = mysite.customs.miro.bug_elt2bug_object(
-            bug, canonical_bug_link_format_string=BUG_URL_PREFIX + '%d',
-            gen_project=project_finder_plugin
-            )
-        bug_id = mysite.customs.bugtrackers.bugzilla_general.bug_url2bug_id(
-            bug_obj.canonical_bug_link, BUG_URL_PREFIX=BUG_URL_PREFIX)
-        bug_obj.good_for_newcomers = True
-        bug_obj.bite_size_tag_name = 'GNOME-Love'
-        ret[bug_id] = bug_obj
-        
-    return ret
-
-def grab():
-    """Loops over GNOME Bugzilla's list of gnome-love bugs and stores/updates
-    them in our DB.
-    
-    For now, just grab the gnome-love bugs to be kind to their servers."""
-
-    current_bug_id2bug_objs = get_current_bug_id2bug_objs()
-
-    bug_ids = chain(
-        current_bug_id2bug_objs.keys(),
-         mysite.customs.bugtrackers.bugzilla_general.get_remote_bug_ids_already_stored(
-             BUG_URL_PREFIX))
-
-    for bug_id in set(bug_ids):
-        # Sometimes create_bug_object_for_remote_bug_id will fail to create
-        # a bug because it's somehow gone missing. For those cases:
-
-        # create canonical_bug_link in this function to avoid assuming the
-        # returned bug is not None.
-        canonical_bug_link = BUG_URL_PREFIX + str(bug_id)
-
-        # If there is already a bug with this canonical_bug_link in
-        # the DB, just delete it. Same story if the bug doens't 404!
-        bugs_this_one_replaces = mysite.search.models.Bug.all_bugs.filter(
-            canonical_bug_link=canonical_bug_link)
-        for delete_me in bugs_this_one_replaces:
-            delete_me.delete()
-
-        if bug_id not in current_bug_id2bug_objs:
-            continue # If the bug is not in the new data set, we're done here.
-
-        bug = current_bug_id2bug_objs[bug_id]
-
-        # Otherwise, print and save the sucker!
-        print bug
-        bug.save()
diff --git a/mysite/customs/bugtrackers/kde.py b/mysite/customs/bugtrackers/kde.py
deleted file mode 100644
index 81a536c..0000000
--- a/mysite/customs/bugtrackers/kde.py
+++ /dev/null
@@ -1,106 +0,0 @@
-import logging
-
-import mysite.customs.bugtrackers.bugzilla_general
-
-QUERY_URL='https://bugs.kde.org/buglist.cgi?query_format=advanced&short_desc_type=allwordssubstr&short_desc=&long_desc_type=allwordssubstr&long_desc=&bug_file_loc_type=allwordssubstr&bug_file_loc=&keywords_type=allwords&keywords=junior-jobs&bug_status=UNCONFIRMED&bug_status=NEW&bug_status=REOPENED&bug_status=NEEDSINFO&bug_status=VERIFIED&resolution=---&emailtype1=substring&email1=&emailtype2=substring&email2=&bugidtype=include&bug_id=&votes=&chfieldfrom=&chfieldto=Now&chfieldvalue=&cmdtype=doit&order=Reuse+same+sort+as+last+time&field0-0-0=noop&type0-0-0=noop&value0-0-0='
-BUG_URL_PREFIX = 'https://bugs.kde.org/show_bug.cgi?id='
-
-def project_finder_plugin(bug_xml_elt):
-    import mysite.search.models
-    product = bug_xml_elt.xpath('product')[0].text
-    reasonable_products = set([
-        'Akonadi',
-        'Phonon'
-        'kmail',
-        'Rocs',
-        'akregator',
-        'amarok',
-        'ark',
-        'cervisia',
-        'k3b',
-        'kappfinder',
-        'kbabel',
-        'kdeprint',
-        'kdesktop',
-        'kfile',
-        'kfourinline',
-        'khotkeys',
-        'kio',
-        'kmail',
-        'kmplot',
-        'koffice',
-        'kompare',
-        'konqueror',
-        'kopete',
-        'kpat',
-        'kphotoalbum',
-        'krita',
-        'ksmserver',
-        'kspread',
-        'ksysguard',
-        'ktimetracker',
-        'kwin',
-        'kword',
-        'marble',
-        'okular',
-        'plasma',
-        'printer-applet',
-        'rsibreak',
-        'step',
-        'systemsettings',
-        'kdelibs',
-        'kcontrol',
-        'korganizer',
-        'kipiplugins',
-        'Phonon',
-        'dolphin',
-        'umbrello']
-        )
-    products_to_be_renamed = {
-        'digikamimageplugins': 'digikam image plugins',
-        'Network Management': 'KDE Network Management',
-        'telepathy': 'telepathy for KDE',
-        'docs': 'KDE documentation',
-        }
-    component = bug_xml_elt.xpath('component')[0].text
-    things = (product, component)
-
-    if product in reasonable_products:
-        project_name = product
-    else:
-        if product in products_to_be_renamed:
-            project_name = products_to_be_renamed[product]
-        else:
-            logging.info("Guessing on KDE subproject name. Found %s" %  repr(things))
-            project_name = product
-
-    project, _ = mysite.search.models.Project.objects.get_or_create(
-        name=project_name)
-    return project
-
-def detect_if_good_for_newcomers_plugin(bug_xml_elt, bug_object):
-    # muahaha if it starts with "JJ:" eat that
-    if bug_object.title.startswith("JJ:"):
-        bug_object.title = bug_object.title[3:].strip()
-    keywords_blob = bug_xml_elt.xpath('keywords')[0].text
-    splitted = keywords_blob.split(',')
-    splitted_and_stripped = [k.strip() for k in splitted]
-    if 'junior-jobs' in splitted:
-        bug_object.good_for_newcomers = True
-    else:
-        bug_object.good_for_newcomers = False
-    if bug_object.project.name == 'KDE documentation':
-        bug_object.concerns_just_documentation = True
-
-def get_current_bug_id2bug_objs():
-    return mysite.customs.bugtrackers.bugzilla_general.query_url2bug_objects(
-        BUG_URL_PREFIX=BUG_URL_PREFIX,
-        QUERY_URL=QUERY_URL,
-        project_finder_plugin=project_finder_plugin,
-        detect_if_good_for_newcomers_plugin=detect_if_good_for_newcomers_plugin)
-
-def grab():
-    current_bug_id2bug_objs = get_current_bug_id2bug_objs()
-    mysite.customs.bugtrackers.bugzilla_general.grab(
-        current_bug_id2bug_objs,
-        BUG_URL_PREFIX=BUG_URL_PREFIX)
diff --git a/mysite/customs/bugtrackers/mozilla.py b/mysite/customs/bugtrackers/mozilla.py
deleted file mode 100644
index fc58714..0000000
--- a/mysite/customs/bugtrackers/mozilla.py
+++ /dev/null
@@ -1,110 +0,0 @@
-import urllib2
-import logging
-import mechanize
-import lxml.etree
-
-import mysite.customs.miro
-import mysite.customs.ohloh
-import mysite.customs.models
-import mysite.search.models
-import mysite.customs.bugtrackers.bugzilla_general
-
-import itertools
-
-MOZILLA_GOOD_FIRST_BUG_QUERY='https://bugzilla.mozilla.org/buglist.cgi?resolution=---;status_whiteboard_type=substring;query_format=advanced;status_whiteboard=[good%20first%20bug]'
-BUG_URL_PREFIX = 'https://bugzilla.mozilla.org/show_bug.cgi?id='
-
-def get_current_bug_id2bug_objs():
-    b = mysite.customs.ohloh.mechanize_get(MOZILLA_GOOD_FIRST_BUG_QUERY)
-
-    # find the one form with ctype XML
-    ctype_xml_form_no = mysite.customs.bugtrackers.bugzilla_general.find_ctype_xml_form_number(
-        b.forms())
-
-    # Click ze button
-    b.select_form(nr=ctype_xml_form_no)
-    b.submit()
-
-    # Get a bunch of XML back
-    bugzila_elt = lxml.etree.XML(b.response().read())
-
-    ret = {}
-
-    def project_finder_plugin(bug_elt):
-        import mysite.search.models
-        xml_project_name = bug_elt.xpath('product')[0].text
-
-        ### Special-case the project names we know about
-        mozilla2openhatch = {'Core': 'Mozilla Core',
-                             'Firefox': 'Firefox',
-                             'MailNews Core': 'Mozilla Messaging',
-                             'addons.mozilla.org': 'addons.mozilla.org',
-                             'Thunderbird': 'Thunderbird',
-                             'Testing': 'Mozilla automated testing',
-                             'Directory': 'Mozilla LDAP',
-                             'mozilla.org': 'mozilla.org',
-                             'SeaMonkey': 'SeaMonkey',
-                             'Toolkit': 'Mozilla Toolkit',
-                             'support.mozilla.com': 'support.mozilla.com',
-                             'Camino': 'Camino',
-                             'Calendar': 'Mozilla Calendar',
-                             'Mozilla Localizations': 'Mozilla Localizations',
-                             }
-        if xml_project_name == 'Other Applications':
-            project_name = 'Mozilla ' + bug_elt.xpath('component')[0].text
-        else:
-            project_name = mozilla2openhatch[xml_project_name]
-        
-        project, _ = mysite.search.models.Project.objects.get_or_create(
-            name=project_name)
-        return project
-
-    for bug in bugzila_elt.xpath('bug'):
-        bug_obj = mysite.customs.miro.bug_elt2bug_object(
-            bug, canonical_bug_link_format_string=BUG_URL_PREFIX + '%d',
-            gen_project=project_finder_plugin
-            )
-        bug_id = mysite.customs.bugtrackers.bugzilla_general.bug_url2bug_id(
-            bug_obj.canonical_bug_link, BUG_URL_PREFIX=BUG_URL_PREFIX)
-        bug_obj.good_for_newcomers = True
-        bug_obj.bite_size_tag_name = '[good first bug]'
-        ret[bug_id] = bug_obj
-        
-    return ret
-
-def grab():
-    """Loops over Mozilla's list of good first bugs and stores/updates
-    them in our DB.
-    
-    For now, just grab the good first bugs to be kind to their servers."""
-
-    current_bug_id2bug_objs = get_current_bug_id2bug_objs()
-
-    bug_ids = itertools.chain(
-        current_bug_id2bug_objs.keys(),
-        mysite.customs.bugtrackers.bugzilla_general.get_remote_bug_ids_already_stored(
-             BUG_URL_PREFIX))
-
-    for bug_id in set(bug_ids):
-        # Sometimes create_bug_object_for_remote_bug_id will fail to create
-        # a bug because it's somehow gone missing. For those cases:
-
-        # create canonical_bug_link in this function to avoid assuming the
-        # returned bug is not None.
-        canonical_bug_link = BUG_URL_PREFIX + str(bug_id)
-
-        # If there is already a bug with this canonical_bug_link in
-        # the DB, just delete it. Same story if the bug doens't 404!
-        bugs_this_one_replaces = mysite.search.models.Bug.all_bugs.filter(
-            canonical_bug_link=canonical_bug_link)
-        for delete_me in bugs_this_one_replaces:
-            delete_me.delete()
-
-        if bug_id not in current_bug_id2bug_objs:
-            continue # If the bug is not in the new data set, we're done here.
-
-        bug = current_bug_id2bug_objs[bug_id]
-
-        # Otherwise, print and save the sucker!
-        print bug
-        bug.save()
diff --git a/mysite/customs/bugtrackers/wikimedia.py b/mysite/customs/bugtrackers/wikimedia.py
deleted file mode 100644
index 66ddf41..0000000
--- a/mysite/customs/bugtrackers/wikimedia.py
+++ /dev/null
@@ -1,44 +0,0 @@
-import mysite.customs.bugtrackers.bugzilla_general
-
-QUERY_URL='https://bugzilla.wikimedia.org/buglist.cgi?keywords=easy&query_format=advanced&keywords_type=allwords&bug_status=NEW&bug_status=ASSIGNED&bug_status=REOPENED&bug_status=VERIFIED&resolution=LATER&resolution=---'
-BUG_URL_PREFIX = 'https://bugzilla.wikimedia.org/show_bug.cgi?id='
-
-def project_finder_plugin(bug_xml_elt):
-    import mysite.search.models
-    product = bug_xml_elt.xpath('product')[0].text
-    if product == 'MediaWiki extensions':
-        project_name = bug_xml_elt.xpath('component')[0].text
-        if project_name in ('FCKeditor', 'Gadgets'):
-            project_name += ' for MediaWiki'
-    else:
-        project_name = product
-        
-    project, _ = mysite.search.models.Project.objects.get_or_create(
-        name=project_name)
-    return project
-
-def detect_if_good_for_newcomers_plugin(bug_xml_elt, bug_object):
-    keywords_blob = bug_xml_elt.xpath('keywords')[0].text
-    splitted = keywords_blob.split(',')
-    splitted_and_stripped = [k.strip() for k in splitted]
-    if 'easy' in splitted:
-        bug_object.good_for_newcomers = True
-    else:
-        bug_object.good_for_newcomers = False        
-
-def get_current_bug_id2bug_objs():
-    return mysite.customs.bugtrackers.bugzilla_general.query_url2bug_objects(
-        BUG_URL_PREFIX=BUG_URL_PREFIX,
-        QUERY_URL=QUERY_URL,
-        project_finder_plugin=project_finder_plugin,
-        detect_if_good_for_newcomers_plugin=detect_if_good_for_newcomers_plugin)
-
-def grab():
-    current_bug_id2bug_objs = get_current_bug_id2bug_objs()
-    mysite.customs.bugtrackers.bugzilla_general.grab(
-        current_bug_id2bug_objs,
-        BUG_URL_PREFIX=BUG_URL_PREFIX)
-                                         
-                                         
-
-
diff --git a/mysite/customs/miro.py b/mysite/customs/miro.py
deleted file mode 100644
index 25a944d..0000000
--- a/mysite/customs/miro.py
+++ /dev/null
@@ -1,141 +0,0 @@
-# vim: set columns=80:
-import os
-import datetime
-import csv
-import urllib2
-
-import mysite.base.helpers
-
-import simplejson
-import datetime
-import glob
-import lxml
-from ..search.models import Project, Bug
-import codecs
-import dateutil.parser
-
-def get_tag_text_from_xml(xml_doc, tag_name, index = 0):
-    """Given an object representing <bug><tag>text</tag></bug>,
-    and tag_name = 'tag', returns 'text'."""
-    tags = xml_doc.xpath(tag_name)
-    try:
-        return tags[index].text
-    except IndexError:
-        return ''
-    assert False, "You should not get here."
-
-def count_people_involved(xml_doc):
-    """Strategy: Create a set of all the listed text values
-    inside a <who ...>(text)</who> tag
-    Return the length of said set."""
-    everyone = [tag.text for tag in xml_doc.xpath('.//who')]
-    return len(set(everyone))
-
-def bugzilla_date_to_datetime(date_string):
-    return mysite.base.helpers.string2naive_datetime(date_string)
-
-def who_tag_to_username_and_realname(who_tag):
-    username = who_tag.text
-    realname = who_tag.attrib.get('name', '')
-    return username, realname
-
-def xml2bug_object(xml_fd,
-                   canonical_bug_link_format_string=
-                   'http://bugzilla.pculture.org/show_bug.cgi?id=%d'):
-    """xml fd: xml file descriptor 'containing' information about one bug"""
-    parsed = lxml.etree.parse(xml_fd)
-    gen_miro_project = lambda x: Project.objects.get_or_create(name='Miro')[0]
-    bug_elt, = parsed.xpath('bug') # The comma asserts that the xpath() returns a list of length 1
-    return bug_elt2bug_object(bug_elt, canonical_bug_link_format_string, gen_miro_project)
-
-def bug_elt2bug_dict(parsed, canonical_bug_link_format_string,
-                       gen_project):
-    date_reported_text = get_tag_text_from_xml(parsed, 'creation_ts')
-    last_touched_text = get_tag_text_from_xml(parsed, 'delta_ts')
-    u, r = who_tag_to_username_and_realname(parsed.xpath('.//reporter')[0])
-    bug_id = int(get_tag_text_from_xml(parsed, 'bug_id'))
-    keywords_text = get_tag_text_from_xml(parsed, 'keywords')
-    keywords = map(lambda s: s.strip(),
-                   keywords_text.split(','))
-    project = gen_project(parsed)
-    status = get_tag_text_from_xml(parsed, 'bug_status')
-    looks_closed = status in ('RESOLVED', 'WONTFIX', 'CLOSED', 'ASSIGNED')
-
-    ret = dict(
-        project = project,
-        title = get_tag_text_from_xml(parsed, 'short_desc'),
-        description = (get_tag_text_from_xml(parsed, 'long_desc/thetext') or
-                       '(Empty description)'),
-        status = status,
-        importance = get_tag_text_from_xml(parsed, 'bug_severity'),
-        people_involved = count_people_involved(parsed),
-        date_reported = bugzilla_date_to_datetime(date_reported_text),
-        last_touched = bugzilla_date_to_datetime(last_touched_text),
-        last_polled = datetime.datetime.now(),
-        submitter_username = u,
-        submitter_realname = r,
-        canonical_bug_link = canonical_bug_link_format_string % bug_id,
-        good_for_newcomers = ('bitesized' in keywords),
-        looks_closed=looks_closed)
-    return ret
-
-def bug_elt2bug_object(parsed, canonical_bug_link_format_string,
-                       gen_project):
-    ret = Bug()
-    data = bug_elt2bug_dict(parsed, canonical_bug_link_format_string, gen_project)
-    for key in data:
-        setattr(ret, key, data[key])
-    return ret
-
-def bugzilla_query_to_bug_ids(csv_fd):
-    doc = csv.reader(csv_fd)
-    try:
-        doc.next() # throw away header row
-    except StopIteration:
-        return []
-
-    bug_ids = []
-    
-    for row in doc:
-        bug_ids.append(int(row[0]))
-
-    return bug_ids
-
-def link2bug_id(url):
-    first, rest = url.split('?id=')
-    return int(rest)
-
-def bitesized_bugs_csv_fd():
-    csv_url = 'http://bugzilla.pculture.org/buglist.cgi?bug_status=NEW&bug_status=ASSIGNED&bug_status=REOPENED&field-1-0-0=bug_status&field-1-1-0=product&field-1-2-0=keywords&keywords=bitesized&product=Miro&query_format=advanced&remaction=&type-1-0-0=anyexact&type-1-1-0=anyexact&type-1-2-0=anywords&value-1-0-0=NEW%2CASSIGNED%2CREOPENED&value-1-1-0=Miro&value-1-2-0=bitesized&ctype=csv'
-    csv_fd = urllib2.urlopen(csv_url)
-    return csv_fd
-
-def open_xml_url(xml_url):
-    return urllib2.urlopen(xml_url)
-    
-def grab_miro_bugs():
-    '''Input: Nothing.
-
-    Side-effect: Loops over the Miro bitesized bugs (in the Miro bug tracker) and stores/updates them in our DB.'''
-    csv_fd = bitesized_bugs_csv_fd()
-
-    old_bitesized_bugs = Bug.all_bugs.filter(canonical_bug_link__startswith='http://bugzilla.pculture.org/')
-    old_bitesized_bug_ids = [link2bug_id(k.canonical_bug_link) for k in old_bitesized_bugs]
-    
-    current_bitesized_bug_ids  = bugzilla_query_to_bug_ids(csv_fd)
-
-    bug_ids = current_bitesized_bug_ids + old_bitesized_bug_ids
-
-    for bug_id in bug_ids:
-        xml_url = 'http://bugzilla.pculture.org/show_bug.cgi?ctype=xml&id=%d' % bug_id
-        xml_fd = open_xml_url(xml_url)
-        bug = xml2bug_object(xml_fd)
-
-        # If there is already a bug with this canonical_bug_link in the DB, just delete it.
-        bugs_this_one_replaces = Bug.all_bugs.filter(canonical_bug_link=
-                                                    bug.canonical_bug_link)
-        for delete_me in bugs_this_one_replaces:
-            delete_me.delete()
-
-        # With the coast clear, we save the bug we just extracted from the Miro tracker.
-        bug.save()
diff --git a/mysite/search/management/commands/search_daily_tasks.py b/mysite/search/management/commands/search_daily_tasks.py
index 5eb8b97..0504564 100644
--- a/mysite/search/management/commands/search_daily_tasks.py
+++ b/mysite/search/management/commands/search_daily_tasks.py
@@ -5,20 +5,12 @@ from django.core.management.base import BaseCommand
 import django.conf
 django.conf.settings.CELERY_ALWAYS_EAGER = True
 
-import mysite.search.tasks
+import mysite.customs.bugtrackers.opensolaris
 import mysite.customs.bugtrackers.roundup_general
-import mysite.customs.bugtrackers
+import mysite.search.tasks.trac_instances
+import mysite.search.tasks.bugzilla_instances
 import mysite.search.tasks.launchpad_tasks
 
-import mysite.customs.miro
-import mysite.customs.bugtrackers.trac
-import mysite.customs.bugtrackers.gnome_love
-import mysite.customs.bugtrackers.fedora_fitfinish
-import mysite.customs.bugtrackers.mozilla
-import mysite.customs.bugtrackers.wikimedia
-import mysite.customs.bugtrackers.kde
-import mysite.customs.bugtrackers.opensolaris
-
 ### All this code runs synchronously once a day.
 ### For now, we can crawl all the bug trackers in serial.
 
@@ -46,41 +38,6 @@ import mysite.customs.bugtrackers.opensolaris
 class Command(BaseCommand):
     help = "Call this once a day to make sure we run Bug search-related nightly jobs."
 
-    def update_bugzilla_trackers(self):
-        bugzilla_trackers = {
-            'Miro':
-                mysite.customs.miro.grab_miro_bugs,
-            'KDE junior jobs':
-                mysite.customs.bugtrackers.kde.grab,
-            'Wikimedia easy bugs':
-                mysite.customs.bugtrackers.wikimedia.grab,
-            'GNOME Love':
-                mysite.customs.bugtrackers.gnome_love.grab,
-            'Mozilla "good first bug"s':
-                mysite.customs.bugtrackers.mozilla.grab,
-
-            # FIXME
-            # Really, the Bugzilla import code should be reworked to be as
-            # clean and tidy as the Mercurial/Python/Roundup stuff, with
-            # an abstract class with a .update() method.
-            # Then simple sub-classes can handle each of the different projects'
-            # details.
-
-            # What the heck is up with the Fedora code being
-            # special-cased like this? Well, I'll clean it up another day,
-            # so long as it seems to work right now.
-            'Fedora "fit and finish" new bugs':
-                mysite.search.tasks.bugzilla_instances.learn_about_new_fedora_fit_and_finish_bugs,
-
-            'Fedora "fit and finish" refreshing old bugs':
-                mysite.search.tasks.bugzilla_instances.refresh_all_fedora_fit_and_finish_bugs,
-            }
-
-        for bugzilla_tracker in bugzilla_trackers:
-            logging.info("Refreshing bugs from %s." % bugzilla_tracker)
-            call_me = bugzilla_trackers[bugzilla_tracker]
-            call_me()
-
     def find_and_update_enabled_roundup_trackers(self):
         enabled_roundup_trackers = []
 
@@ -147,7 +104,4 @@ class Command(BaseCommand):
         self.update_launchpad_hosted_projects()
         self.find_and_update_enabled_trac_instances()
         self.find_and_update_enabled_roundup_trackers()
-        self.update_bugzilla_trackers()
-        #self.find_and_update_enabled_bugzilla_instances()
-        
-
+        self.find_and_update_enabled_bugzilla_instances()
diff --git a/mysite/search/tasks/__init__.py b/mysite/search/tasks/__init__.py
index 8fcc7a5..2076fd0 100644
--- a/mysite/search/tasks/__init__.py
+++ b/mysite/search/tasks/__init__.py
@@ -11,10 +11,6 @@ import datetime
 
 from django.conf import settings
 
-import mysite.customs.miro
-import mysite.customs.bugtrackers.trac
-import mysite.customs.bugtrackers.gnome_love
-import mysite.customs.bugtrackers.fedora_fitfinish
 import mysite.search.tasks.trac_instances
 import mysite.search.tasks.bugzilla_instances
 import mysite.search.tasks.launchpad_tasks
diff --git a/mysite/search/tasks/bugzilla_instances.py b/mysite/search/tasks/bugzilla_instances.py
index ea06540..7fd51a3 100644
--- a/mysite/search/tasks/bugzilla_instances.py
+++ b/mysite/search/tasks/bugzilla_instances.py
@@ -4,57 +4,6 @@ import logging
 import mysite.search.models
 import mysite.customs.bugtrackers.bugzilla
 
-def look_at_one_fedora_bug(bug_id):
-    logging.info("Was asked to look at bug %d in Fedora" % bug_id)
-    # If bug is already in our database, and we looked at
-    # it within the past day, skip the request.
-    bug_url = mysite.customs.bugtrackers.bugzilla_general.bug_id2bug_url(
-        bug_id=bug_id,
-        BUG_URL_PREFIX=mysite.customs.bugtrackers.fedora_fitfinish.BUG_URL_PREFIX)
-
-    try:
-        bug_obj = mysite.search.models.Bug.all_bugs.get(
-            canonical_bug_link=bug_url)
-    except mysite.search.models.Bug.MultipleObjectsReturned:
-        # delete all but the first
-        bug_objs = mysite.search.models.Bug.all_bugs.filter(
-            canonical_bug_link=bug_url)
-        bug_obj = bug_objs[0]
-        for stupid_dup in bug_objs[1:]:
-            stupid_dup.delete()
-
-    except mysite.search.models.Bug.DoesNotExist:
-        bug_obj = mysite.search.models.Bug(
-            canonical_bug_link=bug_url)
-
-    # Is that bug fresh enough to skip?
-    if bug_obj.data_is_more_fresh_than_one_day():
-        logging.info("Bug is fresh! Skipping.")
-        return
-    # if the delta is greater than a day, refresh it.
-    mysite.customs.bugtrackers.fedora_fitfinish.reload_bug_obj(bug_obj)
-    bug_obj.save()
-    logging.info("Finished with %d from Fedora." % bug_id)
-
-def learn_about_new_fedora_fit_and_finish_bugs():
-    logging.info('Started to learn about new Fedora fit and finish bugs.')
-    for bug_id in mysite.customs.bugtrackers.fedora_fitfinish.current_fit_and_finish_bug_ids():
-        look_at_one_fedora_bug(bug_id=bug_id)
-    logging.info('Finished grabbing the list of Fedora fit and finish bugs.')
-
-def refresh_all_fedora_fit_and_finish_bugs():
-    logging.info("Starting refreshing all Fedora bugs.")
-    all_such_bugs = mysite.search.models.Bug.all_bugs.filter(
-        canonical_bug_link__contains=
-        mysite.customs.bugtrackers.fedora_fitfinish.BUG_URL_PREFIX)
-    logging.info("All %d of them." % all_such_bugs.count())
-
-    for bug in all_such_bugs:
-        bug_id = mysite.customs.bugtrackers.bugzilla_general.bug_url2bug_id(
-            bug.canonical_bug_link,
-            BUG_URL_PREFIX=mysite.customs.bugtrackers.fedora_fitfinish.BUG_URL_PREFIX)
-        look_at_one_fedora_bug(bug_id=bug_id)
-
 class BugzillaBugTracker(object):
     def __init__(self, base_url, project_name, bug_project_name_format, bug_id_list_only=False):
         self.base_url = base_url
-- 
1.7.1


From c7856160b581e44ab8a1caf5d068c3e6abf81d47 Mon Sep 17 00:00:00 2001
From: Jack Grigg <me@jackgrigg.com>
Date: Fri, 25 Jun 2010 16:38:13 +0000
Subject: [PATCH 06/12] Quick fix for search_daily_tasks so that Bugzilla trackers throwing HTTP Error 500 don't break it entirely

---
 .../management/commands/search_daily_tasks.py      |    8 +++++++-
 1 files changed, 7 insertions(+), 1 deletions(-)

diff --git a/mysite/search/management/commands/search_daily_tasks.py b/mysite/search/management/commands/search_daily_tasks.py
index 0504564..b00b477 100644
--- a/mysite/search/management/commands/search_daily_tasks.py
+++ b/mysite/search/management/commands/search_daily_tasks.py
@@ -87,7 +87,13 @@ class Command(BaseCommand):
         for thing in enabled_bugzilla_instances:
             logging.info("[Bugzilla] About to update %s" % thing)
             instantiated = thing()
-            instantiated.update()
+            # FIXME: The Bugzilla trackers seem to throw error 500 a lot.
+            # For now, chuck in a dirty big try except to stop importer
+            # breaking.
+            try:
+                instantiated.update()
+            except:
+                logging.info("[Bugzilla] ERROR: Importer failed, likely HTTP500, continuing on..."
 
     def update_launchpad_hosted_projects(self):
         ### For Launchpad:
-- 
1.7.1


From 2562c881262832aa411f59682cc6f8a71043a031 Mon Sep 17 00:00:00 2001
From: Jack Grigg <me@jackgrigg.com>
Date: Fri, 25 Jun 2010 16:46:37 +0000
Subject: [PATCH 07/12] Removed TestCase for old format Bugzilla importer, since it is no longer there

---
 mysite/customs/tests.py |  164 -----------------------------------------------
 1 files changed, 0 insertions(+), 164 deletions(-)

diff --git a/mysite/customs/tests.py b/mysite/customs/tests.py
index 4733cc6..a51341e 100644
--- a/mysite/customs/tests.py
+++ b/mysite/customs/tests.py
@@ -32,7 +32,6 @@ import ohloh
 import lp_grabber
 
 from mysite.profile.tasks import FetchPersonDataFromOhloh
-import mysite.customs.miro
 import mysite.customs.debianqa
 import mysite.customs.cia
 import mysite.customs.feed
@@ -278,169 +277,6 @@ class LaunchpadDataTests(django.test.TestCase):
 
 class BugzillaTests(django.test.TestCase):
     fixtures = ['miro-project']
-    def test_kde(self):
-        p = Project.create_dummy(name='KDE')
-        f = os.path.join(settings.MEDIA_ROOT, 'sample-data', 'kde-117760-2010-04-09.xml')
-        xml_fd = file(f)
-        bug = mysite.customs.miro.xml2bug_object(xml_fd)
-        self.assertEqual(bug.submitter_username, 'hasso kde org')
-        self.assertEqual(bug.submitter_realname, 'Hasso Tepper')
-
-    def test_kde_harder_bug(self):
-        p = Project.create_dummy(name='KDE')
-        f = os.path.join(settings.MEDIA_ROOT, 'sample-data', 'kde-182054-2010-04-09.xml')
-        xml_fd = file(f)
-        bug = mysite.customs.miro.xml2bug_object(xml_fd)
-        self.assertEqual(bug.submitter_username, 'jedd progsoc org')
-        self.assertEqual(bug.submitter_realname, '')
-
-    def test_miro_bug_object(self):
-        # Parse XML document as if we got it from the web
-        f = os.path.join(settings.MEDIA_ROOT, 'sample-data', 'miro-2294-2009-08-06.xml')
-        xml_fd = file(f)
-        bug = mysite.customs.miro.xml2bug_object(xml_fd)
-
-        self.assertEqual(bug.project.name, 'Miro')
-        self.assertEqual(bug.title, "Add test for torrents that use gzip'd urls")
-        self.assertEqual(bug.description, """This broke. We should make sure it doesn't break again.
-Trac ticket id: 2294
-Owner: wguaraldi
-Reporter: nassar
-Keywords: Torrent unittest""")
-        self.assertEqual(bug.status, 'NEW')
-        self.assertEqual(bug.importance, 'normal')
-        self.assertEqual(bug.people_involved, 5)
-        self.assertEqual(bug.date_reported, datetime.datetime(2006, 6, 9, 12, 49))
-        self.assertEqual(bug.last_touched, datetime.datetime(2008, 6, 11, 23, 56, 27))
-        self.assertEqual(bug.submitter_username, 'nassar@pculture.org')
-        self.assertEqual(bug.submitter_realname, 'Nick Nassar')
-        self.assertEqual(bug.canonical_bug_link, 'http://bugzilla.pculture.org/show_bug.cgi?id=2294')
-        self.assert_(bug.good_for_newcomers)
-
-    def test_csv_parsing(self):
-        csv_fd = StringIO('''some_header,whatever
-1,silly bug
-2,other silly bug''')
-        bugs = mysite.customs.miro.bugzilla_query_to_bug_ids(
-            csv_fd)
-        self.assertEqual(bugs, [1, 2])
-
-    @mock.patch("mysite.customs.miro.open_xml_url")
-    @mock.patch("mysite.customs.miro.bitesized_bugs_csv_fd")
-    def test_full_grab_miro_bugs(self, mock_csv_maker, mock_xml_opener):
-        mock_xml_opener.return_value = open(os.path.join(
-            settings.MEDIA_ROOT, 'sample-data', 'miro-2294-2009-08-06.xml'))
-
-        mock_csv_maker.return_value = StringIO("""bug_id,useless
-1,useless""")
-        mysite.customs.miro.grab_miro_bugs()
-        all_bugs = Bug.all_bugs.all()
-        self.assertEqual(len(all_bugs), 1)
-        bug = all_bugs[0]
-        self.assertEqual(bug.canonical_bug_link,
-                         'http://bugzilla.pculture.org/show_bug.cgi?id=2294')
-        self.assertFalse(bug.looks_closed)
-
-        # And the new manager does find it
-        self.assertEqual(Bug.open_ones.all().count(), 1)
-
-
-    @mock.patch("mysite.customs.miro.open_xml_url")
-    @mock.patch("mysite.customs.miro.bitesized_bugs_csv_fd")
-    def test_miro_bugzilla_detects_closedness(self, mock_csv_maker, mock_xml_opener):
-        cooked_xml = open(os.path.join(
-            settings.MEDIA_ROOT, 'sample-data',
-            'miro-2294-2009-08-06.xml')).read().replace(
-            'NEW', 'CLOSED')
-        mock_xml_opener.return_value = StringIO(cooked_xml)
-        
-        mock_csv_maker.return_value = StringIO("""bug_id,useless
-1,useless""")
-        mysite.customs.miro.grab_miro_bugs()
-        all_bugs = Bug.all_bugs.all()
-        self.assertEqual(len(all_bugs), 1)
-        bug = all_bugs[0]
-        self.assertEqual(bug.canonical_bug_link,
-                         'http://bugzilla.pculture.org/show_bug.cgi?id=2294')
-        self.assert_(bug.looks_closed)
-
-        # And the new manager successfully does NOT find it!
-        self.assertEqual(Bug.open_ones.all().count(), 0)
-
-    @mock.patch("mysite.customs.miro.open_xml_url")
-    @mock.patch("mysite.customs.miro.bitesized_bugs_csv_fd")
-    def test_full_grab_resolved_miro_bug(self, mock_csv_maker, mock_xml_opener):
-        mock_xml_opener.return_value = open(os.path.join(
-            settings.MEDIA_ROOT, 'sample-data', 'miro-2294-2009-08-06-RESOLVED.xml'))
-
-        mock_csv_maker.return_value = StringIO("""bug_id,useless
-1,useless""")
-        mysite.customs.miro.grab_miro_bugs()
-        all_bugs = Bug.all_bugs.all()
-        self.assertEqual(len(all_bugs), 1)
-        bug = all_bugs[0]
-        self.assertEqual(bug.canonical_bug_link,
-                         'http://bugzilla.pculture.org/show_bug.cgi?id=2294')
-        self.assert_(bug.looks_closed)
-
-    @mock.patch("mysite.customs.miro.open_xml_url")
-    @mock.patch("mysite.customs.miro.bitesized_bugs_csv_fd")
-    def test_full_grab_miro_bugs_refreshes_older_bugs(self, mock_csv_maker, mock_xml_opener):
-        mock_xml_opener.return_value = open(os.path.join(
-            settings.MEDIA_ROOT, 'sample-data', 'miro-2294-2009-08-06.xml'))
-
-        mock_csv_maker.return_value = StringIO("""bug_id,useless
-2294,useless""")
-        mysite.customs.miro.grab_miro_bugs()
-
-        # Pretend there's old data lying around:
-        bug = Bug.all_bugs.get()
-        bug.people_involved = 1
-        bug.save()
-
-        mock_xml_opener.return_value = open(os.path.join(
-            settings.MEDIA_ROOT, 'sample-data', 'miro-2294-2009-08-06.xml'))
-
-        # Now refresh
-        mysite.customs.miro.grab_miro_bugs()
-
-        # Now verify there is only one bug, and its people_involved is 5
-        bug = Bug.all_bugs.get()
-        self.assertEqual(bug.people_involved, 5)
-
-
-    @mock.patch("mysite.customs.miro.open_xml_url")
-    @mock.patch("mysite.customs.miro.bitesized_bugs_csv_fd")
-    def test_regrab_miro_bugs_refreshes_older_bugs_even_when_missing_from_csv(self, mock_csv_maker, mock_xml_opener):
-        mock_xml_opener.return_value = open(os.path.join(
-            settings.MEDIA_ROOT, 'sample-data', 'miro-2294-2009-08-06.xml'))
-
-        # Situation: Assume there are zero bitesized bugs today.
-        # Desire: We re-get old bugs that don't show up in the CSV.
-
-        # Prereq: We have some bug with lame data:
-        bug = Bug()
-        bug.people_involved = 1
-        bug.canonical_bug_link = 'http://bugzilla.pculture.org/show_bug.cgi?id=2294'
-        bug.date_reported = datetime.datetime.now()
-        bug.last_touched = datetime.datetime.now()
-        bug.last_polled = datetime.datetime.now()
-        bug.project, _ = Project.objects.get_or_create(name='Miro')
-        bug.save()
-
-        # Prepare a fake CSV that is empty
-        mock_csv_maker.return_value = StringIO('')
-
-        # Now, do a crawl and notice that we updated the bug even though the CSV is empty
-        
-        mysite.customs.miro.grab_miro_bugs() # refreshes no bugs since CSV is empty!
-        all_bugs = Bug.all_bugs.all()
-        self.assertEqual(len(all_bugs), 1)
-        bug = all_bugs[0]
-        self.assertEqual(bug.people_involved, 5)
-
-class BugzillaNewFormatTests(django.test.TestCase):
-    fixtures = ['miro-project']
     @mock.patch("mysite.customs.bugtrackers.bugzilla.url2bug_data")
     def test_kde(self, mock_xml_opener):
         p = Project.create_dummy(name='KDE')
-- 
1.7.1


From 4055ce70ac546bf51be163fafddd63f499b39a5d Mon Sep 17 00:00:00 2001
From: Jack Grigg <me@jackgrigg.com>
Date: Sat, 26 Jun 2010 09:50:09 +0000
Subject: [PATCH 08/12] Modified Bugzilla bug project name generator to allow format strings with {product} as well as {project} and {component}.

---
 mysite/search/tasks/bugzilla_instances.py |    3 +++
 1 files changed, 3 insertions(+), 0 deletions(-)

diff --git a/mysite/search/tasks/bugzilla_instances.py b/mysite/search/tasks/bugzilla_instances.py
index 7fd51a3..51358e3 100644
--- a/mysite/search/tasks/bugzilla_instances.py
+++ b/mysite/search/tasks/bugzilla_instances.py
@@ -14,6 +14,7 @@ class BugzillaBugTracker(object):
     def generate_bug_project_name(self, bb):
         return self.bug_project_name_format.format(
                 project = self.project_name,
+                product = bb.product,
                 component = bb.component)
 
     def create_or_refresh_one_bugzilla_bug(self, bb):
@@ -358,6 +359,8 @@ class FedoraBugzilla(BugzillaBugTracker):
 # If the project has a tracker bug for the bugs to be imported,
 # set bug_id_list_only=True in BugzillaBugTracker.__init__ and
 # replace get_current_xml_bug_tree with get_current_bug_id_list
+# bug_project_name_format can contain the tags {project},
+# {product} and {component} which will be replaced accordingly.
 class GenBugzilla(BugzillaBugTracker):
     enabled = False
 
-- 
1.7.1


From f57a7550e93d40d3b1e04513586d95a7af54b247 Mon Sep 17 00:00:00 2001
From: Jack Grigg <me@jackgrigg.com>
Date: Sat, 26 Jun 2010 11:32:22 +0000
Subject: [PATCH 09/12] And he forgets yet another closing bracket ~_~

---
 .../management/commands/search_daily_tasks.py      |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/mysite/search/management/commands/search_daily_tasks.py b/mysite/search/management/commands/search_daily_tasks.py
index b00b477..b4caebf 100644
--- a/mysite/search/management/commands/search_daily_tasks.py
+++ b/mysite/search/management/commands/search_daily_tasks.py
@@ -93,7 +93,7 @@ class Command(BaseCommand):
             try:
                 instantiated.update()
             except:
-                logging.info("[Bugzilla] ERROR: Importer failed, likely HTTP500, continuing on..."
+                logging.info("[Bugzilla] ERROR: Importer failed, likely HTTP500, continuing on...")
 
     def update_launchpad_hosted_projects(self):
         ### For Launchpad:
-- 
1.7.1


From 0b2e02898638912df342a562c17cc80148eb5861 Mon Sep 17 00:00:00 2001
From: Jack Grigg <me@jackgrigg.com>
Date: Sat, 26 Jun 2010 13:24:20 +0000
Subject: [PATCH 10/12] Added many more bug trackers to the Bugzilla importer.

---
 mysite/search/tasks/bugzilla_instances.py |  180 +++++++++++++++++++++++++++++
 1 files changed, 180 insertions(+), 0 deletions(-)

diff --git a/mysite/search/tasks/bugzilla_instances.py b/mysite/search/tasks/bugzilla_instances.py
index 51358e3..54a5bf3 100644
--- a/mysite/search/tasks/bugzilla_instances.py
+++ b/mysite/search/tasks/bugzilla_instances.py
@@ -355,6 +355,186 @@ class FedoraBugzilla(BugzillaBugTracker):
         # Then pass ret_dict back
         return ret_dict
 
+class SongbirdBugzilla(BugzillaBugTracker):
+    enabled = True
+
+    def __init__(self):
+        BugzillaBugTracker.__init__(self,
+                                    base_url='http://bugzilla.songbirdnest.com/',
+                                    project_name='Songbird',
+                                    bug_project_name_format='{project}')
+
+    def get_current_xml_bug_tree(self):
+        # Query below returns nearly 4000 bugs if we try to index everything.
+        # For now, only import bugs with 'helpwanted' tag.
+        # (This tag doesn't equate to 'bitesized'.)
+        return mysite.customs.bugtrackers.bugzilla.url2bug_data(
+                'http://bugzilla.songbirdnest.com/buglist.cgi?query_format=advanced&resolution=---&keywords=helpwanted')
+
+    @staticmethod
+    def extract_tracker_specific_data(xml_data, ret_dict):
+        # Make modifications to ret_dict using provided metadata
+        ret_dict['good_for_newcomers'] = False # 'helpwanted' doesn't just indicate bitesized.
+        # Then pass ret_dict back
+        return ret_dict
+
+class ApertiumBugzilla(BugzillaBugTracker):
+    enabled = True
+
+    def __init__(self):
+        BugzillaBugTracker.__init__(self,
+                                    base_url='http://bugs.apertium.org/cgi-bin/bugzilla/',
+                                    project_name='Apertium',
+                                    bug_project_name_format='{project}')
+
+    def get_current_xml_bug_tree(self):
+        return mysite.customs.bugtrackers.bugzilla.url2bug_data(
+                'http://bugs.apertium.org/cgi-bin/bugzilla/buglist.cgi?query_format=advanced&resolution=---')
+
+    @staticmethod
+    def extract_tracker_specific_data(xml_data, ret_dict):
+        # Make modifications to ret_dict using provided metadata
+        ret_dict['good_for_newcomers'] = False # No bitesized keyword.
+        # Then pass ret_dict back
+        return ret_dict
+
+class MusopenBugzilla(BugzillaBugTracker):
+    enabled = False # FIXME: Haven't found actual bugtracker yet...
+
+    def __init__(self):
+        BugzillaBugTracker.__init__(self,
+                                    base_url='',
+                                    project_name='Musopen',
+                                    bug_project_name_format='{project}')
+
+    def get_current_xml_bug_tree(self):
+        return mysite.customs.bugtrackers.bugzilla.url2bug_data(
+                '')
+
+    @staticmethod
+    def extract_tracker_specific_data(xml_data, ret_dict):
+        # Make modifications to ret_dict using provided metadata
+        # Check for the bitesized keyword
+        keywords_text = mysite.customs.bugtrackers.bugzilla.get_tag_text_from_xml(xml_data, 'keywords')
+        keywords = map(lambda s: s.strip(),
+                       keywords_text.split(','))
+        ret_dict['good_for_newcomers'] = ('' in keywords)
+        # Then pass ret_dict back
+        return ret_dict
+
+    # The formt string method for generating the project name can be
+    # overloaded by uncommenting the function below.
+    #def generate_bug_project_name(self, bb):
+        #return bug_project_name
+
+class RTEMSBugzilla(BugzillaBugTracker):
+    enabled = True
+
+    def __init__(self):
+        BugzillaBugTracker.__init__(self,
+                                    base_url='https://www.rtems.org/bugzilla/',
+                                    project_name='RTEMS',
+                                    bug_project_name_format='{project}')
+
+    def get_current_xml_bug_tree(self):
+        return mysite.customs.bugtrackers.bugzilla.url2bug_data(
+                'https://www.rtems.org/bugzilla/buglist.cgi?query_format=advanced&resolution=---')
+
+    @staticmethod
+    def extract_tracker_specific_data(xml_data, ret_dict):
+        # Make modifications to ret_dict using provided metadata
+        ret_dict['good_for_newcomers'] = False # No bitesized keyword.
+        # Then pass ret_dict back
+        return ret_dict
+
+# This tracker could be extended to cover all of FreeDesktop.
+# For now, just do X.Org since it is all that was requested.
+class XOrgBugzilla(BugzillaBugTracker):
+    enabled = True
+
+    def __init__(self):
+        BugzillaBugTracker.__init__(self,
+                                    base_url='https://bugs.freedesktop.org/',
+                                    project_name='XOrg',
+                                    bug_project_name_format='{project}')
+
+    def get_current_xml_bug_tree(self):
+        # Query below returns over 2500 bugs if we try to index everything.
+        # For now just index bitesized bugs - keyword filter added to query.
+        return mysite.customs.bugtrackers.bugzilla.url2bug_data(
+                'https://bugs.freedesktop.org/buglist.cgi?query_format=advanced&keywords=janitor&resolution=---&product=xorg')
+
+    @staticmethod
+    def extract_tracker_specific_data(xml_data, ret_dict):
+        # Make modifications to ret_dict using provided metadata
+        # Check for the bitesized keyword
+        keywords_text = mysite.customs.bugtrackers.bugzilla.get_tag_text_from_xml(xml_data, 'keywords')
+        keywords = map(lambda s: s.strip(),
+                       keywords_text.split(','))
+        ret_dict['good_for_newcomers'] = ('janitor' in keywords)
+        # Then pass ret_dict back
+        return ret_dict
+
+class LocamotionBugzilla(BugzillaBugTracker):
+    enabled = True
+
+    def __init__(self):
+        BugzillaBugTracker.__init__(self,
+                                    base_url='http://bugs.locamotion.org/',
+                                    project_name='Locamotion',
+                                    bug_project_name_format='{product}')
+
+    def get_current_xml_bug_tree(self):
+        return mysite.customs.bugtrackers.bugzilla.url2bug_data(
+                'http://bugs.locamotion.org/buglist.cgi?query_format=advanced&resolution=---')
+
+    @staticmethod
+    def extract_tracker_specific_data(xml_data, ret_dict):
+        # Make modifications to ret_dict using provided metadata
+        ret_dict['good_for_newcomers'] = False # No bitesized keyword.
+        # Then pass ret_dict back
+        return ret_dict
+
+class HypertritonBugzilla(BugzillaBugTracker):
+    enabled = True
+
+    def __init__(self):
+        BugzillaBugTracker.__init__(self,
+                                    base_url='https://hypertriton.com/bugzilla/',
+                                    project_name='Hypertriton',
+                                    bug_project_name_format='{product}')
+
+    def get_current_xml_bug_tree(self):
+        return mysite.customs.bugtrackers.bugzilla.url2bug_data(
+                'https://hypertriton.com/bugzilla/buglist.cgi?query_format=advanced&resolution=---&product=Agar&product=EDAcious&product=FabBSD&product=FreeSG')
+
+    @staticmethod
+    def extract_tracker_specific_data(xml_data, ret_dict):
+        # Make modifications to ret_dict using provided metadata
+        ret_dict['good_for_newcomers'] = False # No bitesized keyword
+        # Then pass ret_dict back
+        return ret_dict
+
+class PygameBugzilla(BugzillaBugTracker):
+    enabled = True
+
+    def __init__(self):
+        BugzillaBugTracker.__init__(self,
+                                    base_url='http://pygame.motherhamster.org/bugzilla/',
+                                    project_name='pygame',
+                                    bug_project_name_format='{project}')
+
+    def get_current_xml_bug_tree(self):
+        return mysite.customs.bugtrackers.bugzilla.url2bug_data(
+                'http://pygame.motherhamster.org/bugzilla/buglist.cgi?query_format=advanced&resolution=---')
+
+    @staticmethod
+    def extract_tracker_specific_data(xml_data, ret_dict):
+        # Make modifications to ret_dict using provided metadata
+        ret_dict['good_for_newcomers'] = False # No bitesized keyword
+        # Then pass ret_dict back
+        return ret_dict
+
 # The generic class for Bugzilla trackers. Copy it.
 # If the project has a tracker bug for the bugs to be imported,
 # set bug_id_list_only=True in BugzillaBugTracker.__init__ and
-- 
1.7.1


From 83f4a036df0603bfcfa6241a657abd4c53007b9d Mon Sep 17 00:00:00 2001
From: Jack Grigg <me@jackgrigg.com>
Date: Sat, 26 Jun 2010 15:03:37 +0000
Subject: [PATCH 11/12] Disabled Locamotion bug tracker due to XML bug data causing lxml to throw lxml.etree.XMLSyntaxError

---
 mysite/search/tasks/bugzilla_instances.py |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/mysite/search/tasks/bugzilla_instances.py b/mysite/search/tasks/bugzilla_instances.py
index 54a5bf3..68e942e 100644
--- a/mysite/search/tasks/bugzilla_instances.py
+++ b/mysite/search/tasks/bugzilla_instances.py
@@ -476,7 +476,7 @@ class XOrgBugzilla(BugzillaBugTracker):
         return ret_dict
 
 class LocamotionBugzilla(BugzillaBugTracker):
-    enabled = True
+    enabled = False # FIXME: Throws XML encoding error.
 
     def __init__(self):
         BugzillaBugTracker.__init__(self,
-- 
1.7.1


From b7ac57a410a6dd3c9645056486c2a628ab1a75c4 Mon Sep 17 00:00:00 2001
From: Jack Grigg <me@jackgrigg.com>
Date: Sun, 27 Jun 2010 11:03:31 +0000
Subject: [PATCH 12/12] Modified search_daily_tasks to only catch HTTP errors, so it doesn't mask other problems.

---
 .../management/commands/search_daily_tasks.py      |    5 ++++-
 1 files changed, 4 insertions(+), 1 deletions(-)

diff --git a/mysite/search/management/commands/search_daily_tasks.py b/mysite/search/management/commands/search_daily_tasks.py
index b4caebf..2b4798c 100644
--- a/mysite/search/management/commands/search_daily_tasks.py
+++ b/mysite/search/management/commands/search_daily_tasks.py
@@ -11,6 +11,8 @@ import mysite.search.tasks.trac_instances
 import mysite.search.tasks.bugzilla_instances
 import mysite.search.tasks.launchpad_tasks
 
+import mechanize._response
+
 ### All this code runs synchronously once a day.
 ### For now, we can crawl all the bug trackers in serial.
 
@@ -92,8 +94,9 @@ class Command(BaseCommand):
             # breaking.
             try:
                 instantiated.update()
-            except:
+            except mechanize._response.httperror_seek_wrapper, e:
                 logging.info("[Bugzilla] ERROR: Importer failed, likely HTTP500, continuing on...")
+                logging.info("[Bugzilla] Error message: %s" % type(e))
 
     def update_launchpad_hosted_projects(self):
         ### For Launchpad:
-- 
1.7.1

