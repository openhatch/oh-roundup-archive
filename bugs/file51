From 5a3b1871bcd195eb65751960e8796f9b402f7e71 Mon Sep 17 00:00:00 2001
From: Jack Grigg <me@jackgrigg.com>
Date: Tue, 6 Jul 2010 04:46:36 +0000
Subject: [PATCH] Moved all bug importing code from 'search.tasks' to 'customs.bugtrackers',
 and changed all references in code appropriately.

---
 mysite/customs/bugtrackers/bugzilla.py             |  661 +++++++++++++++++++-
 mysite/customs/bugtrackers/launchpad.py            |  220 +++++++
 mysite/customs/bugtrackers/roundup.py              |  261 ++++++++
 mysite/customs/bugtrackers/roundup_general.py      |  261 --------
 mysite/customs/bugtrackers/trac.py                 |  556 ++++++++++++++++-
 .../management/commands/customs_daily_tasks.py     |  115 ++++
 mysite/customs/tests.py                            |  182 +++++-
 mysite/search/launchpad_crawl.py                   |  127 ----
 .../management/commands/search_daily_tasks.py      |  116 ----
 mysite/search/tasks/__init__.py                    |    4 -
 mysite/search/tasks/bugzilla_instances.py          |  653 -------------------
 mysite/search/tasks/launchpad_tasks.py             |   93 ---
 mysite/search/tasks/trac_instances.py              |  548 ----------------
 mysite/search/tests.py                             |  154 -----
 14 files changed, 1978 insertions(+), 1973 deletions(-)
 create mode 100644 mysite/customs/bugtrackers/launchpad.py
 create mode 100644 mysite/customs/bugtrackers/roundup.py
 delete mode 100644 mysite/customs/bugtrackers/roundup_general.py
 create mode 100644 mysite/customs/management/commands/customs_daily_tasks.py
 delete mode 100644 mysite/search/launchpad_crawl.py
 delete mode 100644 mysite/search/management/commands/search_daily_tasks.py
 delete mode 100644 mysite/search/tasks/bugzilla_instances.py
 delete mode 100644 mysite/search/tasks/launchpad_tasks.py
 delete mode 100644 mysite/search/tasks/roundup_instances.py
 delete mode 100644 mysite/search/tasks/trac_instances.py

diff --git a/mysite/customs/bugtrackers/bugzilla.py b/mysite/customs/bugtrackers/bugzilla.py
index fd6c062..fa58494 100644
--- a/mysite/customs/bugtrackers/bugzilla.py
+++ b/mysite/customs/bugtrackers/bugzilla.py
@@ -1,11 +1,17 @@
 import csv
 import datetime
+import logging
 
 import lxml.etree
 
-import mysite.base.helpers
 from mysite.base.decorators import cached_property
+import mysite.base.models
+import mysite.base.helpers
 import mysite.customs.ohloh
+import mysite.search.models
+
+############################################################
+# Functions and classes for interacting with the tracker
 
 def find_ctype_xml_form_number(forms):
     for n, form in enumerate(forms):
@@ -146,3 +152,656 @@ class BugzillaBug:
             }
         ret_dict = extract_tracker_specific_data(xml_data, ret_dict)
         return ret_dict
+
+############################################################
+# General bug importing class
+
+# FIXME: Should have this somewhere else. Maybe a decorator?
+# Could take arguments of urls and remove the fresh ones.
+def url_is_more_fresh_than_one_day(url):
+    url_timestamp = mysite.base.models.Timestamp.get_timestamp_for_string(url)
+    url_age = datetime.datetime.now() - url_timestamp
+    url_is_fresh = (url_age < datetime.timedelta(days=1))
+    try:
+        mysite.base.models.Timestamp.update_timestamp_for_string(url)
+    except Exception, e:
+        logging.error("[Bugzilla] Error generated when updating Timestamp.")
+        logging.error("[Bugzilla] Error type is %s" % type(e))
+        logging.error("[Bugzilla] Error is %s" % e)
+    return url_is_fresh
+
+class BugzillaBugTracker(object):
+    def __init__(self, base_url, project_name, bug_project_name_format, bug_id_list_only=False):
+        self.base_url = base_url
+        self.project_name = project_name
+        self.bug_project_name_format = bug_project_name_format
+        self.bug_id_list_only = bug_id_list_only
+
+    def generate_bug_xml_from_queries(self, queries):
+        for query_name in queries:
+            query_url = queries[query_name]
+            # Check if this url has been accessed in the last day
+            if url_is_more_fresh_than_one_day(query_url):
+                # Sweet, ignore this one and go on.
+                logging.info("[Bugzilla] URL %s is fresh, skipping..." % query_url)
+                continue
+            query_xml = mysite.customs.bugtrackers.bugzilla.url2bug_data(query_url)
+            for bug_xml in query_xml.xpath('bug'):
+                yield bug_xml
+
+    def generate_bug_project_name(self, bb):
+        return self.bug_project_name_format.format(
+                project = self.project_name,
+                product = bb.product,
+                component = bb.component)
+
+    def create_or_refresh_one_bugzilla_bug(self, bb):
+        bug_id = bb.bug_id
+        bug_url = bb.as_bug_specific_url()
+
+        try:
+            bug = mysite.search.models.Bug.all_bugs.get(
+                    canonical_bug_link=bug_url)
+            # Found an existing bug. Does it need refreshing?
+            if bug.data_is_more_fresh_than_one_day():
+                logging.info("[Bugzilla] Bug %d from %s is fresh. Doing nothing!" % (bug_id, self.project_name))
+                return False # sweet
+        except mysite.search.models.Bug.DoesNotExist:
+            # This is a new bug
+            bug = mysite.search.models.Bug(canonical_bug_link = bug_url)
+
+        # Looks like we have some refreshing to do.
+        logging.info("[Bugzilla] Refreshing bug %d from %s." % (bug_id, self.project_name))
+        # Get the dictionary of data to put into the bug. The function for
+        # obtaining tracker-specific data is passed in.
+        data = bb.as_data_dict_for_bug_object(self.extract_tracker_specific_data)
+
+        # Fill that bug!
+        for key in data:
+            value = data[key]
+            setattr(bug, key, value)
+
+        # Find or create the project for the bug and save it
+        bug_project_name = self.generate_bug_project_name(bb)
+        if bug_project_name == '':
+            raise ValueError("Can't have bug_project_name as ''")
+        project_from_name, _ = mysite.search.models.Project.objects.get_or_create(name=bug_project_name)
+        if bug.project_id != project_from_name.id:
+            bug.project = project_from_name
+        bug.last_polled = datetime.datetime.utcnow()
+        bug.save()
+        logging.info("[Bugzilla] Finished with %d from %s." % (bug_id, self.project_name))
+        return True
+
+    def refresh_all_bugs(self):
+        for bug in mysite.search.models.Bug.all_bugs.filter(
+                canonical_bug_link__contains=self.base_url):
+            bb = mysite.customs.bugtrackers.bugzilla.BugzillaBug.from_url(
+                    bug.canonical_bug_link)
+            self.create_or_refresh_one_bugzilla_bug(bb=bb)
+
+    def update(self):
+        logging.info("[Bugzilla] Started refreshing all %s bugs" % self.project_name)
+
+        # First, go through and create or refresh all the bugs that
+        # we are configured to track. This will add new bugs and
+        # update current ones. Bugzilla doesn't return a nice
+        # CSV list of bug ids, but instead gives an entire XML tree
+        # of bug data for the bugs matching the query. To save on
+        # network traffic, the bug data will be passed to the refresher.
+        if self.bug_id_list_only:
+            # If we have a tracking bug, then we can't get an xml tree
+            # of bug data. Instead we have to use the bug ids pulled
+            # from the dependencies of the tracking bug.
+            current_bug_id_list = self.get_current_bug_id_list()
+            for bug_id in current_bug_id_list:
+                bb = mysite.customs.bugtrackers.bugzilla.BugzillaBug(
+                        BASE_URL=self.base_url,
+                        bug_id=bug_id)
+                self.create_or_refresh_one_bugzilla_bug(bb=bb)
+        else:
+            logging.info("[Bugzilla] Fetching XML data for bugs in tracker...")
+            for bug_data in self.generate_current_bug_xml():
+                bb = mysite.customs.bugtrackers.bugzilla.BugzillaBug(
+                        BASE_URL=self.base_url,
+                        bug_data=bug_data)
+                self.create_or_refresh_one_bugzilla_bug(bb=bb)
+
+        # Then refresh all the bugs we have from this tracker. This
+        # should skip over all the bugs except the ones that didn't
+        # appear in the above query. Usually this is closed bugs.
+        self.refresh_all_bugs()
+
+############################################################
+# Specific sub-classes for individual bug trackers
+
+class MiroBugzilla(BugzillaBugTracker):
+    enabled = True
+
+    def __init__(self):
+        BugzillaBugTracker.__init__(self,
+                                    base_url='http://bugzilla.pculture.org/',
+                                    project_name='Miro',
+                                    bug_project_name_format='{project}')
+
+    def generate_current_bug_xml(self):
+        queries = {
+                'Easy bugs':
+                    'http://bugzilla.pculture.org/buglist.cgi?bug_status=NEW&bug_status=ASSIGNED&bug_status=REOPENED&field-1-0-0=bug_status&field-1-1-0=product&field-1-2-0=keywords&keywords=bitesized&product=Miro&query_format=advanced&remaction=&type-1-0-0=anyexact&type-1-1-0=anyexact&type-1-2-0=anywords&value-1-0-0=NEW%2CASSIGNED%2CREOPENED&value-1-1-0=Miro&value-1-2-0=bitesized',
+                #'Documentation bugs':
+                    #''
+                }
+        return self.generate_bug_xml_from_queries(queries)
+
+    @staticmethod
+    def extract_tracker_specific_data(xml_data, ret_dict):
+        # Make modifications to ret_dict using provided xml data
+        keywords_text = mysite.customs.bugtrackers.bugzilla.get_tag_text_from_xml(xml_data, 'keywords')
+        keywords = map(lambda s: s.strip(),
+                       keywords_text.split(','))
+        ret_dict['good_for_newcomers'] = ('bitesized' in keywords)
+        ret_dict['bite_size_tag_name'] = 'bitesized'
+        # Then pass ret_dict back
+        return ret_dict
+
+class KDEBugzilla(BugzillaBugTracker):
+    enabled = True
+
+    def __init__(self):
+        BugzillaBugTracker.__init__(self,
+                                    base_url='https://bugs.kde.org/',
+                                    project_name='KDE',
+                                    bug_project_name_format='')
+
+    def generate_current_bug_xml(self):
+        queries = {
+                'Easy bugs':
+                    'https://bugs.kde.org/buglist.cgi?query_format=advanced&keywords=junior-jobs&resolution=---',
+                'Documentation bugs':
+                    'https://bugs.kde.org/buglist.cgi?query_format=advanced&product=docs&resolution=---'
+                }
+        return self.generate_bug_xml_from_queries(queries)
+
+    @staticmethod
+    def extract_tracker_specific_data(xml_data, ret_dict):
+        # Make modifications to ret_dict using provided metadata
+        keywords_text = mysite.customs.bugtrackers.bugzilla.get_tag_text_from_xml(xml_data, 'keywords')
+        keywords = map(lambda s: s.strip(),
+                       keywords_text.split(','))
+        ret_dict['good_for_newcomers'] = ('junior-jobs' in keywords)
+        ret_dict['bite_size_tag_name'] = 'junior-jobs'
+        # Remove 'JJ:' from title if present
+        if ret_dict['title'].startswith("JJ:"):
+            ret_dict['title'] = ret_dict['title'][3:].strip()
+        # Check whether documentation bug
+        product = mysite.customs.bugtrackers.bugzilla.get_tag_text_from_xml(xml_data, 'product')
+        ret_dict['concerns_just_documentation'] = (product == 'docs')
+        # Then pass ret_dict back
+        return ret_dict
+
+    def generate_bug_project_name(self, bb):
+        product = bb.product
+        reasonable_products = set([
+            'Akonadi',
+            'Phonon'
+            'kmail',
+            'Rocs',
+            'akregator',
+            'amarok',
+            'ark',
+            'cervisia',
+            'k3b',
+            'kappfinder',
+            'kbabel',
+            'kdeprint',
+            'kdesktop',
+            'kfile',
+            'kfourinline',
+            'khotkeys',
+            'kio',
+            'kmail',
+            'kmplot',
+            'koffice',
+            'kompare',
+            'konqueror',
+            'kopete',
+            'kpat',
+            'kphotoalbum',
+            'krita',
+            'ksmserver',
+            'kspread',
+            'ksysguard',
+            'ktimetracker',
+            'kwin',
+            'kword',
+            'marble',
+            'okular',
+            'plasma',
+            'printer-applet',
+            'rsibreak',
+            'step',
+            'systemsettings',
+            'kdelibs',
+            'kcontrol',
+            'korganizer',
+            'kipiplugins',
+            'Phonon',
+            'dolphin',
+            'umbrello']
+            )
+        products_to_be_renamed = {
+            'digikamimageplugins': 'digikam image plugins',
+            'Network Management': 'KDE Network Management',
+            'telepathy': 'telepathy for KDE',
+            'docs': 'KDE documentation',
+            }
+        component = bb.component
+        things = (product, component)
+
+        if product in reasonable_products:
+            bug_project_name = product
+        else:
+            if product in products_to_be_renamed:
+                bug_project_name = products_to_be_renamed[product]
+            else:
+                logging.info("Guessing on KDE subproject name. Found %s" %  repr(things))
+                bug_project_name = product
+        return bug_project_name
+
+class MediaWikiBugzilla(BugzillaBugTracker):
+    enabled = True
+
+    def __init__(self):
+        BugzillaBugTracker.__init__(self,
+                                    base_url='https://bugzilla.wikimedia.org/',
+                                    project_name='MediaWiki',
+                                    bug_project_name_format='')
+
+    def generate_current_bug_xml(self):
+        queries = {
+                'Easy bugs':
+                    'https://bugzilla.wikimedia.org/buglist.cgi?keywords=easy&query_format=advanced&resolution=LATER&resolution=---',
+                'Documentation bugs':
+                    'https://bugzilla.wikimedia.org/buglist.cgi?query_format=advanced&component=Documentation&resolution=---'
+                }
+        return self.generate_bug_xml_from_queries(queries)
+
+    @staticmethod
+    def extract_tracker_specific_data(xml_data, ret_dict):
+        # Make modifications to ret_dict using provided metadata
+        # Check for the bitesized keyword
+        keywords_text = mysite.customs.bugtrackers.bugzilla.get_tag_text_from_xml(xml_data, 'keywords')
+        keywords = map(lambda s: s.strip(),
+                       keywords_text.split(','))
+        ret_dict['good_for_newcomers'] = ('easy' in keywords)
+        ret_dict['bite_size_tag_name'] = 'easy'
+        # Check whether documentation bug
+        component = mysite.customs.bugtrackers.bugzilla.get_tag_text_from_xml(xml_data, 'component')
+        ret_dict['concerns_just_documentation'] = (component == 'Documentation')
+        # Then pass ret_dict back
+        return ret_dict
+
+    def generate_bug_project_name(self, bb):
+        product = bb.product
+        if product == 'MediaWiki extensions':
+            bug_project_name = bb.component
+            if bug_project_name in ('FCKeditor', 'Gadgets'):
+                bug_project_name += ' for MediaWiki'
+        else:
+            bug_project_name = product
+        return bug_project_name
+
+class GnomeBugzilla(BugzillaBugTracker):
+    enabled = True
+
+    def __init__(self):
+        BugzillaBugTracker.__init__(self,
+                                    base_url='https://bugzilla.gnome.org/',
+                                    project_name='Gnome',
+                                    bug_project_name_format='')
+
+    def generate_current_bug_xml(self):
+        # Get all bugs that contain any of the keywords 'gnome-love'
+        # or 'documentation'
+        queries = {
+                'Easy bugs':
+                    'https://bugzilla.gnome.org/buglist.cgi?columnlist=id&keywords=gnome-love&query_format=advanced&resolution=---',
+                # FIXME: Query with documentation keyword causes XML syntax errors
+                #'Documentation bugs':
+                    #'https://bugzilla.gnome.org/buglist.cgi?columnlist=id&keywords=gnome-love%2Cdocumentation&query_format=advanced&resolution=---'
+                }
+        return self.generate_bug_xml_from_queries(queries)
+
+    @staticmethod
+    def extract_tracker_specific_data(xml_data, ret_dict):
+        # Make modifications to ret_dict using provided metadata
+        # Check for the bitesized keyword
+        keywords_text = mysite.customs.bugtrackers.bugzilla.get_tag_text_from_xml(xml_data, 'keywords')
+        keywords = map(lambda s: s.strip(),
+                       keywords_text.split(','))
+        ret_dict['good_for_newcomers'] = ('gnome-love' in keywords)
+        ret_dict['bite_size_tag_name'] = 'gnome-love'
+        # Check whether this is a documentation bug.
+        ret_dict['concerns_just_documentation'] = ('documentation' in keywords)
+        # Then pass ret_dict back
+        return ret_dict
+
+    def generate_bug_project_name(self, bb):
+        bug_project_name = bb.product
+        gnome2openhatch = {'general': 'GNOME (general)',
+                           'website': 'GNOME (website)'}
+        if bug_project_name in gnome2openhatch:
+            bug_project_name=gnome2openhatch[bug_project_name]
+        return bug_project_name
+
+class MozillaBugzilla(BugzillaBugTracker):
+    enabled = True
+
+    def __init__(self):
+        BugzillaBugTracker.__init__(self,
+                                    base_url='https://bugzilla.mozilla.org/',
+                                    project_name='Mozilla',
+                                    bug_project_name_format='')
+
+    def generate_current_bug_xml(self):
+        queries = {
+                'Easy bugs':
+                    'https://bugzilla.mozilla.org/buglist.cgi?resolution=---;status_whiteboard_type=substring;query_format=advanced;status_whiteboard=[good%20first%20bug]',
+                #'Documentation bugs':
+                    #''
+                }
+        return self.generate_bug_xml_from_queries(queries)
+
+    @staticmethod
+    def extract_tracker_specific_data(xml_data, ret_dict):
+        # Make modifications to ret_dict using provided metadata
+        # Check for the bitesized keyword
+        whiteboard_text = mysite.customs.bugtrackers.bugzilla.get_tag_text_from_xml(xml_data, 'status_whiteboard')
+        ret_dict['good_for_newcomers'] = (whiteboard_text == '[good first bug]')
+        ret_dict['bite_size_tag_name'] = '[good first bug]'
+        # Then pass ret_dict back
+        return ret_dict
+
+    def generate_bug_project_name(self, bb):
+        ### Special-case the project names we know about
+        mozilla2openhatch = {'Core': 'Mozilla Core',
+                             'Firefox': 'Firefox',
+                             'MailNews Core': 'Mozilla Messaging',
+                             'addons.mozilla.org': 'addons.mozilla.org',
+                             'Thunderbird': 'Thunderbird',
+                             'Testing': 'Mozilla automated testing',
+                             'Directory': 'Mozilla LDAP',
+                             'mozilla.org': 'mozilla.org',
+                             'SeaMonkey': 'SeaMonkey',
+                             'Toolkit': 'Mozilla Toolkit',
+                             'support.mozilla.com': 'support.mozilla.com',
+                             'Camino': 'Camino',
+                             'Calendar': 'Mozilla Calendar',
+                             'Mozilla Localizations': 'Mozilla Localizations',
+                             }
+        if bb.product == 'Other Applications':
+            bug_project_name = 'Mozilla ' + bb.component
+        else:
+            bug_project_name = mozilla2openhatch[bb.product]
+        return bug_project_name
+
+class FedoraBugzilla(BugzillaBugTracker):
+    enabled = True
+
+    def __init__(self):
+        BugzillaBugTracker.__init__(self,
+                                    base_url='https://bugzilla.redhat.com/',
+                                    project_name='Fedora',
+                                    bug_project_name_format='{component}',
+                                    bug_id_list_only=True)
+
+    def get_current_bug_id_list(self):
+        return mysite.customs.bugtrackers.bugzilla.tracker_bug2bug_ids(
+                'https://bugzilla.redhat.com/show_bug.cgi?ctype=xml&id=509829')
+
+    @staticmethod
+    def extract_tracker_specific_data(xml_data, ret_dict):
+        # Make modifications to ret_dict using provided metadata
+        # Check for the bitesized keyword
+        keywords_text = mysite.customs.bugtrackers.bugzilla.get_tag_text_from_xml(xml_data, 'keywords')
+        keywords = map(lambda s: s.strip(),
+                       keywords_text.split(','))
+        ret_dict['good_for_newcomers'] = True # Since they are 'fit and finish'
+        ret_dict['bite_size_tag_name'] = 'fitandfinish'
+        # Set the distribution tag
+        ret_dict['as_appears_in_distribution'] = 'Fedora'
+        # Then pass ret_dict back
+        return ret_dict
+
+class SongbirdBugzilla(BugzillaBugTracker):
+    enabled = True
+
+    def __init__(self):
+        BugzillaBugTracker.__init__(self,
+                                    base_url='http://bugzilla.songbirdnest.com/',
+                                    project_name='Songbird',
+                                    bug_project_name_format='{project}')
+
+    def generate_current_bug_xml(self):
+        # Query below returns nearly 4000 bugs if we try to index everything.
+        # For now, only import bugs with 'helpwanted' tag.
+        # (This tag doesn't equate to 'bitesized'.)
+        queries = {
+                'Helpwanted bugs':
+                    'http://bugzilla.songbirdnest.com/buglist.cgi?query_format=advanced&resolution=---&keywords=helpwanted',
+                'Documentation bugs':
+                    'http://bugzilla.songbirdnest.com/buglist.cgi?query_format=advanced&component=Documentation&resolution=---'
+                }
+        return self.generate_bug_xml_from_queries(queries)
+
+    @staticmethod
+    def extract_tracker_specific_data(xml_data, ret_dict):
+        # Make modifications to ret_dict using provided metadata
+        ret_dict['good_for_newcomers'] = False # 'helpwanted' doesn't just indicate bitesized.
+        # Check whether documentation bug
+        component = mysite.customs.bugtrackers.bugzilla.get_tag_text_from_xml(xml_data, 'component')
+        ret_dict['concerns_just_documentation'] = (component == 'Documentation')
+        # Then pass ret_dict back
+        return ret_dict
+
+class ApertiumBugzilla(BugzillaBugTracker):
+    enabled = True
+
+    def __init__(self):
+        BugzillaBugTracker.__init__(self,
+                                    base_url='http://bugs.apertium.org/cgi-bin/bugzilla/',
+                                    project_name='Apertium',
+                                    bug_project_name_format='{project}')
+
+    def generate_current_bug_xml(self):
+        queries = {
+                'All bugs':
+                    'http://bugs.apertium.org/cgi-bin/bugzilla/buglist.cgi?query_format=advanced&resolution=---'
+                }
+        return self.generate_bug_xml_from_queries(queries)
+
+    @staticmethod
+    def extract_tracker_specific_data(xml_data, ret_dict):
+        # Make modifications to ret_dict using provided metadata
+        ret_dict['good_for_newcomers'] = False # No bitesized keyword.
+        # Then pass ret_dict back
+        return ret_dict
+
+class RTEMSBugzilla(BugzillaBugTracker):
+    enabled = True
+
+    def __init__(self):
+        BugzillaBugTracker.__init__(self,
+                                    base_url='https://www.rtems.org/bugzilla/',
+                                    project_name='RTEMS',
+                                    bug_project_name_format='{project}')
+
+    def generate_current_bug_xml(self):
+        queries = {
+                'All bugs':
+                    'https://www.rtems.org/bugzilla/buglist.cgi?query_format=advanced&resolution=---'
+                }
+        return self.generate_bug_xml_from_queries(queries)
+
+    @staticmethod
+    def extract_tracker_specific_data(xml_data, ret_dict):
+        # Make modifications to ret_dict using provided metadata
+        ret_dict['good_for_newcomers'] = False # No bitesized keyword.
+        # Check whether documentation bug
+        component = mysite.customs.bugtrackers.bugzilla.get_tag_text_from_xml(xml_data, 'component')
+        ret_dict['concerns_just_documentation'] = (component == 'doc')
+        # Then pass ret_dict back
+        return ret_dict
+
+# This tracker could be extended to cover all of FreeDesktop.
+# For now, just do X.Org since it is all that was requested.
+class XOrgBugzilla(BugzillaBugTracker):
+    enabled = True
+
+    def __init__(self):
+        BugzillaBugTracker.__init__(self,
+                                    base_url='https://bugs.freedesktop.org/',
+                                    project_name='XOrg',
+                                    bug_project_name_format='{project}')
+
+    def generate_current_bug_xml(self):
+        # Query below returns over 2500 bugs if we try to index everything.
+        # For now just index bitesized bugs - keyword filter added to query.
+        queries = {
+                'Easy bugs':
+                    'https://bugs.freedesktop.org/buglist.cgi?query_format=advanced&keywords=janitor&resolution=---&product=xorg',
+                'Documentation bugs':
+                    'https://bugs.freedesktop.org/buglist.cgi?query_format=advanced&component=Docs%2Fother&component=Documentation&component=Fonts%2Fdoc&resolution=---&product=xorg'
+                }
+        return self.generate_bug_xml_from_queries(queries)
+
+    @staticmethod
+    def extract_tracker_specific_data(xml_data, ret_dict):
+        # Make modifications to ret_dict using provided metadata
+        # Check for the bitesized keyword
+        keywords_text = mysite.customs.bugtrackers.bugzilla.get_tag_text_from_xml(xml_data, 'keywords')
+        keywords = map(lambda s: s.strip(),
+                       keywords_text.split(','))
+        ret_dict['good_for_newcomers'] = ('janitor' in keywords)
+        ret_dict['bite_size_tag_name'] = 'janitor'
+        # Check whether documentation bug
+        component = mysite.customs.bugtrackers.bugzilla.get_tag_text_from_xml(xml_data, 'component')
+        documentation_components = [
+                'Docs/other',
+                'Documentation',
+                'Fonts/doc']
+        ret_dict['concerns_just_documentation'] = (component in documentation_components)
+        # Then pass ret_dict back
+        return ret_dict
+
+class LocamotionBugzilla(BugzillaBugTracker):
+    enabled = False # FIXME: Throws XML encoding error.
+
+    def __init__(self):
+        BugzillaBugTracker.__init__(self,
+                                    base_url='http://bugs.locamotion.org/',
+                                    project_name='Locamotion',
+                                    bug_project_name_format='{product}')
+
+    def generate_current_bug_xml(self):
+        queries = {
+                'All bugs':
+                    'http://bugs.locamotion.org/buglist.cgi?query_format=advanced&resolution=---'
+                }
+        return self.generate_bug_xml_from_queries(queries)
+
+    @staticmethod
+    def extract_tracker_specific_data(xml_data, ret_dict):
+        # Make modifications to ret_dict using provided metadata
+        ret_dict['good_for_newcomers'] = False # No bitesized keyword.
+        # Then pass ret_dict back
+        return ret_dict
+
+class HypertritonBugzilla(BugzillaBugTracker):
+    enabled = True
+
+    def __init__(self):
+        BugzillaBugTracker.__init__(self,
+                                    base_url='https://hypertriton.com/bugzilla/',
+                                    project_name='Hypertriton',
+                                    bug_project_name_format='{product}')
+
+    def generate_current_bug_xml(self):
+        queries = {
+                'All bugs':
+                    'https://hypertriton.com/bugzilla/buglist.cgi?query_format=advanced&resolution=---&product=Agar&product=EDAcious&product=FabBSD&product=FreeSG'
+                }
+        return self.generate_bug_xml_from_queries(queries)
+
+    @staticmethod
+    def extract_tracker_specific_data(xml_data, ret_dict):
+        # Make modifications to ret_dict using provided metadata
+        ret_dict['good_for_newcomers'] = False # No bitesized keyword
+        # Then pass ret_dict back
+        return ret_dict
+
+class PygameBugzilla(BugzillaBugTracker):
+    enabled = True
+
+    def __init__(self):
+        BugzillaBugTracker.__init__(self,
+                                    base_url='http://pygame.motherhamster.org/bugzilla/',
+                                    project_name='pygame',
+                                    bug_project_name_format='{project}')
+
+    def generate_current_bug_xml(self):
+        queries = {
+                'All bugs':
+                    'http://pygame.motherhamster.org/bugzilla/buglist.cgi?query_format=advanced&resolution=---'
+                }
+        return self.generate_bug_xml_from_queries(queries)
+
+    @staticmethod
+    def extract_tracker_specific_data(xml_data, ret_dict):
+        # Make modifications to ret_dict using provided metadata
+        ret_dict['good_for_newcomers'] = False # No bitesized keyword
+        # Then pass ret_dict back
+        return ret_dict
+
+# The generic class for Bugzilla trackers. Copy it.
+# If the project has a tracker bug for the bugs to be imported,
+# set bug_id_list_only=True in BugzillaBugTracker.__init__ and
+# replace get_current_xml_bug_tree with get_current_bug_id_list
+# bug_project_name_format can contain the tags {project},
+# {product} and {component} which will be replaced accordingly.
+class GenBugzilla(BugzillaBugTracker):
+    enabled = False
+
+    def __init__(self):
+        BugzillaBugTracker.__init__(self,
+                                    base_url='',
+                                    project_name='',
+                                    bug_project_name_format='')
+
+    def generate_current_bug_xml(self):
+        # Can replace both entries below with an 'All bugs' query.
+        queries = {
+                'Easy bugs':
+                    '',
+                'Documentation bugs':
+                    ''
+                }
+        return self.generate_bug_xml_from_queries(queries)
+
+    @staticmethod
+    def extract_tracker_specific_data(xml_data, ret_dict):
+        # Make modifications to ret_dict using provided metadata
+        # Check for the bitesized keyword
+        keywords_text = mysite.customs.bugtrackers.bugzilla.get_tag_text_from_xml(xml_data, 'keywords')
+        keywords = map(lambda s: s.strip(),
+                       keywords_text.split(','))
+        ret_dict['good_for_newcomers'] = ('' in keywords)
+        ret_dict['bite_size_tag_name'] = ''
+        # Then pass ret_dict back
+        return ret_dict
+
+    # The format string method for generating the project name can be
+    # overloaded by uncommenting the function below.
+    #def generate_bug_project_name(self, bb):
+        #return bug_project_name
+
diff --git a/mysite/customs/bugtrackers/launchpad.py b/mysite/customs/bugtrackers/launchpad.py
new file mode 100644
index 0000000..c7ee0cb
--- /dev/null
+++ b/mysite/customs/bugtrackers/launchpad.py
@@ -0,0 +1,220 @@
+import codecs
+import datetime
+import glob
+import logging
+import os
+
+import mysite.customs.models
+import mysite.search.models
+
+from celery.task import Task
+from celery.registry import tasks
+import celery.decorators
+
+# Initialize Launchpad scraper thing
+from launchpadbugs.connector import ConnectBug, ConnectBugList
+from launchpadbugs.basebuglistfilter import URLBugListFilter
+
+# Initialize data dumpers
+import mysite.search.lpb2json
+import simplejson
+
+##################################################
+# Crawler functions for Launchpad
+
+#FIXME: Add only those of the following that actually use Launchpad for development.
+#u'apache-mod-digest' : u'apache-mod-digest' , u'bws-upload' : u'BWS-Upload' , u'pyjunitxml' : u'pyjunitxml' , u'bzr-search' : u'bzr search plugin' , u'bzr-email' : u'bzr email commit hook' , u'check' : u'check' , u'libsyncml' : u'libsyncml' , u'config-manager' : u'config-manager' , u'testscenarios' : u'testscenarios' , u'liburl' : u'liburl' , u'liblockdir' : u'lockdir' , u'bzr-guess' : u'bzr-guess' , u'etap' : u'etap' , u'gforth' : u'Gforth' , u'bitten' : u'Bitten' , u'sqlobject' : u'SQLObject' , u'bzr-ping' : u'Ping plugin for Bazaar' , u'unittest-ext' : u'unittest-ext' , u'pytz' : u'pytz' , u'funkload' : u'FunkLoad' , u'slony-i' : u'Slony-I' , u'zoneinfo' : u'The tz Database' , u'py-radius' : u'py-radius' , u'pypi' : u'Python Package Index' , u'pybabel' : u'Python Babel' , u'feedvalidator' : u'Feed Validator' , u'sphinx' : u'Sphinx' , u'mammoth-replicator' : u'Mammoth Replicator' , u'dbapi-compliance' : u'Python DBAPI Compliance Tests' , u'wget' : u'wget' , u'redhatcluster' : u'Red Hat Cluster' , u'bugzilla' : u'Bugzilla' , u'grepmap' : u'grepmap' , u'live-f1' : u'Live F1' , u'libnih' : u'libnih' , u'hct' : u'HCT' , u'upstart' : u'upstart ' , u'module-init-tools' : u'module-init-tools' , u'ubuntu-seeds' : u'Ubuntu Seeds' , u'usplash' : u'usplash' , u'merge-o-matic' : u'Merge-o-Matic' , u'uds-intrepid' : u'UDS Intrepid' , u'watershed' : u'watershed' , u'udev-extras' : u'Udev extras' , u'sreadahead' : u'sreadahead' , u'pybootchartgui' : u'pybootchartgui' , u'bootchart-collector' : u'bootchart-collector' , u'bootchart' : u'bootchart' , u'ubiquity' : u'ubiquity' , u'man-db' : u'man-db'}
+
+
+TextBugList = ConnectBugList("text")
+TextBug = ConnectBug("text")
+
+def dump_data_from_project(project):
+
+        yield serialized
+
+# Callback to handle an update to a single Launchpad bug update
+def handle_launchpad_bug_update(project_name, canonical_bug_link, new_data):
+    """
+    We're going to store a bug in our database. First we want to
+    check to see if we've stored in the DB a stale copy of the same bug.
+
+    Side-effect: We create or update a bug in the database.  
+    In particular, if we already have a bug for this (project,
+    canonical_bug_link) pair, we modify that instead of creating a
+    duplicate entry.
+
+    Right now we do not store last_modified time stamps; no one has
+    yet figured out what good it would do us."""
+    project, _ = mysite.search.models.Project.objects.get_or_create(name=project_name)
+    new_data['project'] = project
+    bug, created = mysite.search.models.Bug.all_bugs.get_or_create(
+            canonical_bug_link=canonical_bug_link, defaults=new_data)
+    # 'defaults' means data used for creating but not getting
+    if created:
+        return bug # nothing to do!
+    else:
+        # else, update the local copy of the bug
+        for key in new_data:
+            setattr(bug, key, new_data[key])
+        bug.save()
+        return bug
+    
+def clean_lp_data_dict(lp_data_dict):
+    """Input: A single datum as returned by launchpadbugs.
+
+    Output: query_data, new_data - two dicts that represent
+    processed data from Launchpad.
+    We've divided the data from launchpad into bug-identifying data (query_data)
+    and the rest of the data we want to store (new_data).
+    """
+    # These are the invariants for every bug: together (well, maybe the
+    # bug link is enough, hush) they uniquely identify the bug.
+    query_data = {}
+    query_data['canonical_bug_link'] = lp_data_dict['url']
+
+    # If the above is the "key" that we use to find or create the record,
+    # these are the "value",
+    new_data = {}
+    new_data['title'] = lp_data_dict['title']
+    new_data['description'] = lp_data_dict['text']
+
+    new_data['importance'] = lp_data_dict['importance']
+    if new_data['importance'] is None:
+        new_data['importance'] =  'Unknown'
+
+    # create set of people who have commented or created the ticket
+    people_involved = set()
+    if lp_data_dict['reporter']:
+        people_involved.add(dict2hashable(lp_data_dict['reporter']))
+    for comment in lp_data_dict['comments']:
+        people_involved.add(dict2hashable(comment['user']))
+
+    new_data['people_involved'] = len(people_involved)
+
+    new_data['submitter_username'] = lp_data_dict['reporter']['lplogin']
+    new_data['submitter_realname'] = unicode(lp_data_dict['reporter']['realname'])
+
+    # Handle dates
+    new_data['last_touched'] = datetime.datetime(*lp_data_dict['date_updated'][:6])
+    new_data['last_polled'] = datetime.datetime.now()
+
+    # Look for bitesize tag
+    # If no 'tags', pass
+    if 'bitesize' in lp_data_dict.get('tags', []):
+        new_data['good_for_newcomers'] = True
+
+    status =  lp_data_dict.get('status', 'Unknown')
+    if not status:
+        status = 'Unknown'
+    new_data['status'] = status
+    if new_data['status'].lower() in ('fix released', 'fix committed'):
+        new_data['looks_closed'] = True
+    # else looks_closed will be False due to the Bug default
+    new_data['date_reported'] = datetime.datetime(
+        *lp_data_dict['date_reported'][:6])
+    return query_data, new_data
+    
+def dict2hashable(d):
+    return tuple(d.items())
+
+def grab_lp_bugs(lp_project, openhatch_project_name):
+    '''Input: The name of a Launchpad project and its corresponding
+    OpenHatch project name.
+
+    Side effect: Loops over the available issues in that project and
+    updates the database with them.'''
+    for data_dict in dump_data_from_project(lp_project):
+        data_dict['project'] = openhatch_project_name
+        query_data, new_data = clean_lp_data_dict(data_dict)
+        handle_launchpad_bug_update(
+                project_name=openhatch_project_name,
+                canonical_bug_link=query_data['canonical_bug_link'],
+                new_data=new_data)
+
+##################################################
+# Import functions for Launchpad
+
+def refresh_bugs_from_all_indexed_launchpad_projects():
+    # Look, ma, a hard-coded table that maps to
+    # OpenHatch project names from Launchpad.net project names.
+    # TimBL would be proud.
+    lpproj2ohproj = { 'lxml': 'lxml',
+                      'do': 'GNOME-do',
+                      'gwibber': 'Gwibber',
+                      'keryx': 'Keryx',
+                     }
+    for launchpad_project_name in lpproj2ohproj:
+        openhatch_project_name = lpproj2ohproj[launchpad_project_name]
+        import_bugs_from_one_project(launchpad_project_name,
+                                     openhatch_project_name)
+
+@celery.decorators.task
+def import_bugs_from_one_project(launchpad_project_name,
+                                 openhatch_project_name):
+    logging.info("Looking at bugs %s on Launchpad" % launchpad_project_name)
+    url = "https://bugs.launchpad.net/%s/+bugs" % launchpad_project_name
+    bug_filter = URLBugListFilter()
+    # no filtering; dump everything
+    l = TextBugList(bug_filter(url))
+    # convert elements into Bug objects
+    for bug in l:
+        openhatch_bug_link = 'https://bugs.launchpad.net/bugs/%d' % (
+            bug.bugnumber)
+        refresh_one_launchpad_bug(
+            canonical_bug_link=openhatch_bug_link,
+            openhatch_project_name=openhatch_project_name)
+
+def refresh_all_launchpad_bugs():
+    logging.info("Refreshing all Launchpad bugs.")
+    all_lp_bugs = mysite.search.models.Bug.all_bugs.filter(
+        canonical_bug_link__startswith='https://bugs.launchpad.net/')
+    logging.info("All %d of them." % all_lp_bugs.count())
+    for lp_bug in all_lp_bugs:
+        refresh_one_launchpad_bug(
+            canonical_bug_link=lp_bug.canonical_bug_link,
+            openhatch_project_name=None)
+
+@celery.decorators.task
+def refresh_one_launchpad_bug(canonical_bug_link,
+                              openhatch_project_name):
+    logging.info("Checking on %s..." % canonical_bug_link)
+    # Either we already have the bug...
+    try:
+        bug = mysite.search.models.Bug.all_bugs.get(
+            canonical_bug_link=canonical_bug_link)
+    # ...or we need to create it
+    except mysite.search.models.Bug.DoesNotExist:
+        bug = mysite.search.models.Bug()
+        bug.canonical_bug_link = canonical_bug_link
+
+    if bug.data_is_more_fresh_than_one_day():
+        return
+
+    # Okay, so it's stale. Refresh the sucker.
+    logging.info("Refreshing %s." % canonical_bug_link)
+
+    # Set the project, if necessary
+    if openhatch_project_name is None:
+        pass
+    else:
+        # Get or create the OpenHatch project
+        openhatch_project, _ = mysite.search.models.Project.objects.get_or_create(name=openhatch_project_name)
+        
+        if bug.project_id != openhatch_project.id:
+            bug.project = openhatch_project
+
+    # FIXME: One day, look at the bug data to see what project to use.
+    # This code incorrectly assumes bugs don't migrate from one project
+    # to another.
+    prefix = 'https://bugs.launchpad.net/bugs/'
+    assert canonical_bug_link.startswith(prefix)
+    bug_id_str = canonical_bug_link.split(prefix, 1)[1]
+    bug_id = int(bug_id_str)
+    tb = TextBug(bug_id)
+    data_dict = mysite.search.lpb2json.obj2serializable(tb)
+    _, new_data = clean_lp_data_dict(data_dict)
+    for key in new_data:
+        setattr(bug, key, new_data[key])
+    bug.last_polled = datetime.datetime.utcnow()
+    bug.save()
diff --git a/mysite/customs/bugtrackers/roundup.py b/mysite/customs/bugtrackers/roundup.py
new file mode 100644
index 0000000..f1888ca
--- /dev/null
+++ b/mysite/customs/bugtrackers/roundup.py
@@ -0,0 +1,261 @@
+import urllib2
+import urllib
+import re
+import lxml.html # scraper library
+import itertools
+import csv
+import datetime
+import logging
+import urlparse
+
+from django.db import models
+
+import mysite.search.models
+import mysite.customs.ohloh
+
+def csv_url2bugs(csv_url):
+    csv_fd = mysite.customs.ohloh.mechanize_get(
+        csv_url).response()
+    dict_reader = csv.DictReader(csv_fd)
+    for thing in dict_reader:
+        yield int(thing['id'])
+
+class RoundupTracker(object):
+    def __init__(self, root_url, project_name):
+        assert root_url[-1] == '/'
+        assert root_url[-2] != '/'
+        self.root_url = unicode(root_url)
+        self.project, _ = mysite.search.models.Project.objects.get_or_create(name=project_name)
+
+    @staticmethod
+    def roundup_tree2metadata_dict(tree):
+        '''
+        Input: tree is a parsed HTML document that lxml.html can understand.
+
+        Output: For each <th>key</th><td>value</td> in the tree,
+        append {'key': 'value'} to a dictionary.
+        Return the dictionary when done.'''
+
+        ret = {}
+        for th in tree.cssselect('th'):
+            # Get next sibling
+            key_with_colon = th.text_content().strip()
+            key = key_with_colon.rsplit(':', 1)[0]
+            try:
+                td = th.itersiblings().next()
+            except StopIteration:
+                # If there isn't an adjacent TD, don't use this TH.
+                continue
+            value = td.text_content().strip()
+            ret[key] = value
+
+        return ret
+
+    def str2datetime_obj(self, date_string, possibility_index=0):
+        # FIXME: I make guesses as to the timezone.
+        possible_date_strings = [
+                "%Y-%m-%d %H:%M",
+                "%Y-%m-%d %H:%M:%S",
+                "%Y-%m-%d.%H:%M",
+                "%Y-%m-%d.%H:%M:%S"]
+        try:
+            return datetime.datetime.strptime(date_string, possible_date_strings[possibility_index])
+        except ValueError:
+            # A keyerror raised here means we ran out of a possibilities.
+            return self.str2datetime_obj(date_string, possibility_index=possibility_index+1)
+
+    def get_remote_bug_ids_already_stored(self):
+        bugs = mysite.search.models.Bug.all_bugs.filter(
+                canonical_bug_link__contains=self.root_url)
+        bug_ids = [self.get_remote_bug_id(bug) for bug in bugs]
+        return bug_ids
+
+    def get_all_submitter_realname_pairs(self, tree):
+        '''Input: the tree
+        Output: A dictionary mapping username=>realname'''
+
+        ret = {}
+        for th in tree.cssselect('th'):
+            match = re.match("Author: ([^(]*) \(([^)]*)", th.text_content().strip())
+            if match:
+                realname, username = match.groups()
+                ret[username] = realname
+        return ret
+
+    def get_submitter_realname(self, tree, submitter_username):
+        try:
+            return self.get_all_submitter_realname_pairs(tree)[submitter_username]
+        except KeyError:
+            return None
+
+    def remote_bug_id2url(self, remote_bug_id):
+        return urlparse.urljoin(self.root_url, "issue%d" % remote_bug_id)
+
+    def get_remote_bug_id(self, bug):
+        plus_slash_issue = urlparse.urljoin(self.root_url, 'issue')
+        return int(bug.canonical_bug_link.split(plus_slash_issue)[1])
+
+    def create_bug_object_for_remote_bug_id_if_necessary(self, remote_bug_id):
+        """See if we have either no bug or only a stale one. If so,
+        refresh."""
+        logging.info(
+            "Was asked to look at bug %d in %s" % (remote_bug_id, self.project.name))
+        try:
+            bug = mysite.search.models.Bug.all_bugs.get(
+                canonical_bug_link=self.remote_bug_id2url(remote_bug_id))
+            if bug.data_is_more_fresh_than_one_day():
+                return False
+        except mysite.search.models.Bug.DoesNotExist:
+            bug = mysite.search.models.Bug()
+            bug.canonical_bug_link = self.remote_bug_id2url(remote_bug_id)
+
+        # otherwise, fill the bug object with fresh data
+        bug = self._update_bug_object_for_remote_bug_id(
+            bug_object=bug,
+            remote_bug_id=remote_bug_id)
+        bug.save()
+        logging.info(
+            "Actually loaded %d in from %s" % (
+                remote_bug_id, self.project.name))
+        return True
+
+    def _update_bug_object_for_remote_bug_id(self, bug_object, remote_bug_id):
+        """Create but don't save a bug."""
+        remote_bug_url = self.remote_bug_id2url(remote_bug_id)
+        tree = lxml.html.document_fromstring(urllib2.urlopen(remote_bug_url).read())
+
+        metadata_dict = RoundupTracker.roundup_tree2metadata_dict(tree)
+
+        date_reported, bug_object.submitter_username, last_touched, last_toucher = [
+                x.text_content() for x in tree.cssselect(
+                    'form[name=itemSynopsis] + p > b, form[name=itemSynopsis] + hr + p > b')]
+        bug_object.submitter_realname = self.get_submitter_realname(tree, bug_object.submitter_username)
+        bug_object.date_reported = self.str2datetime_obj(date_reported)
+        bug_object.last_touched = self.str2datetime_obj(last_touched)
+        bug_object.canonical_bug_link = remote_bug_url
+
+        bug_object.status = metadata_dict['Status'] 
+        bug_object.looks_closed = (metadata_dict['Status'] == 'closed')
+        bug_object.title = metadata_dict['Title'] 
+        bug_object.importance = metadata_dict['Priority']
+
+        # For description, just grab the first "message"
+        try:
+            bug_object.description = tree.cssselect('table.messages td.content')[0].text_content().strip()
+        except IndexError:
+            # This Roundup issue has no messages.
+            bug_object.description = ""
+
+        bug_object.project = self.project
+
+        # How many people participated?
+        bug_object.people_involved = len(self.get_all_submitter_realname_pairs(tree))
+
+        bug_object.last_polled = datetime.datetime.utcnow()
+
+        self.extract_bug_tracker_specific_data(metadata_dict=metadata_dict,
+                                               bug_object=bug_object)
+
+        return bug_object
+
+    def extract_bug_tracker_specific_data(self, metadata_dict, bug_object):
+        raise RuntimeError(NotImplemented)
+
+    def grab(self):
+        """Loops over the Python bug tracker's easy bugs and stores/updates them in our DB.
+        For now, just grab the easy bugs to be kind to their servers."""
+
+        bug_ids = itertools.chain(self.get_remote_bug_ids_to_read(),
+                                  self.get_remote_bug_ids_already_stored())
+
+        for bug_id in bug_ids:
+            print bug_id
+            bug = self.create_bug_object_for_remote_bug_id(bug_id)
+
+            # If there is already a bug with this canonical_bug_link in the DB, just delete it.
+            bugs_this_one_replaces = mysite.search.models.Bug.all_bugs.filter(canonical_bug_link=
+                                                        bug.canonical_bug_link)
+            for delete_me in bugs_this_one_replaces:
+                delete_me.delete()
+
+            print bug
+            # With the coast clear, we save the bug we just extracted from the Miro tracker.
+            bug.save()
+
+    def update(self):
+        '''Call this nightly.'''
+        logging.info("Learning about new bugs in %s" % self.project.name)
+
+        # First, find an examine any new bugs.
+        for bug_id in self.generate_list_of_bug_ids_to_look_at():
+            self.create_bug_object_for_remote_bug_id_if_necessary(bug_id)
+        # Second, make sure old bugs in the database aren't too stale.
+        logging.info("Starting refreshing all bugs from %s." % self.project.name)
+        count = 0
+        for bug_id in self.get_remote_bug_ids_already_stored():
+            self.create_bug_object_for_remote_bug_id_if_necessary(remote_bug_id=bug_id)
+            count += 1
+        logging.info("Okay, looked at %d bugs from %s." % (
+                count, self.project.name))
+
+    def __unicode__(self):
+        return "<Roundup bug tracker for %s>" % self.root_url
+
+class MercurialTracker(RoundupTracker):
+    enabled = True
+
+    def __init__(self):
+        RoundupTracker.__init__(self,
+                                root_url='http://mercurial.selenic.com/bts/',
+                                project_name='Mercurial')
+
+    def extract_bug_tracker_specific_data(self, metadata_dict, bug_object):
+        if 'bitesized' in metadata_dict['Topics']:
+            bug_object.good_for_newcomers = True
+        if 'documentation' in metadata_dict['Topics']:
+            bug_object.concerns_just_documentation = True
+        bug_object.looks_closed = (metadata_dict['Status'] == 'resolved')
+
+    def generate_list_of_bug_ids_to_look_at(self):
+        # Bitesized bugs
+        for bug_id in csv_url2bugs(
+            'http://mercurial.selenic.com/bts/issue?@action=export_csv&@columns=title,id,activity,status,assignedto&@sort=activity&@group=priority&@filter=topic&@pagesize=500&@startwith=0&topic=61'):
+            yield bug_id
+            
+        # Documentation bugs
+        for bug_id in csv_url2bugs(
+                'http://mercurial.selenic.com/bts/issue?@action=export_csv&@columns=title,id,activity,status,assignedto&@sort=activity&@group=priority&@filter=topic&@pagesize=500&@startwith=0&topic=10'):
+            yield bug_id
+        
+class PythonTracker(RoundupTracker):
+    enabled = True
+
+    def __init__(self):
+        RoundupTracker.__init__(self,
+                                root_url='http://bugs.python.org/',
+                                project_name='Python')
+
+    def extract_bug_tracker_specific_data(self, metadata_dict, bug_object):
+        bug_object.good_for_newcomers = (
+            'easy' in metadata_dict['Keywords'])
+        bug_object.concerns_just_documentation = (
+            'Documentation' in metadata_dict['Components'])
+        bug_object.status = metadata_dict['Status']
+        bug_object.looks_closed = (
+            metadata_dict['Status'] == 'closed' or
+            'patch' in metadata_dict['Keywords'])
+        bug_object.importance = metadata_dict['Priority']
+
+    def generate_list_of_bug_ids_to_look_at(self):
+        ### bug queries to look at
+        queries = {
+            'Documentation bugs':
+                'http://bugs.python.org/issue?status=1%2C3&%40sort=activity&%40columns=id&%40startwith=0&%40group=priority&%40filter=status%2Ccomponents&components=4&%40action=export_csv',
+            'Easy bugs':
+                'http://bugs.python.org/issue?status=1%2C3&%40sort=activity&%40columns=id&%40startwith=0&%40group=priority&%40filter=status%2Ckeywords&keywords=6&%40action=export_csv',
+            }
+
+        for query_name in queries:
+            query_url = queries[query_name]
+            for bug_id in csv_url2bugs(query_url):
+                yield bug_id
diff --git a/mysite/customs/bugtrackers/roundup_general.py b/mysite/customs/bugtrackers/roundup_general.py
deleted file mode 100644
index f1888ca..0000000
--- a/mysite/customs/bugtrackers/roundup_general.py
+++ /dev/null
@@ -1,261 +0,0 @@
-import urllib2
-import urllib
-import re
-import lxml.html # scraper library
-import itertools
-import csv
-import datetime
-import logging
-import urlparse
-
-from django.db import models
-
-import mysite.search.models
-import mysite.customs.ohloh
-
-def csv_url2bugs(csv_url):
-    csv_fd = mysite.customs.ohloh.mechanize_get(
-        csv_url).response()
-    dict_reader = csv.DictReader(csv_fd)
-    for thing in dict_reader:
-        yield int(thing['id'])
-
-class RoundupTracker(object):
-    def __init__(self, root_url, project_name):
-        assert root_url[-1] == '/'
-        assert root_url[-2] != '/'
-        self.root_url = unicode(root_url)
-        self.project, _ = mysite.search.models.Project.objects.get_or_create(name=project_name)
-
-    @staticmethod
-    def roundup_tree2metadata_dict(tree):
-        '''
-        Input: tree is a parsed HTML document that lxml.html can understand.
-
-        Output: For each <th>key</th><td>value</td> in the tree,
-        append {'key': 'value'} to a dictionary.
-        Return the dictionary when done.'''
-
-        ret = {}
-        for th in tree.cssselect('th'):
-            # Get next sibling
-            key_with_colon = th.text_content().strip()
-            key = key_with_colon.rsplit(':', 1)[0]
-            try:
-                td = th.itersiblings().next()
-            except StopIteration:
-                # If there isn't an adjacent TD, don't use this TH.
-                continue
-            value = td.text_content().strip()
-            ret[key] = value
-
-        return ret
-
-    def str2datetime_obj(self, date_string, possibility_index=0):
-        # FIXME: I make guesses as to the timezone.
-        possible_date_strings = [
-                "%Y-%m-%d %H:%M",
-                "%Y-%m-%d %H:%M:%S",
-                "%Y-%m-%d.%H:%M",
-                "%Y-%m-%d.%H:%M:%S"]
-        try:
-            return datetime.datetime.strptime(date_string, possible_date_strings[possibility_index])
-        except ValueError:
-            # A keyerror raised here means we ran out of a possibilities.
-            return self.str2datetime_obj(date_string, possibility_index=possibility_index+1)
-
-    def get_remote_bug_ids_already_stored(self):
-        bugs = mysite.search.models.Bug.all_bugs.filter(
-                canonical_bug_link__contains=self.root_url)
-        bug_ids = [self.get_remote_bug_id(bug) for bug in bugs]
-        return bug_ids
-
-    def get_all_submitter_realname_pairs(self, tree):
-        '''Input: the tree
-        Output: A dictionary mapping username=>realname'''
-
-        ret = {}
-        for th in tree.cssselect('th'):
-            match = re.match("Author: ([^(]*) \(([^)]*)", th.text_content().strip())
-            if match:
-                realname, username = match.groups()
-                ret[username] = realname
-        return ret
-
-    def get_submitter_realname(self, tree, submitter_username):
-        try:
-            return self.get_all_submitter_realname_pairs(tree)[submitter_username]
-        except KeyError:
-            return None
-
-    def remote_bug_id2url(self, remote_bug_id):
-        return urlparse.urljoin(self.root_url, "issue%d" % remote_bug_id)
-
-    def get_remote_bug_id(self, bug):
-        plus_slash_issue = urlparse.urljoin(self.root_url, 'issue')
-        return int(bug.canonical_bug_link.split(plus_slash_issue)[1])
-
-    def create_bug_object_for_remote_bug_id_if_necessary(self, remote_bug_id):
-        """See if we have either no bug or only a stale one. If so,
-        refresh."""
-        logging.info(
-            "Was asked to look at bug %d in %s" % (remote_bug_id, self.project.name))
-        try:
-            bug = mysite.search.models.Bug.all_bugs.get(
-                canonical_bug_link=self.remote_bug_id2url(remote_bug_id))
-            if bug.data_is_more_fresh_than_one_day():
-                return False
-        except mysite.search.models.Bug.DoesNotExist:
-            bug = mysite.search.models.Bug()
-            bug.canonical_bug_link = self.remote_bug_id2url(remote_bug_id)
-
-        # otherwise, fill the bug object with fresh data
-        bug = self._update_bug_object_for_remote_bug_id(
-            bug_object=bug,
-            remote_bug_id=remote_bug_id)
-        bug.save()
-        logging.info(
-            "Actually loaded %d in from %s" % (
-                remote_bug_id, self.project.name))
-        return True
-
-    def _update_bug_object_for_remote_bug_id(self, bug_object, remote_bug_id):
-        """Create but don't save a bug."""
-        remote_bug_url = self.remote_bug_id2url(remote_bug_id)
-        tree = lxml.html.document_fromstring(urllib2.urlopen(remote_bug_url).read())
-
-        metadata_dict = RoundupTracker.roundup_tree2metadata_dict(tree)
-
-        date_reported, bug_object.submitter_username, last_touched, last_toucher = [
-                x.text_content() for x in tree.cssselect(
-                    'form[name=itemSynopsis] + p > b, form[name=itemSynopsis] + hr + p > b')]
-        bug_object.submitter_realname = self.get_submitter_realname(tree, bug_object.submitter_username)
-        bug_object.date_reported = self.str2datetime_obj(date_reported)
-        bug_object.last_touched = self.str2datetime_obj(last_touched)
-        bug_object.canonical_bug_link = remote_bug_url
-
-        bug_object.status = metadata_dict['Status'] 
-        bug_object.looks_closed = (metadata_dict['Status'] == 'closed')
-        bug_object.title = metadata_dict['Title'] 
-        bug_object.importance = metadata_dict['Priority']
-
-        # For description, just grab the first "message"
-        try:
-            bug_object.description = tree.cssselect('table.messages td.content')[0].text_content().strip()
-        except IndexError:
-            # This Roundup issue has no messages.
-            bug_object.description = ""
-
-        bug_object.project = self.project
-
-        # How many people participated?
-        bug_object.people_involved = len(self.get_all_submitter_realname_pairs(tree))
-
-        bug_object.last_polled = datetime.datetime.utcnow()
-
-        self.extract_bug_tracker_specific_data(metadata_dict=metadata_dict,
-                                               bug_object=bug_object)
-
-        return bug_object
-
-    def extract_bug_tracker_specific_data(self, metadata_dict, bug_object):
-        raise RuntimeError(NotImplemented)
-
-    def grab(self):
-        """Loops over the Python bug tracker's easy bugs and stores/updates them in our DB.
-        For now, just grab the easy bugs to be kind to their servers."""
-
-        bug_ids = itertools.chain(self.get_remote_bug_ids_to_read(),
-                                  self.get_remote_bug_ids_already_stored())
-
-        for bug_id in bug_ids:
-            print bug_id
-            bug = self.create_bug_object_for_remote_bug_id(bug_id)
-
-            # If there is already a bug with this canonical_bug_link in the DB, just delete it.
-            bugs_this_one_replaces = mysite.search.models.Bug.all_bugs.filter(canonical_bug_link=
-                                                        bug.canonical_bug_link)
-            for delete_me in bugs_this_one_replaces:
-                delete_me.delete()
-
-            print bug
-            # With the coast clear, we save the bug we just extracted from the Miro tracker.
-            bug.save()
-
-    def update(self):
-        '''Call this nightly.'''
-        logging.info("Learning about new bugs in %s" % self.project.name)
-
-        # First, find an examine any new bugs.
-        for bug_id in self.generate_list_of_bug_ids_to_look_at():
-            self.create_bug_object_for_remote_bug_id_if_necessary(bug_id)
-        # Second, make sure old bugs in the database aren't too stale.
-        logging.info("Starting refreshing all bugs from %s." % self.project.name)
-        count = 0
-        for bug_id in self.get_remote_bug_ids_already_stored():
-            self.create_bug_object_for_remote_bug_id_if_necessary(remote_bug_id=bug_id)
-            count += 1
-        logging.info("Okay, looked at %d bugs from %s." % (
-                count, self.project.name))
-
-    def __unicode__(self):
-        return "<Roundup bug tracker for %s>" % self.root_url
-
-class MercurialTracker(RoundupTracker):
-    enabled = True
-
-    def __init__(self):
-        RoundupTracker.__init__(self,
-                                root_url='http://mercurial.selenic.com/bts/',
-                                project_name='Mercurial')
-
-    def extract_bug_tracker_specific_data(self, metadata_dict, bug_object):
-        if 'bitesized' in metadata_dict['Topics']:
-            bug_object.good_for_newcomers = True
-        if 'documentation' in metadata_dict['Topics']:
-            bug_object.concerns_just_documentation = True
-        bug_object.looks_closed = (metadata_dict['Status'] == 'resolved')
-
-    def generate_list_of_bug_ids_to_look_at(self):
-        # Bitesized bugs
-        for bug_id in csv_url2bugs(
-            'http://mercurial.selenic.com/bts/issue?@action=export_csv&@columns=title,id,activity,status,assignedto&@sort=activity&@group=priority&@filter=topic&@pagesize=500&@startwith=0&topic=61'):
-            yield bug_id
-            
-        # Documentation bugs
-        for bug_id in csv_url2bugs(
-                'http://mercurial.selenic.com/bts/issue?@action=export_csv&@columns=title,id,activity,status,assignedto&@sort=activity&@group=priority&@filter=topic&@pagesize=500&@startwith=0&topic=10'):
-            yield bug_id
-        
-class PythonTracker(RoundupTracker):
-    enabled = True
-
-    def __init__(self):
-        RoundupTracker.__init__(self,
-                                root_url='http://bugs.python.org/',
-                                project_name='Python')
-
-    def extract_bug_tracker_specific_data(self, metadata_dict, bug_object):
-        bug_object.good_for_newcomers = (
-            'easy' in metadata_dict['Keywords'])
-        bug_object.concerns_just_documentation = (
-            'Documentation' in metadata_dict['Components'])
-        bug_object.status = metadata_dict['Status']
-        bug_object.looks_closed = (
-            metadata_dict['Status'] == 'closed' or
-            'patch' in metadata_dict['Keywords'])
-        bug_object.importance = metadata_dict['Priority']
-
-    def generate_list_of_bug_ids_to_look_at(self):
-        ### bug queries to look at
-        queries = {
-            'Documentation bugs':
-                'http://bugs.python.org/issue?status=1%2C3&%40sort=activity&%40columns=id&%40startwith=0&%40group=priority&%40filter=status%2Ccomponents&components=4&%40action=export_csv',
-            'Easy bugs':
-                'http://bugs.python.org/issue?status=1%2C3&%40sort=activity&%40columns=id&%40startwith=0&%40group=priority&%40filter=status%2Ckeywords&keywords=6&%40action=export_csv',
-            }
-
-        for query_name in queries:
-            query_url = queries[query_name]
-            for bug_id in csv_url2bugs(query_url):
-                yield bug_id
diff --git a/mysite/customs/bugtrackers/trac.py b/mysite/customs/bugtrackers/trac.py
index cc497b2..3eb90fe 100644
--- a/mysite/customs/bugtrackers/trac.py
+++ b/mysite/customs/bugtrackers/trac.py
@@ -1,17 +1,22 @@
+import cgi
 import csv
 import datetime
+import logging
 import urlparse
-import cgi
 
 import dateutil.parser
 import lxml.html
 import lxml.html.clean
 
-import mysite.base.helpers
 from mysite.base.decorators import cached_property
+import mysite.base.helpers
 import mysite.customs.ohloh
+import mysite.search.models
 import mysite.search.templatetags.search
 
+############################################################
+# Functions and classes for interacting with the tracker
+
 def csv_of_bugs(url):
     b = mysite.customs.ohloh.mechanize_get(url)
     return b.response()
@@ -176,3 +181,550 @@ class TracBug:
 
         ret = extract_tracker_specific_data(trac_data, ret)
         return ret
+
+############################################################
+# General bug importing class
+
+class TracBugTracker(object):
+    def __init__(self, base_url, project_name, bug_project_name_format):
+        self.base_url = base_url
+        self.project_name = project_name
+        self.bug_project_name_format = bug_project_name_format
+
+    def generate_bug_ids_from_queries(self, queries):
+        for query_name in queries:
+            query_url = queries[query_name]
+            query_ids = mysite.customs.bugtrackers.trac.csv_url2list_of_bug_ids(
+                mysite.customs.bugtrackers.trac.csv_of_bugs(query_url))
+            for bug_id in query_ids:
+                yield bug_id
+
+    def generate_bug_project_name(self, trac_bug):
+        return self.bug_project_name_format.format(project=self.project_name,
+                                                   component=trac_bug.component)
+
+    def update(self):
+        logging.info("Started refreshing all %s bugs." % self.project_name)
+
+        # First, go through and refresh all the bugs specifically marked
+        # as bugs to look at.
+
+        for bug_id in self.generate_list_of_bug_ids_to_look_at():
+            self.refresh_one_bug_id(bug_id)
+
+        # Then, refresh them all
+        self.refresh_all_bugs()
+
+    def refresh_all_bugs(self):
+        for bug in mysite.search.models.Bug.all_bugs.filter(
+            canonical_bug_link__contains=self.base_url):
+            tb = mysite.customs.bugtrackers.trac.TracBug.from_url(
+                bug.canonical_bug_link)
+            self.refresh_one_bug_id(tb.bug_id)
+
+    def refresh_one_bug_id(self, bug_id):
+        tb = mysite.customs.bugtrackers.trac.TracBug(
+            bug_id=bug_id,
+            BASE_URL=self.base_url)
+        bug_url = tb.as_bug_specific_url()
+    
+        try:
+            bug = mysite.search.models.Bug.all_bugs.get(
+                canonical_bug_link=bug_url)
+        except mysite.search.models.Bug.DoesNotExist:
+            bug = mysite.search.models.Bug(canonical_bug_link = bug_url)
+
+        # Hopefully, the bug is so fresh it needs no refreshing.
+        if bug.data_is_more_fresh_than_one_day():
+            logging.info("Bug %d from %s is fresh. Doing nothing!" % (bug_id, self.project_name))
+            return # sweet
+
+        # Okay, fine, we need to actually refresh it.
+        logging.info("Refreshing bug %d from %s." %
+                     (bug_id, self.project_name))
+        data = tb.as_data_dict_for_bug_object(self.extract_tracker_specific_data)
+
+        for key in data:
+            value = data[key]
+            setattr(bug, key, value)
+
+        # And save the project onto it
+        # Project name is taken from either overall project name or individual component name
+        # based on the value of the boolean set in the __init__ method.
+        project_from_name, _ = mysite.search.models.Project.objects.get_or_create(name=self.generate_bug_project_name(tb))
+        if bug.project_id != project_from_name.id:
+            bug.project = project_from_name
+        bug.last_polled = datetime.datetime.utcnow()
+        bug.save()
+        logging.info("Finished with %d from %s." % (bug_id, self.project_name))
+ 
+############################################################
+# Specific sub-classes for individual bug trackers
+
+class TahoeLafsTrac(TracBugTracker):
+    enabled = True
+
+    def __init__(self):
+        TracBugTracker.__init__(self,
+                                project_name='Tahoe-LAFS',
+                                base_url='http://tahoe-lafs.org/trac/tahoe-lafs/',
+                                bug_project_name_format='{project}')
+
+    def generate_list_of_bug_ids_to_look_at(self):
+        queries = {
+                'All bugs':
+                    'http://tahoe-lafs.org/trac/tahoe-lafs/query?status=assigned&status=new&status=reopened&max=10000&reporter=~&col=id&col=summary&col=keywords&col=reporter&col=status&col=owner&col=type&col=priority&col=milestone&keywords=~&owner=~&desc=1&order=id&format=csv',
+                }
+        return self.generate_bug_ids_from_queries(queries)
+
+    @staticmethod
+    def extract_tracker_specific_data(trac_data, ret_dict):
+        # Make modifications to ret_dict using provided metadata
+        # Check for the bitesized keyword
+        ret_dict['bite_size_tag_name'] = 'easy'
+        ret_dict['good_for_newcomers'] = ('easy' in trac_data['keywords'])
+        # Check whether this is a documentation bug.
+        ret_dict['concerns_just_documentation'] = ('docs' in trac_data['keywords'])
+        # Then pass ret_dict back
+        return ret_dict
+
+class TwistedTrac(TracBugTracker):
+    enabled = True
+
+    def __init__(self):
+        TracBugTracker.__init__(self,
+                                project_name='Twisted',
+                                base_url='http://twistedmatrix.com/trac/',
+                                bug_project_name_format='{project}')
+
+    def generate_list_of_bug_ids_to_look_at(self):
+        queries = {
+                'Easy bugs':
+                    'http://twistedmatrix.com/trac/query?status=new&status=assigned&status=reopened&format=csv&keywords=%7Eeasy&order=priority',
+                'Documentation bugs':
+                    'http://twistedmatrix.com/trac/query?status=assigned&status=new&status=reopened&format=csv&order=priority&keywords=~documentation'
+                }
+        return self.generate_bug_ids_from_queries(queries)
+
+    @staticmethod
+    def extract_tracker_specific_data(trac_data, ret_dict):
+        # Make modifications to ret_dict using provided metadata
+        # Check for the bitesized keyword
+        ret_dict['bite_size_tag_name'] = 'easy'
+        ret_dict['good_for_newcomers'] = ('easy' in trac_data['keywords'])
+        # Check whether this is a documentation bug.
+        ret_dict['concerns_just_documentation'] = ('documentation' in trac_data['keywords'])
+        # Then pass ret_dict back
+        return ret_dict
+
+class SugarLabsTrac(TracBugTracker):
+    enabled = True
+
+    def __init__(self):
+        TracBugTracker.__init__(self,
+                                project_name='Sugar Labs',
+                                base_url='http://bugs.sugarlabs.org/',
+                                bug_project_name_format='{component}')
+
+    def generate_list_of_bug_ids_to_look_at(self):
+        queries = {
+                'Easy bugs':
+                    'http://bugs.sugarlabs.org/query?status=accepted&status=new&status=assigned&status=reopened&format=csv&keywords=%7Esugar-love&order=priority',
+                'Documentation bugs':
+                    'http://bugs.sugarlabs.org/query?status=accepted&status=assigned&status=new&status=reopened&format=csv&order=priority&keywords=~documentation'
+                }
+        return self.generate_bug_ids_from_queries(queries)
+
+    @staticmethod
+    def extract_tracker_specific_data(trac_data, ret_dict):
+        # Make modifications to ret_dict using provided metadata
+        # Check for the bitesized keyword
+        ret_dict['bite_size_tag_name'] = 'sugar-love'
+        ret_dict['good_for_newcomers'] = ('sugar-love' in trac_data['keywords'])
+        # Check whether this is a documentation bug.
+        ret_dict['concerns_just_documentation'] = ('documentation' in trac_data['keywords'])
+        # Then pass ret_dict back
+        return ret_dict
+
+class StatusNetTrac(TracBugTracker):
+    enabled = False # No longer Bugzilla?
+
+    def __init__(self):
+        TracBugTracker.__init__(self,
+                                project_name='StatusNet',
+                                base_url='http://status.net/trac/',
+                                bug_project_name_format='{project}')
+
+    def generate_list_of_bug_ids_to_look_at(self):
+        # Only gives a list of bitesized bugs - confirm if devels want all bugs indexed
+        return mysite.customs.bugtrackers.trac.csv_url2list_of_bug_ids(
+            mysite.customs.bugtrackers.trac.csv_of_bugs(
+                'http://status.net/trac/query?status=accepted&status=assigned&status=new&status=reopened&format=csv&order=priority&keywords=%7Eeasy'))
+
+class XiphTrac(TracBugTracker):
+    enabled = True
+
+    def __init__(self):
+        TracBugTracker.__init__(self,
+                                project_name='Xiph',
+                                base_url='http://trac.xiph.org/',
+                                bug_project_name_format='{project}')
+
+    def generate_list_of_bug_ids_to_look_at(self):
+        queries = {
+                'Easy bugs': # Only gives a list of bitesized bugs - confirm if devels want all bugs indexed
+                    'https://trac.xiph.org/query?status=assigned&status=new&status=reopened&order=priority&format=csv&keywords=%7Eeasy',
+                #'Documentation bugs':
+                    #''
+                }
+        return self.generate_bug_ids_from_queries(queries)
+
+    @staticmethod
+    def extract_tracker_specific_data(trac_data, ret_dict):
+        # Make modifications to ret_dict using provided metadata
+        # Check for the bitesized keyword
+        ret_dict['bite_size_tag_name'] = 'easy' # Unconfirmed, there were no such bugs at the time
+        ret_dict['good_for_newcomers'] = ('easy' in trac_data['keywords'])
+        # Check whether this is a documentation bug.
+        #ret_dict['concerns_just_documentation'] = ('docs' in trac_data['keywords'])
+        # Then pass ret_dict back
+        return ret_dict
+
+class OLPCTrac(TracBugTracker):
+    enabled = False # Need to sort out naming for bug projects
+
+    def __init__(self):
+        TracBugTracker.__init__(self,
+                                project_name='OLPC',
+                                base_url='http://dev.laptop.org/',
+                                bug_project_name_format='{project}')
+
+    def generate_list_of_bug_ids_to_look_at(self):
+        queries = {
+                'All bugs':
+                    'http://dev.laptop.org/query?status=assigned&status=new&status=reopened&order=priority&format=csv',
+                }
+        return self.generate_bug_ids_from_queries(queries)
+
+    @staticmethod
+    def extract_tracker_specific_data(trac_data, ret_dict):
+        # Make modifications to ret_dict using provided metadata
+        # Check for the bitesized keyword
+        ret_dict['bite_size_tag_name'] = 'easy'
+        ret_dict['good_for_newcomers'] = ('easy' in trac_data['keywords']) or ('sugar-love' in trac_data['keywords'])
+        # Check whether this is a documentation bug.
+        ret_dict['concerns_just_documentation'] = ('doc' in trac_data['keywords'])
+        # Then pass ret_dict back
+        return ret_dict
+
+class DjangoTrac(TracBugTracker):
+    enabled = False # Opened' and 'Last modified' fields aren't hyperlinked
+
+    def __init__(self):
+        TracBugTracker.__init__(self,
+                                project_name='Django',
+                                base_url='http://code.djangoproject.com/',
+                                bug_project_name_format='{project}')
+
+    def generate_list_of_bug_ids_to_look_at(self):
+        queries = {
+                'All bugs':
+                    'http://code.djangoproject.com/query?status=new&status=assigned&status=reopened&order=priority&format=csv',
+                }
+        return self.generate_bug_ids_from_queries(queries)
+
+    @staticmethod
+    def extract_tracker_specific_data(trac_data, ret_dict):
+        # Make modifications to ret_dict using provided metadata
+        # Check for the bitesized keyword
+        ret_dict['bite_size_tag_name'] = 'easy'
+        ret_dict['good_for_newcomers'] = ('easy' in trac_data['keywords'])
+        # Check whether this is a documentation bug.
+        # FIXME: No standard. Check which to use, or just look for  all?
+        #ret_dict['concerns_just_documentation'] = ('doc' in trac_data['keywords'])
+        # Then pass ret_dict back
+        return ret_dict
+
+class HelenOSTrac(TracBugTracker):
+    enabled = True
+
+    def __init__(self):
+        TracBugTracker.__init__(self,
+                                project_name='HelenOS',
+                                base_url='http://trac.helenos.org/trac.fcgi/',
+                                bug_project_name_format='{project}')
+
+    def generate_list_of_bug_ids_to_look_at(self):
+        queries = {
+                'All bugs':
+                    'http://trac.helenos.org/trac.fcgi/query?status=accepted&status=assigned&status=new&status=reopened&order=priority&format=csv',
+                }
+        return self.generate_bug_ids_from_queries(queries)
+
+    @staticmethod
+    def extract_tracker_specific_data(trac_data, ret_dict):
+        # Make modifications to ret_dict using provided metadata
+        # Check for the bitesized keyword
+        ret_dict['bite_size_tag_name'] = 'easy' # Unconfirmed, there were no such bugs at the time
+        ret_dict['good_for_newcomers'] = ('easy' in trac_data['keywords'])
+        # Check whether this is a documentation bug. FIXME: Need better example - doc keyword or component?
+        #ret_dict['concerns_just_documentation'] = ('doc' in trac_data['keywords'])
+        # Then pass ret_dict back
+        return ret_dict
+
+class Bcfg2Trac(TracBugTracker):
+    enabled = True
+
+    def __init__(self):
+        TracBugTracker.__init__(self,
+                                project_name='Bcfg2',
+                                base_url='https://trac.mcs.anl.gov/projects/bcfg2/',
+                                bug_project_name_format='{project}')
+
+    def generate_list_of_bug_ids_to_look_at(self):
+        queries = {
+                'All bugs':
+                    'https://trac.mcs.anl.gov/projects/bcfg2/query?status=accepted&status=assigned&status=new&status=reopened&order=priority&format=csv',
+                }
+        return self.generate_bug_ids_from_queries(queries)
+
+    @staticmethod
+    def extract_tracker_specific_data(trac_data, ret_dict):
+        # Make modifications to ret_dict using provided metadata
+        # Check for the bitesized keyword
+        ret_dict['bite_size_tag_name'] = 'easy' # Unconfirmed, there were no such bugs at the time
+        ret_dict['good_for_newcomers'] = ('easy' in trac_data['keywords'])
+        # Check whether this is a documentation bug.
+        ret_dict['concerns_just_documentation'] = ('bcfg2-doc' in trac_data['component'])
+        # Then pass ret_dict back
+        return ret_dict
+
+class WarFoundryTrac(TracBugTracker):
+    enabled = True
+
+    def __init__(self):
+        TracBugTracker.__init__(self,
+                                project_name='WarFoundry',
+                                base_url='http://dev.ibboard.co.uk/projects/warfoundry/',
+                                bug_project_name_format='{project}')
+
+    def generate_list_of_bug_ids_to_look_at(self):
+        queries = {
+                'All bugs':
+                    'http://dev.ibboard.co.uk/projects/warfoundry/query?status=accepted&status=assigned&status=confirmed&status=needinfo&status=needinfo_new&status=new&status=reopened&order=priority&format=csv',
+                }
+        return self.generate_bug_ids_from_queries(queries)
+
+    @staticmethod
+    def extract_tracker_specific_data(trac_data, ret_dict):
+        # Make modifications to ret_dict using provided metadata
+        # Check for the bitesized keyword
+        ret_dict['bite_size_tag_name'] = 'papercut'
+        ret_dict['good_for_newcomers'] = ('papercut' in trac_data['keywords'])
+        # Check whether this is a documentation bug.
+        #ret_dict['concerns_just_documentation'] = ('docs' in trac_data['keywords'])
+        # Then pass ret_dict back
+        return ret_dict
+
+class FedoraPythonModulesTrac(TracBugTracker):
+    enabled = False # 'Opened' and 'Last modified' bug fields aren't hyperlinked
+
+    def __init__(self):
+        TracBugTracker.__init__(self,
+                                project_name='Fedora Python Modules',
+                                base_url='https://fedorahosted.org/python-fedora/',
+                                bug_project_name_format='{project}')
+
+    def generate_list_of_bug_ids_to_look_at(self):
+        queries = {
+                'All bugs':
+                    'https://fedorahosted.org/python-fedora/query?status=new&status=assigned&status=reopened&order=priority&format=csv',
+                }
+        return self.generate_bug_ids_from_queries(queries)
+
+    @staticmethod
+    def extract_tracker_specific_data(trac_data, ret_dict):
+        # Make modifications to ret_dict using provided metadata
+        # Check for the bitesized keyword
+        #ret_dict['bite_size_tag_name'] = 'easy'
+        #ret_dict['good_for_newcomers'] = ('easy' in trac_data['keywords'])
+        # Check whether this is a documentation bug.
+        #ret_dict['concerns_just_documentation'] = ('doc' in trac_data['keywords'])
+        # Then pass ret_dict back
+        return ret_dict
+
+class AngbandTrac(TracBugTracker):
+    enabled = True
+
+    def __init__(self):
+        TracBugTracker.__init__(self,
+                                project_name='Angband',
+                                base_url='http://trac.rephial.org/',
+                                bug_project_name_format='{project}')
+
+    def generate_list_of_bug_ids_to_look_at(self):
+        queries = {
+                'All bugs':
+                    'http://trac.rephial.org/query?status=assigned&status=confirmed&status=new&status=reopened&order=priority&format=csv',
+                }
+        return self.generate_bug_ids_from_queries(queries)
+
+    @staticmethod
+    def extract_tracker_specific_data(trac_data, ret_dict):
+        # Make modifications to ret_dict using provided metadata
+        # Check for the bitesized keyword
+        ret_dict['bite_size_tag_name'] = 'easy' # Unconfirmed, there were no such bugs at the time
+        ret_dict['good_for_newcomers'] = ('easy' in trac_data['keywords'])
+        # Check whether this is a documentation bug.
+        ret_dict['concerns_just_documentation'] = ('doc' in trac_data['keywords'])
+        # Then pass ret_dict back
+        return ret_dict
+
+class GHCTrac(TracBugTracker):
+    enabled = True
+
+    def __init__(self):
+        TracBugTracker.__init__(self,
+                                project_name='GHC',
+                                base_url='http://hackage.haskell.org/trac/ghc/',
+                                bug_project_name_format='{project}')
+
+    def generate_list_of_bug_ids_to_look_at(self):
+        queries = {
+                'All bugs':
+                    'http://hackage.haskell.org/trac/ghc/query?status=new&status=assigned&status=reopened&group=priority&order=id&desc=1&format=csv',
+                }
+        return self.generate_bug_ids_from_queries(queries)
+
+    @staticmethod
+    def extract_tracker_specific_data(trac_data, ret_dict):
+        # Make modifications to ret_dict using provided metadata
+        # Check for the bitesized keyword
+        ret_dict['bite_size_tag_name'] = 'Easy (less than 1 hour)'
+        ret_dict['good_for_newcomers'] = ('Easy (less than 1 hour)' in trac_data['difficulty'])
+        # Check whether this is a documentation bug.
+        ret_dict['concerns_just_documentation'] = ('Documentation' in trac_data['component'])
+        # Then pass ret_dict back
+        return ret_dict
+
+class TracTrac(TracBugTracker):
+    enabled = True
+
+    def __init__(self):
+        TracBugTracker.__init__(self,
+                                project_name='Trac',
+                                base_url='http://trac.edgewall.org/',
+                                bug_project_name_format='{project}')
+
+    def generate_list_of_bug_ids_to_look_at(self):
+        queries = {
+                'Easy bugs':
+                    'http://trac.edgewall.org/query?status=!closed&keywords=~bitesized&format=csv',
+                #'Documentation bugs':
+                    #''
+                }
+        return self.generate_bug_ids_from_queries(queries)
+
+    @staticmethod
+    def extract_tracker_specific_data(trac_data, ret_dict):
+        # Make modifications to ret_dict using provided metadata
+        # Check for the bitesized keyword
+        ret_dict['bite_size_tag_name'] = 'bitesized'
+        ret_dict['good_for_newcomers'] = ('bitesized' in trac_data['keywords'])
+        # Check whether this is a documentation bug.
+        #ret_dict['concerns_just_documentation'] = ('doc' in trac_data['keywords'])
+        # Then pass ret_dict back
+        return ret_dict
+
+class SSSDTrac(TracBugTracker):
+    enabled = False # 'Opened' and 'Last modified' fields aren't hyperlinked
+
+    def __init__(self):
+        TracBugTracker.__init__(self,
+                                project_name='SSSD',
+                                base_url='https://fedorahosted.org/sssd/',
+                                bug_project_name_format='{project}')
+
+    def generate_list_of_bug_ids_to_look_at(self):
+        queries = {
+                'All bugs':
+                    'https://fedorahosted.org/sssd/query?status=new&status=assigned&status=reopened&order=priority&format=csv',
+                }
+        return self.generate_bug_ids_from_queries(queries)
+
+    @staticmethod
+    def extract_tracker_specific_data(trac_data, ret_dict):
+        # Make modifications to ret_dict using provided metadata
+        # Check for the bitesized keyword
+        ret_dict['bite_size_tag_name'] = 'trivial'
+        ret_dict['good_for_newcomers'] = ('trivial' in trac_data['priority'])
+        # Check whether this is a documentation bug.
+        #ret_dict['concerns_just_documentation'] = ('doc' in trac_data['keywords'])
+        # Then pass ret_dict back
+        return ret_dict
+
+class I2PTrac(TracBugTracker):
+    enabled = True
+
+    def __init__(self):
+        TracBugTracker.__init__(self,
+                                project_name='I2P',
+                                base_url='http://trac.i2p2.de/',
+                                bug_project_name_format='{project}')
+
+    def generate_list_of_bug_ids_to_look_at(self):
+        queries = {
+                'All bugs':
+                    'http://trac.i2p2.de/query?status=accepted&status=assigned&status=new&status=reopened&order=priority&format=csv',
+                }
+        return self.generate_bug_ids_from_queries(queries)
+
+    @staticmethod
+    def extract_tracker_specific_data(trac_data, ret_dict):
+        # Make modifications to ret_dict using provided metadata
+        # Check for the bitesized keyword
+        ret_dict['bite_size_tag_name'] = 'easy'
+        ret_dict['good_for_newcomers'] = ('easy' in trac_data['keywords'])
+        # Check whether this is a documentation bug.
+        #ret_dict['concerns_just_documentation'] = ('doc' in trac_data['keywords'])
+        # Then pass ret_dict back
+        return ret_dict
+
+# Copy this generic class to add a new Trac bugtracker
+# Remember to set 'enabled' to True
+# Notes:
+# Base URL: the URL of a bug for the bugtracker, without the 'ticket/1234'
+# Tracking URL: go to BASE_URL/query and search for the bugs you want tracked
+# bug_project_name_format: the format to be used for the bug's project name
+# "{project}" will be replaced by project_name, and "{component}" by the
+# component the bug is part of (as taken from the bug's ticket).
+class GenTrac(TracBugTracker):
+    enabled = False
+
+    def __init__(self):
+        TracBugTracker.__init__(self,
+                                project_name='',
+                                base_url='',
+                                bug_project_name_format='')
+
+    def generate_list_of_bug_ids_to_look_at(self):
+        # Can replace both entries below with an 'All bugs' query.
+        queries = {
+                'Easy bugs':
+                    '',
+                'Documentation bugs':
+                    ''
+                }
+        return self.generate_bug_ids_from_queries(queries)
+
+    @staticmethod
+    def extract_tracker_specific_data(trac_data, ret_dict):
+        # Make modifications to ret_dict using provided metadata
+        # Check for the bitesized keyword
+        ret_dict['bite_size_tag_name'] = ''
+        ret_dict['good_for_newcomers'] = ('' in trac_data['keywords'])
+        # Check whether this is a documentation bug.
+        ret_dict['concerns_just_documentation'] = ('' in trac_data['keywords'])
+        # Then pass ret_dict back
+        return ret_dict
+
diff --git a/mysite/customs/management/commands/customs_daily_tasks.py b/mysite/customs/management/commands/customs_daily_tasks.py
new file mode 100644
index 0000000..1f59145
--- /dev/null
+++ b/mysite/customs/management/commands/customs_daily_tasks.py
@@ -0,0 +1,115 @@
+import logging
+import urllib2
+
+from django.core.management.base import BaseCommand
+
+import django.conf
+django.conf.settings.CELERY_ALWAYS_EAGER = True
+
+import mysite.customs.bugtrackers.bugzilla
+import mysite.customs.bugtrackers.launchpad
+import mysite.customs.bugtrackers.opensolaris
+import mysite.customs.bugtrackers.roundup
+import mysite.customs.bugtrackers.trac
+
+### All this code runs synchronously once a day.
+### For now, we can crawl all the bug trackers in serial.
+
+### One day, though, we will crawl so many bug trackers that it will take
+### too long.
+
+### I suggest that, at that point, we fork a number of worker processes, and
+### turn these lists into a queue or something. That should be easy with the
+### multiprocessing module. Then we can do N at once.
+
+### We could do something smart with statistics, detecting the average
+### refresh time within the bug tracker of a bug, then polling at some
+### approximation of that rate. (But, really, why bother?)
+
+### Since most of the time we're waiting on the network, we could also use
+### Twisted or Stackless Python or something. That would be super cool, too.
+### If somone can show me how to migrate this codebase to it, that'd be neat.
+### I'm unlikely to look into it myself, though.
+
+### (If at some point we start indexing absolutely every bug in free and open
+### source software, then the above ideas will actually become meaningful.)
+
+### -- New Age Asheesh, 2010-05-31.
+
+class Command(BaseCommand):
+    help = "Call this once a day to make sure we run Bug search-related nightly jobs."
+
+    def find_and_update_enabled_roundup_trackers(self):
+        enabled_roundup_trackers = []
+
+        ### First, the "find" step
+        for thing_name in dir(mysite.customs.bugtrackers.roundup):
+            thing = getattr(mysite.customs.bugtrackers.roundup,
+                            thing_name)
+            if hasattr(thing, 'enabled'):
+                if getattr(thing, 'enabled'):
+                    enabled_roundup_trackers.append(thing)
+
+        ### Okay, now update!
+        for thing in enabled_roundup_trackers:
+            logging.info("[Roundup] About to update %s" % thing)
+            instantiated = thing()
+            instantiated.update()
+
+    def find_and_update_enabled_trac_instances(self):
+        enabled_trac_instances = []
+
+        ### First, the "find" step
+        for thing_name in dir(mysite.customs.bugtrackers.trac):
+            thing = getattr(mysite.customs.bugtrackers.trac,
+                            thing_name)
+            if hasattr(thing, 'enabled'):
+                if getattr(thing, 'enabled'):
+                    enabled_trac_instances.append(thing)
+
+        ### Okay, now update!
+        for thing in enabled_trac_instances:
+            logging.info("[Trac] About to update %s" % thing)
+            instantiated = thing()
+            instantiated.update()
+
+    def find_and_update_enabled_bugzilla_instances(self):
+        enabled_bugzilla_instances = []
+
+        ### First, the "find" step
+        for thing_name in dir(mysite.customs.bugtrackers.bugzilla):
+            thing = getattr(mysite.customs.bugtrackers.bugzilla,
+                            thing_name)
+            if hasattr(thing, 'enabled'):
+                if getattr(thing, 'enabled'):
+                    enabled_bugzilla_instances.append(thing)
+
+        ### Okay, now update!
+        for thing in enabled_bugzilla_instances:
+            logging.info("[Bugzilla] About to update %s" % thing)
+            instantiated = thing()
+            # FIXME: The Bugzilla trackers seem to throw error 500 a lot.
+            # For now, chuck in a dirty big try except to stop importer
+            # breaking.
+            try:
+                instantiated.update()
+            except urllib2.URLError, e:
+                logging.error("[Bugzilla] ERROR: Importer failed, likely HTTP500, continuing on...")
+                logging.error("[Bugzilla] Error message: %s" % str(e))
+
+    def update_launchpad_hosted_projects(self):
+        ### For Launchpad:
+        # First, we ask the projects' bug trackers if there are new bugs we should know about
+        mysite.customs.bugtrackers.launchpad.refresh_bugs_from_all_indexed_launchpad_projects()
+        # Second, we go through our *own* database of Launchpad-sourced bugs, and make sure they are all up to date
+        mysite.customs.bugtrackers.launchpad.refresh_all_launchpad_bugs()
+
+    def update_opensolaris_osnet(self):
+        mysite.customs.bugtrackers.opensolaris.update()
+
+    def handle(self, *args, **options):
+        self.update_opensolaris_osnet()
+        self.update_launchpad_hosted_projects()
+        self.find_and_update_enabled_trac_instances()
+        self.find_and_update_enabled_roundup_trackers()
+        self.find_and_update_enabled_bugzilla_instances()
diff --git a/mysite/customs/tests.py b/mysite/customs/tests.py
index 33c48f0..f0192dd 100644
--- a/mysite/customs/tests.py
+++ b/mysite/customs/tests.py
@@ -12,6 +12,7 @@ import os
 import re
 import twill
 import lxml
+import time
 from twill import commands as tc
 from twill.shell import TwillCommandLoop
 
@@ -38,9 +39,9 @@ import mysite.customs.feed
 import mysite.customs.github
 
 import mysite.customs.models
-import mysite.customs.bugtrackers.roundup_general
+import mysite.customs.bugtrackers.roundup
 import mysite.customs.lp_grabber
-import mysite.search.management.commands.search_daily_tasks
+import mysite.customs.management.commands.customs_daily_tasks
 # }}}
 
 # Mocked out browser.open
@@ -287,7 +288,7 @@ class BugzillaTests(django.test.TestCase):
         p = Project.create_dummy(name='kmail')
         mock_xml_opener.return_value = lxml.etree.XML(open(os.path.join(
             settings.MEDIA_ROOT, 'sample-data', 'kde-117760-2010-04-09.xml')).read())
-        kde = mysite.search.tasks.bugzilla_instances.KDEBugzilla()
+        kde = mysite.customs.bugtrackers.bugzilla.KDEBugzilla()
         kde.update()
         all_bugs = Bug.all_bugs.all()
         self.assertEqual(len(all_bugs), 1)
@@ -300,7 +301,7 @@ class BugzillaTests(django.test.TestCase):
         p = Project.create_dummy(name='kphotoalbum')
         mock_xml_opener.return_value = lxml.etree.XML(open(os.path.join(
             settings.MEDIA_ROOT, 'sample-data', 'kde-182054-2010-04-09.xml')).read())
-        kde = mysite.search.tasks.bugzilla_instances.KDEBugzilla()
+        kde = mysite.customs.bugtrackers.bugzilla.KDEBugzilla()
         kde.update()
         all_bugs = Bug.all_bugs.all()
         self.assertEqual(len(all_bugs), 1)
@@ -314,7 +315,7 @@ class BugzillaTests(django.test.TestCase):
         mock_xml_opener.return_value = lxml.etree.XML(open(os.path.join(
             settings.MEDIA_ROOT, 'sample-data', 'miro-2294-2009-08-06.xml')).read())
 
-        miro = mysite.search.tasks.bugzilla_instances.MiroBugzilla()
+        miro = mysite.customs.bugtrackers.bugzilla.MiroBugzilla()
         miro.update()
         all_bugs = Bug.all_bugs.all()
         self.assertEqual(len(all_bugs), 1)
@@ -341,7 +342,7 @@ Keywords: Torrent unittest""")
         mock_xml_opener.return_value = lxml.etree.XML(open(os.path.join(
             settings.MEDIA_ROOT, 'sample-data', 'miro-2294-2009-08-06.xml')).read())
 
-        miro = mysite.search.tasks.bugzilla_instances.MiroBugzilla()
+        miro = mysite.customs.bugtrackers.bugzilla.MiroBugzilla()
         miro.update()
         all_bugs = Bug.all_bugs.all()
         self.assertEqual(len(all_bugs), 1)
@@ -362,7 +363,7 @@ Keywords: Torrent unittest""")
             'NEW', 'CLOSED')
         mock_xml_opener.return_value = lxml.etree.XML(cooked_xml)
 
-        miro = mysite.search.tasks.bugzilla_instances.MiroBugzilla()
+        miro = mysite.customs.bugtrackers.bugzilla.MiroBugzilla()
         miro.update()
         all_bugs = Bug.all_bugs.all()
         self.assertEqual(len(all_bugs), 1)
@@ -379,7 +380,7 @@ Keywords: Torrent unittest""")
         mock_xml_opener.return_value = lxml.etree.XML(open(os.path.join(
             settings.MEDIA_ROOT, 'sample-data', 'miro-2294-2009-08-06-RESOLVED.xml')).read())
 
-        miro = mysite.search.tasks.bugzilla_instances.MiroBugzilla()
+        miro = mysite.customs.bugtrackers.bugzilla.MiroBugzilla()
         miro.update()
         all_bugs = Bug.all_bugs.all()
         self.assertEqual(len(all_bugs), 1)
@@ -392,7 +393,7 @@ Keywords: Torrent unittest""")
     def test_full_grab_miro_bugs_refreshes_older_bugs(self, mock_xml_opener):
         mock_xml_opener.return_value = lxml.etree.XML(open(os.path.join(
             settings.MEDIA_ROOT, 'sample-data', 'miro-2294-2009-08-06.xml')).read())
-        miro = mysite.search.tasks.bugzilla_instances.MiroBugzilla()
+        miro = mysite.customs.bugtrackers.bugzilla.MiroBugzilla()
         miro.update()
 
         # Pretend there's old data lying around:
@@ -413,7 +414,7 @@ Keywords: Torrent unittest""")
 
 
     @mock.patch("mysite.customs.bugtrackers.bugzilla.url2bug_data")
-    @mock.patch("mysite.search.tasks.bugzilla_instances.MiroBugzilla.generate_current_bug_xml")
+    @mock.patch("mysite.customs.bugtrackers.bugzilla.MiroBugzilla.generate_current_bug_xml")
     def test_regrab_miro_bugs_refreshes_older_bugs_even_when_missing_from_csv(self, mock_xml_bug_tree, mock_xml_opener):
         mock_xml_opener.return_value = lxml.etree.XML(open(os.path.join(
             settings.MEDIA_ROOT, 'sample-data', 'miro-2294-2009-08-06.xml')).read())
@@ -437,7 +438,7 @@ Keywords: Torrent unittest""")
         # Now, do a crawl and notice that we updated the bug even
         # though the xml bug list is empty
         
-        miro = mysite.search.tasks.bugzilla_instances.MiroBugzilla()
+        miro = mysite.customs.bugtrackers.bugzilla.MiroBugzilla()
         miro.update()
         all_bugs = Bug.all_bugs.all()
         self.assertEqual(len(all_bugs), 1)
@@ -538,7 +539,7 @@ class MercurialRoundupGrab(django.test.TestCase):
 
         mock_urlopen.return_value=open(MercurialRoundupGrab.closed_bug_filename)
 
-        tracker = mysite.customs.bugtrackers.roundup_general.MercurialTracker()
+        tracker = mysite.customs.bugtrackers.roundup.MercurialTracker()
         did_create = tracker.create_bug_object_for_remote_bug_id_if_necessary(1)
         self.assertEqual(did_create, should_do_something)
 
@@ -1034,17 +1035,170 @@ class OpenSolaris(django.test.TestCase):
         bug_result = mysite.customs.bugtrackers.opensolaris.create_bug_object_for_remote_bug_id_if_necessary(1)
         self.assertEquals(bug_result, False)
 
+sample_launchpad_data_dump = mock.Mock()
+sample_launchpad_data_dump.return_value = [dict(
+        url=u'', project=u'rose.makesad.us', text=u'', status=u'',
+        importance=u'low', reporter={u'lplogin': 'a',
+                                    'realname': 'b'},
+        tags=[], comments=[], date_updated=time.localtime(),
+        date_reported=time.localtime(),
+        title="Joi's Lab AFS",)]
+
+class AutoCrawlTests(django.test.TestCase):
+    @mock.patch('mysite.customs.bugtrackers.launchpad.dump_data_from_project', 
+                sample_launchpad_data_dump)
+    @mock.patch('mysite.search.tasks.PopulateProjectLanguageFromOhloh')
+    def testSearch(self, do_nothing):
+        # Verify that we can't find a bug with the right description
+        self.assertRaises(mysite.search.models.Bug.DoesNotExist,
+                          mysite.search.models.Bug.all_bugs.get,
+                          title="Joi's Lab AFS")
+        # Now get all the bugs about rose
+        mysite.customs.bugtrackers.launchpad.grab_lp_bugs(lp_project='rose',
+                                            openhatch_project_name=
+                                            u'rose.makesad.us')
+        # Now see, we have one!
+        b = mysite.search.models.Bug.all_bugs.get(title="Joi's Lab AFS")
+        self.assertEqual(b.project.name, u'rose.makesad.us')
+        # Ta-da.
+        return b
+
+    def test_running_job_twice_does_update(self):
+        b = self.testSearch()
+        b.description = u'Eat more potato starch'
+        b.title = u'Yummy potato paste'
+        b.save()
+
+        new_b = self.testSearch()
+        self.assertEqual(new_b.title, "Joi's Lab AFS") # bug title restored
+        # thanks to fresh import
+
+class LaunchpadImporterTests(django.test.TestCase):
+
+    @mock.patch('mysite.search.tasks.PopulateProjectLanguageFromOhloh')
+    def test_lp_update_handler(self, do_nothing):
+        '''Test the Launchpad import handler with some fake data.'''
+        some_date = datetime.datetime(2009, 4, 1, 2, 2, 2)
+        query_data = dict(project='GNOME-Do',
+                          canonical_bug_link='http://example.com/1')
+        new_data = dict(title='Title', status='Godforsaken',
+                        description='Everything should be better',
+                        importance='High',
+                        people_involved=1000 * 1000,
+                        submitter_username='yourmom',
+                        submitter_realname='Your Mom',
+                        date_reported=some_date,
+                        last_touched=some_date,
+                        last_polled=some_date)
+
+        # Create the bug...
+        mysite.customs.bugtrackers.launchpad.handle_launchpad_bug_update(
+                project_name=query_data['project'],
+                canonical_bug_link=query_data['canonical_bug_link'], 
+                new_data=new_data)
+        # Verify that the bug was stored.
+        bug = Bug.all_bugs.get(canonical_bug_link=
+                                       query_data['canonical_bug_link'])
+        for key in new_data:
+            self.assertEqual(getattr(bug, key), new_data[key])
+
+        # Now re-do the update, this time with more people involved
+        new_data['people_involved'] = 1000 * 1000 * 1000
+        # pass the data in...
+        mysite.customs.bugtrackers.launchpad.handle_launchpad_bug_update(
+                project_name=query_data['project'],
+                canonical_bug_link=query_data['canonical_bug_link'], 
+                new_data=new_data)
+        # Do a get; this will explode if there's more than one with the
+        # canonical_bug_link, so it tests duplicate finding.
+        bug = Bug.all_bugs.get(canonical_bug_link=
+                                       query_data[u'canonical_bug_link'])
+
+        for key in new_data:
+            self.assertEqual(getattr(bug, key), new_data[key])
+
+    @mock.patch('mysite.search.tasks.PopulateProjectLanguageFromOhloh')
+    def test_lp_data_clean(self, do_nothing):
+        now_t = (2009, 4, 1, 5, 13, 2) # partial time tuple
+        now_d = datetime.datetime(2009, 4, 1, 5, 13, 2)
+        # NOTE: We do not test for time zone correctness.
+        sample_in = dict(project='GNOME-Do', url='http://example.com/1',
+                         title='Title', text='Some long text',
+                         importance=None, status='Ready for take-off',
+                         comments=[{'user': {
+                             'lplogin': 'jones', 'realname': 'Jones'}}],
+                         reporter={'lplogin': 'bob', 'realname': 'Bob'},
+                         date_reported=now_t,
+                         date_updated=now_t,
+                         )
+        sample_out_query = dict(project='GNOME-Do',
+                                canonical_bug_link='http://example.com/1')
+        sample_out_data = dict(title='Title', description='Some long text',
+                               importance='Unknown', status='Ready for take-off',
+                               people_involved=2, submitter_realname='Bob',
+                               submitter_username='bob',
+                               date_reported=now_d,
+                               last_touched=now_d)
+        out_q, out_d = mysite.customs.bugtrackers.launchpad.clean_lp_data_dict(sample_in)
+        self.assertEqual(sample_out_query, out_q)
+        # Make sure last_polled is at least in the same year
+        self.assertEqual(out_d['last_polled'].year, datetime.date.today().year)
+        del out_d['last_polled']
+        self.assertEqual(sample_out_data, out_d)
+
+class LaunchpadImporterMarksFixedBugsAsClosed(django.test.TestCase):
+    def test(self):
+        '''Start with a bug that is "Fix Released"
+
+        Verify that we set looks_closed to True'''
+        # retry this with committed->released
+        lp_data_dict = {'project': '',
+                        'url': '',
+                        'title': '',
+                        'text': '',
+                        'status': 'Fix Committed',
+                        'importance': '',
+                        'reporter': {'lplogin': '', 'realname': ''},
+                        'comments': '',
+                        'date_updated': datetime.datetime.now().timetuple(),
+                        'date_reported': datetime.datetime.now().timetuple()}
+        # maybe I could have done this with a defaultdict of str with
+        # just the non-str exceptions
+        query_data, new_data = mysite.customs.bugtrackers.launchpad.clean_lp_data_dict(
+            lp_data_dict)
+        self.assertTrue(new_data['looks_closed'])
+
+    def test_with_status_missing(self):
+        '''Verify we do not explode if Launchpad gives us a bug with no Status
+
+        Verify that we set looks_closed to True'''
+        # retry this with committed->released
+        lp_data_dict = {'project': '',
+                        'url': '',
+                        'title': '',
+                        'text': '',
+                        'importance': '',
+                        'reporter': {'lplogin': '', 'realname': ''},
+                        'comments': '',
+                        'date_updated': datetime.datetime.now().timetuple(),
+                        'date_reported': datetime.datetime.now().timetuple()}
+        # maybe I could have done this with a defaultdict of str with
+        # just the non-str exceptions
+        query_data, new_data = mysite.customs.bugtrackers.launchpad.clean_lp_data_dict(
+            lp_data_dict)
+        self.assertEqual(new_data['status'], 'Unknown')
+
 class DailyBugImporter(django.test.TestCase):
 
     @mock.patch('mysite.customs.ohloh.mechanize_get')
     def test_bugzilla_http_error_504_does_not_break(self, mock_error):
         mock_error.side_effect = generate_504
-        mysite.search.management.commands.search_daily_tasks.Command().find_and_update_enabled_bugzilla_instances()
+        mysite.customs.management.commands.customs_daily_tasks.Command().find_and_update_enabled_bugzilla_instances()
 
     @mock.patch('mysite.customs.ohloh.mechanize_get')
     def test_bugzilla_http_generic_error_does_break(self, mock_error):
         mock_error.side_effect = ValueError()
-        self.assertRaises(ValueError, mysite.search.management.commands.search_daily_tasks.Command().find_and_update_enabled_bugzilla_instances)
+        self.assertRaises(ValueError, mysite.customs.management.commands.customs_daily_tasks.Command().find_and_update_enabled_bugzilla_instances)
 
 
 # vim: set nu:
diff --git a/mysite/search/launchpad_crawl.py b/mysite/search/launchpad_crawl.py
deleted file mode 100644
index 99704a9..0000000
--- a/mysite/search/launchpad_crawl.py
+++ /dev/null
@@ -1,127 +0,0 @@
-# vim: set columns=80:
-import os
-import datetime
-
-# Initialize Launchpad scraper thing
-from launchpadbugs.connector import ConnectBug, ConnectBugList
-from launchpadbugs.basebuglistfilter import URLBugListFilter
-
-# Initialize data dumpers
-import lpb2json
-import simplejson
-
-import simplejson
-import datetime
-import glob
-from .models import Project, Bug
-import codecs
-
-#FIXME: Add only those of the following that actually use Launchpad for development.
-#u'apache-mod-digest' : u'apache-mod-digest' , u'bws-upload' : u'BWS-Upload' , u'pyjunitxml' : u'pyjunitxml' , u'bzr-search' : u'bzr search plugin' , u'bzr-email' : u'bzr email commit hook' , u'check' : u'check' , u'libsyncml' : u'libsyncml' , u'config-manager' : u'config-manager' , u'testscenarios' : u'testscenarios' , u'liburl' : u'liburl' , u'liblockdir' : u'lockdir' , u'bzr-guess' : u'bzr-guess' , u'etap' : u'etap' , u'gforth' : u'Gforth' , u'bitten' : u'Bitten' , u'sqlobject' : u'SQLObject' , u'bzr-ping' : u'Ping plugin for Bazaar' , u'unittest-ext' : u'unittest-ext' , u'pytz' : u'pytz' , u'funkload' : u'FunkLoad' , u'slony-i' : u'Slony-I' , u'zoneinfo' : u'The tz Database' , u'py-radius' : u'py-radius' , u'pypi' : u'Python Package Index' , u'pybabel' : u'Python Babel' , u'feedvalidator' : u'Feed Validator' , u'sphinx' : u'Sphinx' , u'mammoth-replicator' : u'Mammoth Replicator' , u'dbapi-compliance' : u'Python DBAPI Compliance Tests' , u'wget' : u'wget' , u'redhatcluster' : u'Red Hat Cluster' , u'bugzilla' : u'Bugzilla' , u'grepmap' : u'grepmap' , u'live-f1' : u'Live F1' , u'libnih' : u'libnih' , u'hct' : u'HCT' , u'upstart' : u'upstart ' , u'module-init-tools' : u'module-init-tools' , u'ubuntu-seeds' : u'Ubuntu Seeds' , u'usplash' : u'usplash' , u'merge-o-matic' : u'Merge-o-Matic' , u'uds-intrepid' : u'UDS Intrepid' , u'watershed' : u'watershed' , u'udev-extras' : u'Udev extras' , u'sreadahead' : u'sreadahead' , u'pybootchartgui' : u'pybootchartgui' , u'bootchart-collector' : u'bootchart-collector' , u'bootchart' : u'bootchart' , u'ubiquity' : u'ubiquity' , u'man-db' : u'man-db'}
-
-
-TextBugList = ConnectBugList("text")
-TextBug = ConnectBug("text")
-
-def dump_data_from_project(project):
-
-        yield serialized
-
-# Callback to handle an update to a single Launchpad bug update
-def handle_launchpad_bug_update(project_name, canonical_bug_link, new_data):
-    """
-    We're going to store a bug in our database. First we want to
-    check to see if we've stored in the DB a stale copy of the same bug.
-
-    Side-effect: We create or update a bug in the database.  
-    In particular, if we already have a bug for this (project,
-    canonical_bug_link) pair, we modify that instead of creating a
-    duplicate entry.
-
-    Right now we do not store last_modified time stamps; no one has
-    yet figured out what good it would do us."""
-    project, _ = Project.objects.get_or_create(name=project_name)
-    new_data['project'] = project
-    bug, created = Bug.all_bugs.get_or_create(
-            canonical_bug_link=canonical_bug_link, defaults=new_data)
-    # 'defaults' means data used for creating but not getting
-    if created:
-        return bug # nothing to do!
-    else:
-        # else, update the local copy of the bug
-        for key in new_data:
-            setattr(bug, key, new_data[key])
-        bug.save()
-        return bug
-    
-def clean_lp_data_dict(lp_data_dict):
-    """Input: A single datum as returned by launchpadbugs.
-
-    Output: query_data, new_data - two dicts that represent
-    processed data from Launchpad.
-    We've divided the data from launchpad into bug-identifying data (query_data)
-    and the rest of the data we want to store (new_data).
-    """
-    # These are the invariants for every bug: together (well, maybe the
-    # bug link is enough, hush) they uniquely identify the bug.
-    query_data = {}
-    query_data['canonical_bug_link'] = lp_data_dict['url']
-
-    # If the above is the "key" that we use to find or create the record,
-    # these are the "value",
-    new_data = {}
-    new_data['title'] = lp_data_dict['title']
-    new_data['description'] = lp_data_dict['text']
-
-    new_data['importance'] = lp_data_dict['importance']
-    if new_data['importance'] is None:
-        new_data['importance'] =  'Unknown'
-
-    # create set of people who have commented or created the ticket
-    people_involved = set()
-    if lp_data_dict['reporter']:
-        people_involved.add(dict2hashable(lp_data_dict['reporter']))
-    for comment in lp_data_dict['comments']:
-        people_involved.add(dict2hashable(comment['user']))
-
-    new_data['people_involved'] = len(people_involved)
-
-    new_data['submitter_username'] = lp_data_dict['reporter']['lplogin']
-    new_data['submitter_realname'] = unicode(lp_data_dict['reporter']['realname'])
-
-    # Handle dates
-    new_data['last_touched'] = datetime.datetime(*lp_data_dict['date_updated'][:6])
-    new_data['last_polled'] = datetime.datetime.now()
-
-    # Look for bitesize tag
-    # If no 'tags', pass
-    if 'bitesize' in lp_data_dict.get('tags', []):
-        new_data['good_for_newcomers'] = True
-
-    status =  lp_data_dict.get('status', 'Unknown')
-    if not status:
-        status = 'Unknown'
-    new_data['status'] = status
-    if new_data['status'].lower() in ('fix released', 'fix committed'):
-        new_data['looks_closed'] = True
-    # else looks_closed will be False due to the Bug default
-    new_data['date_reported'] = datetime.datetime(
-        *lp_data_dict['date_reported'][:6])
-    return query_data, new_data
-    
-def dict2hashable(d):
-    return tuple(d.items())
-
-def grab_lp_bugs(lp_project, openhatch_project_name):
-    '''Input: The name of a Launchpad project and its corresponding
-    OpenHatch project name.
-
-    Side effect: Loops over the available issues in that project and
-    updates the database with them.'''
-    for data_dict in dump_data_from_project(lp_project):
-        data_dict['project'] = openhatch_project_name
-        query_data, new_data = clean_lp_data_dict(data_dict)
-        handle_launchpad_bug_update(
-                project_name=openhatch_project_name,
-                canonical_bug_link=query_data['canonical_bug_link'],
-                new_data=new_data)
diff --git a/mysite/search/management/commands/search_daily_tasks.py b/mysite/search/management/commands/search_daily_tasks.py
deleted file mode 100644
index 5901e81..0000000
--- a/mysite/search/management/commands/search_daily_tasks.py
+++ /dev/null
@@ -1,116 +0,0 @@
-import logging
-
-from django.core.management.base import BaseCommand
-
-import django.conf
-django.conf.settings.CELERY_ALWAYS_EAGER = True
-
-import mysite.customs.bugtrackers.opensolaris
-import mysite.customs.bugtrackers.roundup_general
-import mysite.search.tasks.trac_instances
-import mysite.search.tasks.bugzilla_instances
-import mysite.search.tasks.launchpad_tasks
-
-import urllib2
-
-### All this code runs synchronously once a day.
-### For now, we can crawl all the bug trackers in serial.
-
-### One day, though, we will crawl so many bug trackers that it will take
-### too long.
-
-### I suggest that, at that point, we fork a number of worker processes, and
-### turn these lists into a queue or something. That should be easy with the
-### multiprocessing module. Then we can do N at once.
-
-### We could do something smart with statistics, detecting the average
-### refresh time within the bug tracker of a bug, then polling at some
-### approximation of that rate. (But, really, why bother?)
-
-### Since most of the time we're waiting on the network, we could also use
-### Twisted or Stackless Python or something. That would be super cool, too.
-### If somone can show me how to migrate this codebase to it, that'd be neat.
-### I'm unlikely to look into it myself, though.
-
-### (If at some point we start indexing absolutely every bug in free and open
-### source software, then the above ideas will actually become meaningful.)
-
-### -- New Age Asheesh, 2010-05-31.
-
-class Command(BaseCommand):
-    help = "Call this once a day to make sure we run Bug search-related nightly jobs."
-
-    def find_and_update_enabled_roundup_trackers(self):
-        enabled_roundup_trackers = []
-
-        ### First, the "find" step
-        for thing_name in dir(mysite.customs.bugtrackers.roundup_general):
-            thing = getattr(mysite.customs.bugtrackers.roundup_general,
-                            thing_name)
-            if hasattr(thing, 'enabled'):
-                if getattr(thing, 'enabled'):
-                    enabled_roundup_trackers.append(thing)
-
-        ### Okay, now update!
-        for thing in enabled_roundup_trackers:
-            logging.info("[Roundup] About to update %s" % thing)
-            instantiated = thing()
-            instantiated.update()
-
-    def find_and_update_enabled_trac_instances(self):
-        enabled_trac_instances = []
-
-        ### First, the "find" step
-        for thing_name in dir(mysite.search.tasks.trac_instances):
-            thing = getattr(mysite.search.tasks.trac_instances,
-                            thing_name)
-            if hasattr(thing, 'enabled'):
-                if getattr(thing, 'enabled'):
-                    enabled_trac_instances.append(thing)
-
-        ### Okay, now update!
-        for thing in enabled_trac_instances:
-            logging.info("[Trac] About to update %s" % thing)
-            instantiated = thing()
-            instantiated.update()
-
-    def find_and_update_enabled_bugzilla_instances(self):
-        enabled_bugzilla_instances = []
-
-        ### First, the "find" step
-        for thing_name in dir(mysite.search.tasks.bugzilla_instances):
-            thing = getattr(mysite.search.tasks.bugzilla_instances,
-                            thing_name)
-            if hasattr(thing, 'enabled'):
-                if getattr(thing, 'enabled'):
-                    enabled_bugzilla_instances.append(thing)
-
-        ### Okay, now update!
-        for thing in enabled_bugzilla_instances:
-            logging.info("[Bugzilla] About to update %s" % thing)
-            instantiated = thing()
-            # FIXME: The Bugzilla trackers seem to throw error 500 a lot.
-            # For now, chuck in a dirty big try except to stop importer
-            # breaking.
-            try:
-                instantiated.update()
-            except urllib2.URLError, e:
-                logging.error("[Bugzilla] ERROR: Importer failed, likely HTTP500, continuing on...")
-                logging.error("[Bugzilla] Error message: %s" % str(e))
-
-    def update_launchpad_hosted_projects(self):
-        ### For Launchpad:
-        # First, we ask the projects' bug trackers if there are new bugs we should know about
-        mysite.search.tasks.launchpad_tasks.refresh_bugs_from_all_indexed_launchpad_projects()
-        # Second, we go through our *own* database of Launchpad-sourced bugs, and make sure they are all up to date
-        mysite.search.tasks.launchpad_tasks.refresh_all_launchpad_bugs()
-
-    def update_opensolaris_osnet(self):
-        mysite.customs.bugtrackers.opensolaris.update()
-
-    def handle(self, *args, **options):
-        self.update_opensolaris_osnet()
-        self.update_launchpad_hosted_projects()
-        self.find_and_update_enabled_trac_instances()
-        self.find_and_update_enabled_roundup_trackers()
-        self.find_and_update_enabled_bugzilla_instances()
diff --git a/mysite/search/tasks/__init__.py b/mysite/search/tasks/__init__.py
index 2076fd0..d7db1db 100644
--- a/mysite/search/tasks/__init__.py
+++ b/mysite/search/tasks/__init__.py
@@ -11,10 +11,6 @@ import datetime
 
 from django.conf import settings
 
-import mysite.search.tasks.trac_instances
-import mysite.search.tasks.bugzilla_instances
-import mysite.search.tasks.launchpad_tasks
-import mysite.search.tasks.roundup_instances
 import mysite.base.helpers
 
 class PopulateProjectIconFromOhloh(Task):
diff --git a/mysite/search/tasks/bugzilla_instances.py b/mysite/search/tasks/bugzilla_instances.py
deleted file mode 100644
index 69ce5fe..0000000
--- a/mysite/search/tasks/bugzilla_instances.py
+++ /dev/null
@@ -1,653 +0,0 @@
-import datetime
-import logging
-
-import mysite.base.models
-import mysite.search.models
-import mysite.customs.bugtrackers.bugzilla
-
-# FIXME: Should have this somewhere else. Maybe a decorator?
-# Could take arguments of urls and remove the fresh ones.
-def url_is_more_fresh_than_one_day(url):
-    url_timestamp = mysite.base.models.Timestamp.get_timestamp_for_string(url)
-    url_age = datetime.datetime.now() - url_timestamp
-    url_is_fresh = (url_age < datetime.timedelta(days=1))
-    try:
-        mysite.base.models.Timestamp.update_timestamp_for_string(url)
-    except Exception, e:
-        logging.error("[Bugzilla] Error generated when updating Timestamp.")
-        logging.error("[Bugzilla] Error type is %s" % type(e))
-        logging.error("[Bugzilla] Error is %s" % e)
-    return url_is_fresh
-
-class BugzillaBugTracker(object):
-    def __init__(self, base_url, project_name, bug_project_name_format, bug_id_list_only=False):
-        self.base_url = base_url
-        self.project_name = project_name
-        self.bug_project_name_format = bug_project_name_format
-        self.bug_id_list_only = bug_id_list_only
-
-    def generate_bug_xml_from_queries(self, queries):
-        for query_name in queries:
-            query_url = queries[query_name]
-            # Check if this url has been accessed in the last day
-            if url_is_more_fresh_than_one_day(query_url):
-                # Sweet, ignore this one and go on.
-                logging.info("[Bugzilla] URL %s is fresh, skipping..." % query_url)
-                continue
-            query_xml = mysite.customs.bugtrackers.bugzilla.url2bug_data(query_url)
-            for bug_xml in query_xml.xpath('bug'):
-                yield bug_xml
-
-    def generate_bug_project_name(self, bb):
-        return self.bug_project_name_format.format(
-                project = self.project_name,
-                product = bb.product,
-                component = bb.component)
-
-    def create_or_refresh_one_bugzilla_bug(self, bb):
-        bug_id = bb.bug_id
-        bug_url = bb.as_bug_specific_url()
-
-        try:
-            bug = mysite.search.models.Bug.all_bugs.get(
-                    canonical_bug_link=bug_url)
-            # Found an existing bug. Does it need refreshing?
-            if bug.data_is_more_fresh_than_one_day():
-                logging.info("[Bugzilla] Bug %d from %s is fresh. Doing nothing!" % (bug_id, self.project_name))
-                return False # sweet
-        except mysite.search.models.Bug.DoesNotExist:
-            # This is a new bug
-            bug = mysite.search.models.Bug(canonical_bug_link = bug_url)
-
-        # Looks like we have some refreshing to do.
-        logging.info("[Bugzilla] Refreshing bug %d from %s." % (bug_id, self.project_name))
-        # Get the dictionary of data to put into the bug. The function for
-        # obtaining tracker-specific data is passed in.
-        data = bb.as_data_dict_for_bug_object(self.extract_tracker_specific_data)
-
-        # Fill that bug!
-        for key in data:
-            value = data[key]
-            setattr(bug, key, value)
-
-        # Find or create the project for the bug and save it
-        bug_project_name = self.generate_bug_project_name(bb)
-        if bug_project_name == '':
-            raise ValueError("Can't have bug_project_name as ''")
-        project_from_name, _ = mysite.search.models.Project.objects.get_or_create(name=bug_project_name)
-        if bug.project_id != project_from_name.id:
-            bug.project = project_from_name
-        bug.last_polled = datetime.datetime.utcnow()
-        bug.save()
-        logging.info("[Bugzilla] Finished with %d from %s." % (bug_id, self.project_name))
-        return True
-
-    def refresh_all_bugs(self):
-        for bug in mysite.search.models.Bug.all_bugs.filter(
-                canonical_bug_link__contains=self.base_url):
-            bb = mysite.customs.bugtrackers.bugzilla.BugzillaBug.from_url(
-                    bug.canonical_bug_link)
-            self.create_or_refresh_one_bugzilla_bug(bb=bb)
-
-    def update(self):
-        logging.info("[Bugzilla] Started refreshing all %s bugs" % self.project_name)
-
-        # First, go through and create or refresh all the bugs that
-        # we are configured to track. This will add new bugs and
-        # update current ones. Bugzilla doesn't return a nice
-        # CSV list of bug ids, but instead gives an entire XML tree
-        # of bug data for the bugs matching the query. To save on
-        # network traffic, the bug data will be passed to the refresher.
-        if self.bug_id_list_only:
-            # If we have a tracking bug, then we can't get an xml tree
-            # of bug data. Instead we have to use the bug ids pulled
-            # from the dependencies of the tracking bug.
-            current_bug_id_list = self.get_current_bug_id_list()
-            for bug_id in current_bug_id_list:
-                bb = mysite.customs.bugtrackers.bugzilla.BugzillaBug(
-                        BASE_URL=self.base_url,
-                        bug_id=bug_id)
-                self.create_or_refresh_one_bugzilla_bug(bb=bb)
-        else:
-            logging.info("[Bugzilla] Fetching XML data for bugs in tracker...")
-            for bug_data in self.generate_current_bug_xml():
-                bb = mysite.customs.bugtrackers.bugzilla.BugzillaBug(
-                        BASE_URL=self.base_url,
-                        bug_data=bug_data)
-                self.create_or_refresh_one_bugzilla_bug(bb=bb)
-
-        # Then refresh all the bugs we have from this tracker. This
-        # should skip over all the bugs except the ones that didn't
-        # appear in the above query. Usually this is closed bugs.
-        self.refresh_all_bugs()
-
-class MiroBugzilla(BugzillaBugTracker):
-    enabled = True
-
-    def __init__(self):
-        BugzillaBugTracker.__init__(self,
-                                    base_url='http://bugzilla.pculture.org/',
-                                    project_name='Miro',
-                                    bug_project_name_format='{project}')
-
-    def generate_current_bug_xml(self):
-        queries = {
-                'Easy bugs':
-                    'http://bugzilla.pculture.org/buglist.cgi?bug_status=NEW&bug_status=ASSIGNED&bug_status=REOPENED&field-1-0-0=bug_status&field-1-1-0=product&field-1-2-0=keywords&keywords=bitesized&product=Miro&query_format=advanced&remaction=&type-1-0-0=anyexact&type-1-1-0=anyexact&type-1-2-0=anywords&value-1-0-0=NEW%2CASSIGNED%2CREOPENED&value-1-1-0=Miro&value-1-2-0=bitesized',
-                #'Documentation bugs':
-                    #''
-                }
-        return self.generate_bug_xml_from_queries(queries)
-
-    @staticmethod
-    def extract_tracker_specific_data(xml_data, ret_dict):
-        # Make modifications to ret_dict using provided xml data
-        keywords_text = mysite.customs.bugtrackers.bugzilla.get_tag_text_from_xml(xml_data, 'keywords')
-        keywords = map(lambda s: s.strip(),
-                       keywords_text.split(','))
-        ret_dict['good_for_newcomers'] = ('bitesized' in keywords)
-        ret_dict['bite_size_tag_name'] = 'bitesized'
-        # Then pass ret_dict back
-        return ret_dict
-
-class KDEBugzilla(BugzillaBugTracker):
-    enabled = True
-
-    def __init__(self):
-        BugzillaBugTracker.__init__(self,
-                                    base_url='https://bugs.kde.org/',
-                                    project_name='KDE',
-                                    bug_project_name_format='')
-
-    def generate_current_bug_xml(self):
-        queries = {
-                'Easy bugs':
-                    'https://bugs.kde.org/buglist.cgi?query_format=advanced&keywords=junior-jobs&resolution=---',
-                'Documentation bugs':
-                    'https://bugs.kde.org/buglist.cgi?query_format=advanced&product=docs&resolution=---'
-                }
-        return self.generate_bug_xml_from_queries(queries)
-
-    @staticmethod
-    def extract_tracker_specific_data(xml_data, ret_dict):
-        # Make modifications to ret_dict using provided metadata
-        keywords_text = mysite.customs.bugtrackers.bugzilla.get_tag_text_from_xml(xml_data, 'keywords')
-        keywords = map(lambda s: s.strip(),
-                       keywords_text.split(','))
-        ret_dict['good_for_newcomers'] = ('junior-jobs' in keywords)
-        ret_dict['bite_size_tag_name'] = 'junior-jobs'
-        # Remove 'JJ:' from title if present
-        if ret_dict['title'].startswith("JJ:"):
-            ret_dict['title'] = ret_dict['title'][3:].strip()
-        # Check whether documentation bug
-        product = mysite.customs.bugtrackers.bugzilla.get_tag_text_from_xml(xml_data, 'product')
-        ret_dict['concerns_just_documentation'] = (product == 'docs')
-        # Then pass ret_dict back
-        return ret_dict
-
-    def generate_bug_project_name(self, bb):
-        product = bb.product
-        reasonable_products = set([
-            'Akonadi',
-            'Phonon'
-            'kmail',
-            'Rocs',
-            'akregator',
-            'amarok',
-            'ark',
-            'cervisia',
-            'k3b',
-            'kappfinder',
-            'kbabel',
-            'kdeprint',
-            'kdesktop',
-            'kfile',
-            'kfourinline',
-            'khotkeys',
-            'kio',
-            'kmail',
-            'kmplot',
-            'koffice',
-            'kompare',
-            'konqueror',
-            'kopete',
-            'kpat',
-            'kphotoalbum',
-            'krita',
-            'ksmserver',
-            'kspread',
-            'ksysguard',
-            'ktimetracker',
-            'kwin',
-            'kword',
-            'marble',
-            'okular',
-            'plasma',
-            'printer-applet',
-            'rsibreak',
-            'step',
-            'systemsettings',
-            'kdelibs',
-            'kcontrol',
-            'korganizer',
-            'kipiplugins',
-            'Phonon',
-            'dolphin',
-            'umbrello']
-            )
-        products_to_be_renamed = {
-            'digikamimageplugins': 'digikam image plugins',
-            'Network Management': 'KDE Network Management',
-            'telepathy': 'telepathy for KDE',
-            'docs': 'KDE documentation',
-            }
-        component = bb.component
-        things = (product, component)
-
-        if product in reasonable_products:
-            bug_project_name = product
-        else:
-            if product in products_to_be_renamed:
-                bug_project_name = products_to_be_renamed[product]
-            else:
-                logging.info("Guessing on KDE subproject name. Found %s" %  repr(things))
-                bug_project_name = product
-        return bug_project_name
-
-class MediaWikiBugzilla(BugzillaBugTracker):
-    enabled = True
-
-    def __init__(self):
-        BugzillaBugTracker.__init__(self,
-                                    base_url='https://bugzilla.wikimedia.org/',
-                                    project_name='MediaWiki',
-                                    bug_project_name_format='')
-
-    def generate_current_bug_xml(self):
-        queries = {
-                'Easy bugs':
-                    'https://bugzilla.wikimedia.org/buglist.cgi?keywords=easy&query_format=advanced&resolution=LATER&resolution=---',
-                'Documentation bugs':
-                    'https://bugzilla.wikimedia.org/buglist.cgi?query_format=advanced&component=Documentation&resolution=---'
-                }
-        return self.generate_bug_xml_from_queries(queries)
-
-    @staticmethod
-    def extract_tracker_specific_data(xml_data, ret_dict):
-        # Make modifications to ret_dict using provided metadata
-        # Check for the bitesized keyword
-        keywords_text = mysite.customs.bugtrackers.bugzilla.get_tag_text_from_xml(xml_data, 'keywords')
-        keywords = map(lambda s: s.strip(),
-                       keywords_text.split(','))
-        ret_dict['good_for_newcomers'] = ('easy' in keywords)
-        ret_dict['bite_size_tag_name'] = 'easy'
-        # Check whether documentation bug
-        component = mysite.customs.bugtrackers.bugzilla.get_tag_text_from_xml(xml_data, 'component')
-        ret_dict['concerns_just_documentation'] = (component == 'Documentation')
-        # Then pass ret_dict back
-        return ret_dict
-
-    def generate_bug_project_name(self, bb):
-        product = bb.product
-        if product == 'MediaWiki extensions':
-            bug_project_name = bb.component
-            if bug_project_name in ('FCKeditor', 'Gadgets'):
-                bug_project_name += ' for MediaWiki'
-        else:
-            bug_project_name = product
-        return bug_project_name
-
-class GnomeBugzilla(BugzillaBugTracker):
-    enabled = True
-
-    def __init__(self):
-        BugzillaBugTracker.__init__(self,
-                                    base_url='https://bugzilla.gnome.org/',
-                                    project_name='Gnome',
-                                    bug_project_name_format='')
-
-    def generate_current_bug_xml(self):
-        # Get all bugs that contain any of the keywords 'gnome-love'
-        # or 'documentation'
-        queries = {
-                'Easy bugs':
-                    'https://bugzilla.gnome.org/buglist.cgi?columnlist=id&keywords=gnome-love&query_format=advanced&resolution=---',
-                # FIXME: Query with documentation keyword causes XML syntax errors
-                #'Documentation bugs':
-                    #'https://bugzilla.gnome.org/buglist.cgi?columnlist=id&keywords=gnome-love%2Cdocumentation&query_format=advanced&resolution=---'
-                }
-        return self.generate_bug_xml_from_queries(queries)
-
-    @staticmethod
-    def extract_tracker_specific_data(xml_data, ret_dict):
-        # Make modifications to ret_dict using provided metadata
-        # Check for the bitesized keyword
-        keywords_text = mysite.customs.bugtrackers.bugzilla.get_tag_text_from_xml(xml_data, 'keywords')
-        keywords = map(lambda s: s.strip(),
-                       keywords_text.split(','))
-        ret_dict['good_for_newcomers'] = ('gnome-love' in keywords)
-        ret_dict['bite_size_tag_name'] = 'gnome-love'
-        # Check whether this is a documentation bug.
-        ret_dict['concerns_just_documentation'] = ('documentation' in keywords)
-        # Then pass ret_dict back
-        return ret_dict
-
-    def generate_bug_project_name(self, bb):
-        bug_project_name = bb.product
-        gnome2openhatch = {'general': 'GNOME (general)',
-                           'website': 'GNOME (website)'}
-        if bug_project_name in gnome2openhatch:
-            bug_project_name=gnome2openhatch[bug_project_name]
-        return bug_project_name
-
-class MozillaBugzilla(BugzillaBugTracker):
-    enabled = True
-
-    def __init__(self):
-        BugzillaBugTracker.__init__(self,
-                                    base_url='https://bugzilla.mozilla.org/',
-                                    project_name='Mozilla',
-                                    bug_project_name_format='')
-
-    def generate_current_bug_xml(self):
-        queries = {
-                'Easy bugs':
-                    'https://bugzilla.mozilla.org/buglist.cgi?resolution=---;status_whiteboard_type=substring;query_format=advanced;status_whiteboard=[good%20first%20bug]',
-                #'Documentation bugs':
-                    #''
-                }
-        return self.generate_bug_xml_from_queries(queries)
-
-    @staticmethod
-    def extract_tracker_specific_data(xml_data, ret_dict):
-        # Make modifications to ret_dict using provided metadata
-        # Check for the bitesized keyword
-        whiteboard_text = mysite.customs.bugtrackers.bugzilla.get_tag_text_from_xml(xml_data, 'status_whiteboard')
-        ret_dict['good_for_newcomers'] = (whiteboard_text == '[good first bug]')
-        ret_dict['bite_size_tag_name'] = '[good first bug]'
-        # Then pass ret_dict back
-        return ret_dict
-
-    def generate_bug_project_name(self, bb):
-        ### Special-case the project names we know about
-        mozilla2openhatch = {'Core': 'Mozilla Core',
-                             'Firefox': 'Firefox',
-                             'MailNews Core': 'Mozilla Messaging',
-                             'addons.mozilla.org': 'addons.mozilla.org',
-                             'Thunderbird': 'Thunderbird',
-                             'Testing': 'Mozilla automated testing',
-                             'Directory': 'Mozilla LDAP',
-                             'mozilla.org': 'mozilla.org',
-                             'SeaMonkey': 'SeaMonkey',
-                             'Toolkit': 'Mozilla Toolkit',
-                             'support.mozilla.com': 'support.mozilla.com',
-                             'Camino': 'Camino',
-                             'Calendar': 'Mozilla Calendar',
-                             'Mozilla Localizations': 'Mozilla Localizations',
-                             }
-        if bb.product == 'Other Applications':
-            bug_project_name = 'Mozilla ' + bb.component
-        else:
-            bug_project_name = mozilla2openhatch[bb.product]
-        return bug_project_name
-
-class FedoraBugzilla(BugzillaBugTracker):
-    enabled = True
-
-    def __init__(self):
-        BugzillaBugTracker.__init__(self,
-                                    base_url='https://bugzilla.redhat.com/',
-                                    project_name='Fedora',
-                                    bug_project_name_format='{component}',
-                                    bug_id_list_only=True)
-
-    def get_current_bug_id_list(self):
-        return mysite.customs.bugtrackers.bugzilla.tracker_bug2bug_ids(
-                'https://bugzilla.redhat.com/show_bug.cgi?ctype=xml&id=509829')
-
-    @staticmethod
-    def extract_tracker_specific_data(xml_data, ret_dict):
-        # Make modifications to ret_dict using provided metadata
-        # Check for the bitesized keyword
-        keywords_text = mysite.customs.bugtrackers.bugzilla.get_tag_text_from_xml(xml_data, 'keywords')
-        keywords = map(lambda s: s.strip(),
-                       keywords_text.split(','))
-        ret_dict['good_for_newcomers'] = True # Since they are 'fit and finish'
-        ret_dict['bite_size_tag_name'] = 'fitandfinish'
-        # Set the distribution tag
-        ret_dict['as_appears_in_distribution'] = 'Fedora'
-        # Then pass ret_dict back
-        return ret_dict
-
-class SongbirdBugzilla(BugzillaBugTracker):
-    enabled = True
-
-    def __init__(self):
-        BugzillaBugTracker.__init__(self,
-                                    base_url='http://bugzilla.songbirdnest.com/',
-                                    project_name='Songbird',
-                                    bug_project_name_format='{project}')
-
-    def generate_current_bug_xml(self):
-        # Query below returns nearly 4000 bugs if we try to index everything.
-        # For now, only import bugs with 'helpwanted' tag.
-        # (This tag doesn't equate to 'bitesized'.)
-        queries = {
-                'Helpwanted bugs':
-                    'http://bugzilla.songbirdnest.com/buglist.cgi?query_format=advanced&resolution=---&keywords=helpwanted',
-                'Documentation bugs':
-                    'http://bugzilla.songbirdnest.com/buglist.cgi?query_format=advanced&component=Documentation&resolution=---'
-                }
-        return self.generate_bug_xml_from_queries(queries)
-
-    @staticmethod
-    def extract_tracker_specific_data(xml_data, ret_dict):
-        # Make modifications to ret_dict using provided metadata
-        ret_dict['good_for_newcomers'] = False # 'helpwanted' doesn't just indicate bitesized.
-        # Check whether documentation bug
-        component = mysite.customs.bugtrackers.bugzilla.get_tag_text_from_xml(xml_data, 'component')
-        ret_dict['concerns_just_documentation'] = (component == 'Documentation')
-        # Then pass ret_dict back
-        return ret_dict
-
-class ApertiumBugzilla(BugzillaBugTracker):
-    enabled = True
-
-    def __init__(self):
-        BugzillaBugTracker.__init__(self,
-                                    base_url='http://bugs.apertium.org/cgi-bin/bugzilla/',
-                                    project_name='Apertium',
-                                    bug_project_name_format='{project}')
-
-    def generate_current_bug_xml(self):
-        queries = {
-                'All bugs':
-                    'http://bugs.apertium.org/cgi-bin/bugzilla/buglist.cgi?query_format=advanced&resolution=---'
-                }
-        return self.generate_bug_xml_from_queries(queries)
-
-    @staticmethod
-    def extract_tracker_specific_data(xml_data, ret_dict):
-        # Make modifications to ret_dict using provided metadata
-        ret_dict['good_for_newcomers'] = False # No bitesized keyword.
-        # Then pass ret_dict back
-        return ret_dict
-
-class RTEMSBugzilla(BugzillaBugTracker):
-    enabled = True
-
-    def __init__(self):
-        BugzillaBugTracker.__init__(self,
-                                    base_url='https://www.rtems.org/bugzilla/',
-                                    project_name='RTEMS',
-                                    bug_project_name_format='{project}')
-
-    def generate_current_bug_xml(self):
-        queries = {
-                'All bugs':
-                    'https://www.rtems.org/bugzilla/buglist.cgi?query_format=advanced&resolution=---'
-                }
-        return self.generate_bug_xml_from_queries(queries)
-
-    @staticmethod
-    def extract_tracker_specific_data(xml_data, ret_dict):
-        # Make modifications to ret_dict using provided metadata
-        ret_dict['good_for_newcomers'] = False # No bitesized keyword.
-        # Check whether documentation bug
-        component = mysite.customs.bugtrackers.bugzilla.get_tag_text_from_xml(xml_data, 'component')
-        ret_dict['concerns_just_documentation'] = (component == 'doc')
-        # Then pass ret_dict back
-        return ret_dict
-
-# This tracker could be extended to cover all of FreeDesktop.
-# For now, just do X.Org since it is all that was requested.
-class XOrgBugzilla(BugzillaBugTracker):
-    enabled = True
-
-    def __init__(self):
-        BugzillaBugTracker.__init__(self,
-                                    base_url='https://bugs.freedesktop.org/',
-                                    project_name='XOrg',
-                                    bug_project_name_format='{project}')
-
-    def generate_current_bug_xml(self):
-        # Query below returns over 2500 bugs if we try to index everything.
-        # For now just index bitesized bugs - keyword filter added to query.
-        queries = {
-                'Easy bugs':
-                    'https://bugs.freedesktop.org/buglist.cgi?query_format=advanced&keywords=janitor&resolution=---&product=xorg',
-                'Documentation bugs':
-                    'https://bugs.freedesktop.org/buglist.cgi?query_format=advanced&component=Docs%2Fother&component=Documentation&component=Fonts%2Fdoc&resolution=---&product=xorg'
-                }
-        return self.generate_bug_xml_from_queries(queries)
-
-    @staticmethod
-    def extract_tracker_specific_data(xml_data, ret_dict):
-        # Make modifications to ret_dict using provided metadata
-        # Check for the bitesized keyword
-        keywords_text = mysite.customs.bugtrackers.bugzilla.get_tag_text_from_xml(xml_data, 'keywords')
-        keywords = map(lambda s: s.strip(),
-                       keywords_text.split(','))
-        ret_dict['good_for_newcomers'] = ('janitor' in keywords)
-        ret_dict['bite_size_tag_name'] = 'janitor'
-        # Check whether documentation bug
-        component = mysite.customs.bugtrackers.bugzilla.get_tag_text_from_xml(xml_data, 'component')
-        documentation_components = [
-                'Docs/other',
-                'Documentation',
-                'Fonts/doc']
-        ret_dict['concerns_just_documentation'] = (component in documentation_components)
-        # Then pass ret_dict back
-        return ret_dict
-
-class LocamotionBugzilla(BugzillaBugTracker):
-    enabled = False # FIXME: Throws XML encoding error.
-
-    def __init__(self):
-        BugzillaBugTracker.__init__(self,
-                                    base_url='http://bugs.locamotion.org/',
-                                    project_name='Locamotion',
-                                    bug_project_name_format='{product}')
-
-    def generate_current_bug_xml(self):
-        queries = {
-                'All bugs':
-                    'http://bugs.locamotion.org/buglist.cgi?query_format=advanced&resolution=---'
-                }
-        return self.generate_bug_xml_from_queries(queries)
-
-    @staticmethod
-    def extract_tracker_specific_data(xml_data, ret_dict):
-        # Make modifications to ret_dict using provided metadata
-        ret_dict['good_for_newcomers'] = False # No bitesized keyword.
-        # Then pass ret_dict back
-        return ret_dict
-
-class HypertritonBugzilla(BugzillaBugTracker):
-    enabled = True
-
-    def __init__(self):
-        BugzillaBugTracker.__init__(self,
-                                    base_url='https://hypertriton.com/bugzilla/',
-                                    project_name='Hypertriton',
-                                    bug_project_name_format='{product}')
-
-    def generate_current_bug_xml(self):
-        queries = {
-                'All bugs':
-                    'https://hypertriton.com/bugzilla/buglist.cgi?query_format=advanced&resolution=---&product=Agar&product=EDAcious&product=FabBSD&product=FreeSG'
-                }
-        return self.generate_bug_xml_from_queries(queries)
-
-    @staticmethod
-    def extract_tracker_specific_data(xml_data, ret_dict):
-        # Make modifications to ret_dict using provided metadata
-        ret_dict['good_for_newcomers'] = False # No bitesized keyword
-        # Then pass ret_dict back
-        return ret_dict
-
-class PygameBugzilla(BugzillaBugTracker):
-    enabled = True
-
-    def __init__(self):
-        BugzillaBugTracker.__init__(self,
-                                    base_url='http://pygame.motherhamster.org/bugzilla/',
-                                    project_name='pygame',
-                                    bug_project_name_format='{project}')
-
-    def generate_current_bug_xml(self):
-        queries = {
-                'All bugs':
-                    'http://pygame.motherhamster.org/bugzilla/buglist.cgi?query_format=advanced&resolution=---'
-                }
-        return self.generate_bug_xml_from_queries(queries)
-
-    @staticmethod
-    def extract_tracker_specific_data(xml_data, ret_dict):
-        # Make modifications to ret_dict using provided metadata
-        ret_dict['good_for_newcomers'] = False # No bitesized keyword
-        # Then pass ret_dict back
-        return ret_dict
-
-# The generic class for Bugzilla trackers. Copy it.
-# If the project has a tracker bug for the bugs to be imported,
-# set bug_id_list_only=True in BugzillaBugTracker.__init__ and
-# replace get_current_xml_bug_tree with get_current_bug_id_list
-# bug_project_name_format can contain the tags {project},
-# {product} and {component} which will be replaced accordingly.
-class GenBugzilla(BugzillaBugTracker):
-    enabled = False
-
-    def __init__(self):
-        BugzillaBugTracker.__init__(self,
-                                    base_url='',
-                                    project_name='',
-                                    bug_project_name_format='')
-
-    def generate_current_bug_xml(self):
-        # Can replace both entries below with an 'All bugs' query.
-        queries = {
-                'Easy bugs':
-                    '',
-                'Documentation bugs':
-                    ''
-                }
-        return self.generate_bug_xml_from_queries(queries)
-
-    @staticmethod
-    def extract_tracker_specific_data(xml_data, ret_dict):
-        # Make modifications to ret_dict using provided metadata
-        # Check for the bitesized keyword
-        keywords_text = mysite.customs.bugtrackers.bugzilla.get_tag_text_from_xml(xml_data, 'keywords')
-        keywords = map(lambda s: s.strip(),
-                       keywords_text.split(','))
-        ret_dict['good_for_newcomers'] = ('' in keywords)
-        ret_dict['bite_size_tag_name'] = ''
-        # Then pass ret_dict back
-        return ret_dict
-
-    # The format string method for generating the project name can be
-    # overloaded by uncommenting the function below.
-    #def generate_bug_project_name(self, bb):
-        #return bug_project_name
-
diff --git a/mysite/search/tasks/launchpad_tasks.py b/mysite/search/tasks/launchpad_tasks.py
deleted file mode 100644
index 6fe415f..0000000
--- a/mysite/search/tasks/launchpad_tasks.py
+++ /dev/null
@@ -1,93 +0,0 @@
-from datetime import timedelta
-import datetime
-import logging
-import mysite.search.models
-import mysite.customs.models
-from celery.task import Task
-from celery.registry import tasks
-import celery.decorators
-import mysite.search.launchpad_crawl
-
-def refresh_bugs_from_all_indexed_launchpad_projects():
-    # Look, ma, a hard-coded table that maps to
-    # OpenHatch project names from Launchpad.net project names.
-    # TimBL would be proud.
-    lpproj2ohproj = { 'lxml': 'lxml',
-                      'do': 'GNOME-do',
-                      'gwibber': 'Gwibber',
-                      'keryx': 'Keryx',
-                     }
-    for launchpad_project_name in lpproj2ohproj:
-        openhatch_project_name = lpproj2ohproj[launchpad_project_name]
-        import_bugs_from_one_project(launchpad_project_name,
-                                     openhatch_project_name)
-
-@celery.decorators.task
-def import_bugs_from_one_project(launchpad_project_name,
-                                 openhatch_project_name):
-    logging.info("Looking at bugs %s on Launchpad" % launchpad_project_name)
-    url = "https://bugs.launchpad.net/%s/+bugs" % launchpad_project_name
-    bug_filter = mysite.search.launchpad_crawl.URLBugListFilter()
-    # no filtering; dump everything
-    l = mysite.search.launchpad_crawl.TextBugList(bug_filter(url))
-    # convert elements into Bug objects
-    for bug in l:
-        openhatch_bug_link = 'https://bugs.launchpad.net/bugs/%d' % (
-            bug.bugnumber)
-        refresh_one_launchpad_bug(
-            canonical_bug_link=openhatch_bug_link,
-            openhatch_project_name=openhatch_project_name)
-
-def refresh_all_launchpad_bugs():
-    logging.info("Refreshing all Launchpad bugs.")
-    all_lp_bugs = mysite.search.models.Bug.all_bugs.filter(
-        canonical_bug_link__startswith='https://bugs.launchpad.net/')
-    logging.info("All %d of them." % all_lp_bugs.count())
-    for lp_bug in all_lp_bugs:
-        refresh_one_launchpad_bug(
-            canonical_bug_link=lp_bug.canonical_bug_link,
-            openhatch_project_name=None)
-
-@celery.decorators.task
-def refresh_one_launchpad_bug(canonical_bug_link,
-                              openhatch_project_name):
-    logging.info("Checking on %s..." % canonical_bug_link)
-    # Either we already have the bug...
-    try:
-        bug = mysite.search.models.Bug.all_bugs.get(
-            canonical_bug_link=canonical_bug_link)
-    # ...or we need to create it
-    except mysite.search.models.Bug.DoesNotExist:
-        bug = mysite.search.models.Bug()
-        bug.canonical_bug_link = canonical_bug_link
-
-    if bug.data_is_more_fresh_than_one_day():
-        return
-
-    # Okay, so it's stale. Refresh the sucker.
-    logging.info("Refreshing %s." % canonical_bug_link)
-
-    # Set the project, if necessary
-    if openhatch_project_name is None:
-        pass
-    else:
-        # Get or create the OpenHatch project
-        openhatch_project, _ = mysite.search.models.Project.objects.get_or_create(name=openhatch_project_name)
-        
-        if bug.project_id != openhatch_project.id:
-            bug.project = openhatch_project
-
-    # FIXME: One day, look at the bug data to see what project to use.
-    # This code incorrectly assumes bugs don't migrate from one project
-    # to another.
-    prefix = 'https://bugs.launchpad.net/bugs/'
-    assert canonical_bug_link.startswith(prefix)
-    bug_id_str = canonical_bug_link.split(prefix, 1)[1]
-    bug_id = int(bug_id_str)
-    tb = mysite.search.launchpad_crawl.TextBug(bug_id)
-    data_dict = mysite.search.lpb2json.obj2serializable(tb)
-    _, new_data = mysite.search.launchpad_crawl.clean_lp_data_dict(data_dict)
-    for key in new_data:
-        setattr(bug, key, new_data[key])
-    bug.last_polled = datetime.datetime.utcnow()
-    bug.save()
diff --git a/mysite/search/tasks/roundup_instances.py b/mysite/search/tasks/roundup_instances.py
deleted file mode 100644
index e69de29..0000000
diff --git a/mysite/search/tasks/trac_instances.py b/mysite/search/tasks/trac_instances.py
deleted file mode 100644
index f7d7fac..0000000
--- a/mysite/search/tasks/trac_instances.py
+++ /dev/null
@@ -1,548 +0,0 @@
-import datetime
-import logging
-
-import mysite.search.models
-import mysite.customs.bugtrackers.trac
-
-class TracBugTracker(object):
-    enabled = False
-
-    def __init__(self, base_url, project_name, bug_project_name_format):
-        self.base_url = base_url
-        self.project_name = project_name
-        self.bug_project_name_format = bug_project_name_format
-
-    def generate_bug_ids_from_queries(self, queries):
-        for query_name in queries:
-            query_url = queries[query_name]
-            query_ids = mysite.customs.bugtrackers.trac.csv_url2list_of_bug_ids(
-                mysite.customs.bugtrackers.trac.csv_of_bugs(query_url))
-            for bug_id in query_ids:
-                yield bug_id
-
-    def generate_bug_project_name(self, trac_bug):
-        return self.bug_project_name_format.format(project=self.project_name,
-                                                   component=trac_bug.component)
-
-    def update(self):
-        logging.info("Started refreshing all %s bugs." % self.project_name)
-
-        # First, go through and refresh all the bugs specifically marked
-        # as bugs to look at.
-
-        for bug_id in self.generate_list_of_bug_ids_to_look_at():
-            self.refresh_one_bug_id(bug_id)
-
-        # Then, refresh them all
-        self.refresh_all_bugs()
-
-    def refresh_all_bugs(self):
-        for bug in mysite.search.models.Bug.all_bugs.filter(
-            canonical_bug_link__contains=self.base_url):
-            tb = mysite.customs.bugtrackers.trac.TracBug.from_url(
-                bug.canonical_bug_link)
-            self.refresh_one_bug_id(tb.bug_id)
-
-    def refresh_one_bug_id(self, bug_id):
-        tb = mysite.customs.bugtrackers.trac.TracBug(
-            bug_id=bug_id,
-            BASE_URL=self.base_url)
-        bug_url = tb.as_bug_specific_url()
-    
-        try:
-            bug = mysite.search.models.Bug.all_bugs.get(
-                canonical_bug_link=bug_url)
-        except mysite.search.models.Bug.DoesNotExist:
-            bug = mysite.search.models.Bug(canonical_bug_link = bug_url)
-
-        # Hopefully, the bug is so fresh it needs no refreshing.
-        if bug.data_is_more_fresh_than_one_day():
-            logging.info("Bug %d from %s is fresh. Doing nothing!" % (bug_id, self.project_name))
-            return # sweet
-
-        # Okay, fine, we need to actually refresh it.
-        logging.info("Refreshing bug %d from %s." %
-                     (bug_id, self.project_name))
-        data = tb.as_data_dict_for_bug_object(self.extract_tracker_specific_data)
-
-        for key in data:
-            value = data[key]
-            setattr(bug, key, value)
-
-        # And save the project onto it
-        # Project name is taken from either overall project name or individual component name
-        # based on the value of the boolean set in the __init__ method.
-        project_from_name, _ = mysite.search.models.Project.objects.get_or_create(name=self.generate_bug_project_name(tb))
-        if bug.project_id != project_from_name.id:
-            bug.project = project_from_name
-        bug.last_polled = datetime.datetime.utcnow()
-        bug.save()
-        logging.info("Finished with %d from %s." % (bug_id, self.project_name))
-            
-class TahoeLafsTrac(TracBugTracker):
-    enabled = True
-
-    def __init__(self):
-        TracBugTracker.__init__(self,
-                                project_name='Tahoe-LAFS',
-                                base_url='http://tahoe-lafs.org/trac/tahoe-lafs/',
-                                bug_project_name_format='{project}')
-
-    def generate_list_of_bug_ids_to_look_at(self):
-        queries = {
-                'All bugs':
-                    'http://tahoe-lafs.org/trac/tahoe-lafs/query?status=assigned&status=new&status=reopened&max=10000&reporter=~&col=id&col=summary&col=keywords&col=reporter&col=status&col=owner&col=type&col=priority&col=milestone&keywords=~&owner=~&desc=1&order=id&format=csv',
-                }
-        return self.generate_bug_ids_from_queries(queries)
-
-    @staticmethod
-    def extract_tracker_specific_data(trac_data, ret_dict):
-        # Make modifications to ret_dict using provided metadata
-        # Check for the bitesized keyword
-        ret_dict['bite_size_tag_name'] = 'easy'
-        ret_dict['good_for_newcomers'] = ('easy' in trac_data['keywords'])
-        # Check whether this is a documentation bug.
-        ret_dict['concerns_just_documentation'] = ('docs' in trac_data['keywords'])
-        # Then pass ret_dict back
-        return ret_dict
-
-class TwistedTrac(TracBugTracker):
-    enabled = True
-
-    def __init__(self):
-        TracBugTracker.__init__(self,
-                                project_name='Twisted',
-                                base_url='http://twistedmatrix.com/trac/',
-                                bug_project_name_format='{project}')
-
-    def generate_list_of_bug_ids_to_look_at(self):
-        queries = {
-                'Easy bugs':
-                    'http://twistedmatrix.com/trac/query?status=new&status=assigned&status=reopened&format=csv&keywords=%7Eeasy&order=priority',
-                'Documentation bugs':
-                    'http://twistedmatrix.com/trac/query?status=assigned&status=new&status=reopened&format=csv&order=priority&keywords=~documentation'
-                }
-        return self.generate_bug_ids_from_queries(queries)
-
-    @staticmethod
-    def extract_tracker_specific_data(trac_data, ret_dict):
-        # Make modifications to ret_dict using provided metadata
-        # Check for the bitesized keyword
-        ret_dict['bite_size_tag_name'] = 'easy'
-        ret_dict['good_for_newcomers'] = ('easy' in trac_data['keywords'])
-        # Check whether this is a documentation bug.
-        ret_dict['concerns_just_documentation'] = ('documentation' in trac_data['keywords'])
-        # Then pass ret_dict back
-        return ret_dict
-
-class SugarLabsTrac(TracBugTracker):
-    enabled = True
-
-    def __init__(self):
-        TracBugTracker.__init__(self,
-                                project_name='Sugar Labs',
-                                base_url='http://bugs.sugarlabs.org/',
-                                bug_project_name_format='{component}')
-
-    def generate_list_of_bug_ids_to_look_at(self):
-        queries = {
-                'Easy bugs':
-                    'http://bugs.sugarlabs.org/query?status=accepted&status=new&status=assigned&status=reopened&format=csv&keywords=%7Esugar-love&order=priority',
-                'Documentation bugs':
-                    'http://bugs.sugarlabs.org/query?status=accepted&status=assigned&status=new&status=reopened&format=csv&order=priority&keywords=~documentation'
-                }
-        return self.generate_bug_ids_from_queries(queries)
-
-    @staticmethod
-    def extract_tracker_specific_data(trac_data, ret_dict):
-        # Make modifications to ret_dict using provided metadata
-        # Check for the bitesized keyword
-        ret_dict['bite_size_tag_name'] = 'sugar-love'
-        ret_dict['good_for_newcomers'] = ('sugar-love' in trac_data['keywords'])
-        # Check whether this is a documentation bug.
-        ret_dict['concerns_just_documentation'] = ('documentation' in trac_data['keywords'])
-        # Then pass ret_dict back
-        return ret_dict
-
-class StatusNetTrac(TracBugTracker):
-    enabled = False # No longer Bugzilla?
-
-    def __init__(self):
-        TracBugTracker.__init__(self,
-                                project_name='StatusNet',
-                                base_url='http://status.net/trac/',
-                                bug_project_name_format='{project}')
-
-    def generate_list_of_bug_ids_to_look_at(self):
-        # Only gives a list of bitesized bugs - confirm if devels want all bugs indexed
-        return mysite.customs.bugtrackers.trac.csv_url2list_of_bug_ids(
-            mysite.customs.bugtrackers.trac.csv_of_bugs(
-                'http://status.net/trac/query?status=accepted&status=assigned&status=new&status=reopened&format=csv&order=priority&keywords=%7Eeasy'))
-
-class XiphTrac(TracBugTracker):
-    enabled = True
-
-    def __init__(self):
-        TracBugTracker.__init__(self,
-                                project_name='Xiph',
-                                base_url='http://trac.xiph.org/',
-                                bug_project_name_format='{project}')
-
-    def generate_list_of_bug_ids_to_look_at(self):
-        queries = {
-                'Easy bugs': # Only gives a list of bitesized bugs - confirm if devels want all bugs indexed
-                    'https://trac.xiph.org/query?status=assigned&status=new&status=reopened&order=priority&format=csv&keywords=%7Eeasy',
-                #'Documentation bugs':
-                    #''
-                }
-        return self.generate_bug_ids_from_queries(queries)
-
-    @staticmethod
-    def extract_tracker_specific_data(trac_data, ret_dict):
-        # Make modifications to ret_dict using provided metadata
-        # Check for the bitesized keyword
-        ret_dict['bite_size_tag_name'] = 'easy' # Unconfirmed, there were no such bugs at the time
-        ret_dict['good_for_newcomers'] = ('easy' in trac_data['keywords'])
-        # Check whether this is a documentation bug.
-        #ret_dict['concerns_just_documentation'] = ('docs' in trac_data['keywords'])
-        # Then pass ret_dict back
-        return ret_dict
-
-class OLPCTrac(TracBugTracker):
-    enabled = False # Need to sort out naming for bug projects
-
-    def __init__(self):
-        TracBugTracker.__init__(self,
-                                project_name='OLPC',
-                                base_url='http://dev.laptop.org/',
-                                bug_project_name_format='{project}')
-
-    def generate_list_of_bug_ids_to_look_at(self):
-        queries = {
-                'All bugs':
-                    'http://dev.laptop.org/query?status=assigned&status=new&status=reopened&order=priority&format=csv',
-                }
-        return self.generate_bug_ids_from_queries(queries)
-
-    @staticmethod
-    def extract_tracker_specific_data(trac_data, ret_dict):
-        # Make modifications to ret_dict using provided metadata
-        # Check for the bitesized keyword
-        ret_dict['bite_size_tag_name'] = 'easy'
-        ret_dict['good_for_newcomers'] = ('easy' in trac_data['keywords']) or ('sugar-love' in trac_data['keywords'])
-        # Check whether this is a documentation bug.
-        ret_dict['concerns_just_documentation'] = ('doc' in trac_data['keywords'])
-        # Then pass ret_dict back
-        return ret_dict
-
-class DjangoTrac(TracBugTracker):
-    enabled = False # Opened' and 'Last modified' fields aren't hyperlinked
-
-    def __init__(self):
-        TracBugTracker.__init__(self,
-                                project_name='Django',
-                                base_url='http://code.djangoproject.com/',
-                                bug_project_name_format='{project}')
-
-    def generate_list_of_bug_ids_to_look_at(self):
-        queries = {
-                'All bugs':
-                    'http://code.djangoproject.com/query?status=new&status=assigned&status=reopened&order=priority&format=csv',
-                }
-        return self.generate_bug_ids_from_queries(queries)
-
-    @staticmethod
-    def extract_tracker_specific_data(trac_data, ret_dict):
-        # Make modifications to ret_dict using provided metadata
-        # Check for the bitesized keyword
-        ret_dict['bite_size_tag_name'] = 'easy'
-        ret_dict['good_for_newcomers'] = ('easy' in trac_data['keywords'])
-        # Check whether this is a documentation bug.
-        # FIXME: No standard. Check which to use, or just look for  all?
-        #ret_dict['concerns_just_documentation'] = ('doc' in trac_data['keywords'])
-        # Then pass ret_dict back
-        return ret_dict
-
-class HelenOSTrac(TracBugTracker):
-    enabled = True
-
-    def __init__(self):
-        TracBugTracker.__init__(self,
-                                project_name='HelenOS',
-                                base_url='http://trac.helenos.org/trac.fcgi/',
-                                bug_project_name_format='{project}')
-
-    def generate_list_of_bug_ids_to_look_at(self):
-        queries = {
-                'All bugs':
-                    'http://trac.helenos.org/trac.fcgi/query?status=accepted&status=assigned&status=new&status=reopened&order=priority&format=csv',
-                }
-        return self.generate_bug_ids_from_queries(queries)
-
-    @staticmethod
-    def extract_tracker_specific_data(trac_data, ret_dict):
-        # Make modifications to ret_dict using provided metadata
-        # Check for the bitesized keyword
-        ret_dict['bite_size_tag_name'] = 'easy' # Unconfirmed, there were no such bugs at the time
-        ret_dict['good_for_newcomers'] = ('easy' in trac_data['keywords'])
-        # Check whether this is a documentation bug. FIXME: Need better example - doc keyword or component?
-        #ret_dict['concerns_just_documentation'] = ('doc' in trac_data['keywords'])
-        # Then pass ret_dict back
-        return ret_dict
-
-class Bcfg2Trac(TracBugTracker):
-    enabled = True
-
-    def __init__(self):
-        TracBugTracker.__init__(self,
-                                project_name='Bcfg2',
-                                base_url='https://trac.mcs.anl.gov/projects/bcfg2/',
-                                bug_project_name_format='{project}')
-
-    def generate_list_of_bug_ids_to_look_at(self):
-        queries = {
-                'All bugs':
-                    'https://trac.mcs.anl.gov/projects/bcfg2/query?status=accepted&status=assigned&status=new&status=reopened&order=priority&format=csv',
-                }
-        return self.generate_bug_ids_from_queries(queries)
-
-    @staticmethod
-    def extract_tracker_specific_data(trac_data, ret_dict):
-        # Make modifications to ret_dict using provided metadata
-        # Check for the bitesized keyword
-        ret_dict['bite_size_tag_name'] = 'easy' # Unconfirmed, there were no such bugs at the time
-        ret_dict['good_for_newcomers'] = ('easy' in trac_data['keywords'])
-        # Check whether this is a documentation bug.
-        ret_dict['concerns_just_documentation'] = ('bcfg2-doc' in trac_data['component'])
-        # Then pass ret_dict back
-        return ret_dict
-
-class WarFoundryTrac(TracBugTracker):
-    enabled = True
-
-    def __init__(self):
-        TracBugTracker.__init__(self,
-                                project_name='WarFoundry',
-                                base_url='http://dev.ibboard.co.uk/projects/warfoundry/',
-                                bug_project_name_format='{project}')
-
-    def generate_list_of_bug_ids_to_look_at(self):
-        queries = {
-                'All bugs':
-                    'http://dev.ibboard.co.uk/projects/warfoundry/query?status=accepted&status=assigned&status=confirmed&status=needinfo&status=needinfo_new&status=new&status=reopened&order=priority&format=csv',
-                }
-        return self.generate_bug_ids_from_queries(queries)
-
-    @staticmethod
-    def extract_tracker_specific_data(trac_data, ret_dict):
-        # Make modifications to ret_dict using provided metadata
-        # Check for the bitesized keyword
-        ret_dict['bite_size_tag_name'] = 'papercut'
-        ret_dict['good_for_newcomers'] = ('papercut' in trac_data['keywords'])
-        # Check whether this is a documentation bug.
-        #ret_dict['concerns_just_documentation'] = ('docs' in trac_data['keywords'])
-        # Then pass ret_dict back
-        return ret_dict
-
-class FedoraPythonModulesTrac(TracBugTracker):
-    enabled = False # 'Opened' and 'Last modified' bug fields aren't hyperlinked
-
-    def __init__(self):
-        TracBugTracker.__init__(self,
-                                project_name='Fedora Python Modules',
-                                base_url='https://fedorahosted.org/python-fedora/',
-                                bug_project_name_format='{project}')
-
-    def generate_list_of_bug_ids_to_look_at(self):
-        queries = {
-                'All bugs':
-                    'https://fedorahosted.org/python-fedora/query?status=new&status=assigned&status=reopened&order=priority&format=csv',
-                }
-        return self.generate_bug_ids_from_queries(queries)
-
-    @staticmethod
-    def extract_tracker_specific_data(trac_data, ret_dict):
-        # Make modifications to ret_dict using provided metadata
-        # Check for the bitesized keyword
-        #ret_dict['bite_size_tag_name'] = 'easy'
-        #ret_dict['good_for_newcomers'] = ('easy' in trac_data['keywords'])
-        # Check whether this is a documentation bug.
-        #ret_dict['concerns_just_documentation'] = ('doc' in trac_data['keywords'])
-        # Then pass ret_dict back
-        return ret_dict
-
-class AngbandTrac(TracBugTracker):
-    enabled = True
-
-    def __init__(self):
-        TracBugTracker.__init__(self,
-                                project_name='Angband',
-                                base_url='http://trac.rephial.org/',
-                                bug_project_name_format='{project}')
-
-    def generate_list_of_bug_ids_to_look_at(self):
-        queries = {
-                'All bugs':
-                    'http://trac.rephial.org/query?status=assigned&status=confirmed&status=new&status=reopened&order=priority&format=csv',
-                }
-        return self.generate_bug_ids_from_queries(queries)
-
-    @staticmethod
-    def extract_tracker_specific_data(trac_data, ret_dict):
-        # Make modifications to ret_dict using provided metadata
-        # Check for the bitesized keyword
-        ret_dict['bite_size_tag_name'] = 'easy' # Unconfirmed, there were no such bugs at the time
-        ret_dict['good_for_newcomers'] = ('easy' in trac_data['keywords'])
-        # Check whether this is a documentation bug.
-        ret_dict['concerns_just_documentation'] = ('doc' in trac_data['keywords'])
-        # Then pass ret_dict back
-        return ret_dict
-
-class GHCTrac(TracBugTracker):
-    enabled = True
-
-    def __init__(self):
-        TracBugTracker.__init__(self,
-                                project_name='GHC',
-                                base_url='http://hackage.haskell.org/trac/ghc/',
-                                bug_project_name_format='{project}')
-
-    def generate_list_of_bug_ids_to_look_at(self):
-        queries = {
-                'All bugs':
-                    'http://hackage.haskell.org/trac/ghc/query?status=new&status=assigned&status=reopened&group=priority&order=id&desc=1&format=csv',
-                }
-        return self.generate_bug_ids_from_queries(queries)
-
-    @staticmethod
-    def extract_tracker_specific_data(trac_data, ret_dict):
-        # Make modifications to ret_dict using provided metadata
-        # Check for the bitesized keyword
-        ret_dict['bite_size_tag_name'] = 'Easy (less than 1 hour)'
-        ret_dict['good_for_newcomers'] = ('Easy (less than 1 hour)' in trac_data['difficulty'])
-        # Check whether this is a documentation bug.
-        ret_dict['concerns_just_documentation'] = ('Documentation' in trac_data['component'])
-        # Then pass ret_dict back
-        return ret_dict
-
-class TracTrac(TracBugTracker):
-    enabled = True
-
-    def __init__(self):
-        TracBugTracker.__init__(self,
-                                project_name='Trac',
-                                base_url='http://trac.edgewall.org/',
-                                bug_project_name_format='{project}')
-
-    def generate_list_of_bug_ids_to_look_at(self):
-        queries = {
-                'Easy bugs':
-                    'http://trac.edgewall.org/query?status=!closed&keywords=~bitesized&format=csv',
-                #'Documentation bugs':
-                    #''
-                }
-        return self.generate_bug_ids_from_queries(queries)
-
-    @staticmethod
-    def extract_tracker_specific_data(trac_data, ret_dict):
-        # Make modifications to ret_dict using provided metadata
-        # Check for the bitesized keyword
-        ret_dict['bite_size_tag_name'] = 'bitesized'
-        ret_dict['good_for_newcomers'] = ('bitesized' in trac_data['keywords'])
-        # Check whether this is a documentation bug.
-        #ret_dict['concerns_just_documentation'] = ('doc' in trac_data['keywords'])
-        # Then pass ret_dict back
-        return ret_dict
-
-class SSSDTrac(TracBugTracker):
-    enabled = False # 'Opened' and 'Last modified' fields aren't hyperlinked
-
-    def __init__(self):
-        TracBugTracker.__init__(self,
-                                project_name='SSSD',
-                                base_url='https://fedorahosted.org/sssd/',
-                                bug_project_name_format='{project}')
-
-    def generate_list_of_bug_ids_to_look_at(self):
-        queries = {
-                'All bugs':
-                    'https://fedorahosted.org/sssd/query?status=new&status=assigned&status=reopened&order=priority&format=csv',
-                }
-        return self.generate_bug_ids_from_queries(queries)
-
-    @staticmethod
-    def extract_tracker_specific_data(trac_data, ret_dict):
-        # Make modifications to ret_dict using provided metadata
-        # Check for the bitesized keyword
-        ret_dict['bite_size_tag_name'] = 'trivial'
-        ret_dict['good_for_newcomers'] = ('trivial' in trac_data['priority'])
-        # Check whether this is a documentation bug.
-        #ret_dict['concerns_just_documentation'] = ('doc' in trac_data['keywords'])
-        # Then pass ret_dict back
-        return ret_dict
-
-class I2PTrac(TracBugTracker):
-    enabled = True
-
-    def __init__(self):
-        TracBugTracker.__init__(self,
-                                project_name='I2P',
-                                base_url='http://trac.i2p2.de/',
-                                bug_project_name_format='{project}')
-
-    def generate_list_of_bug_ids_to_look_at(self):
-        queries = {
-                'All bugs':
-                    'http://trac.i2p2.de/query?status=accepted&status=assigned&status=new&status=reopened&order=priority&format=csv',
-                }
-        return self.generate_bug_ids_from_queries(queries)
-
-    @staticmethod
-    def extract_tracker_specific_data(trac_data, ret_dict):
-        # Make modifications to ret_dict using provided metadata
-        # Check for the bitesized keyword
-        ret_dict['bite_size_tag_name'] = 'easy'
-        ret_dict['good_for_newcomers'] = ('easy' in trac_data['keywords'])
-        # Check whether this is a documentation bug.
-        #ret_dict['concerns_just_documentation'] = ('doc' in trac_data['keywords'])
-        # Then pass ret_dict back
-        return ret_dict
-
-# Copy this generic class to add a new Trac bugtracker
-# Remember to set 'enabled' to True
-# Notes:
-# Base URL: the URL of a bug for the bugtracker, without the 'ticket/1234'
-# Tracking URL: go to BASE_URL/query and search for the bugs you want tracked
-# bug_project_name_format: the format to be used for the bug's project name
-# "{project}" will be replaced by project_name, and "{component}" by the
-# component the bug is part of (as taken from the bug's ticket).
-class GenTrac(TracBugTracker):
-    enabled = False
-
-    def __init__(self):
-        TracBugTracker.__init__(self,
-                                project_name='',
-                                base_url='',
-                                bug_project_name_format='')
-
-    def generate_list_of_bug_ids_to_look_at(self):
-        # Can replace both entries below with an 'All bugs' query.
-        queries = {
-                'Easy bugs':
-                    '',
-                'Documentation bugs':
-                    ''
-                }
-        return self.generate_bug_ids_from_queries(queries)
-
-    @staticmethod
-    def extract_tracker_specific_data(trac_data, ret_dict):
-        # Make modifications to ret_dict using provided metadata
-        # Check for the bitesized keyword
-        ret_dict['bite_size_tag_name'] = ''
-        ret_dict['good_for_newcomers'] = ('' in trac_data['keywords'])
-        # Check whether this is a documentation bug.
-        ret_dict['concerns_just_documentation'] = ('' in trac_data['keywords'])
-        # Then pass ret_dict back
-        return ret_dict
-
diff --git a/mysite/search/tests.py b/mysite/search/tests.py
index f5de8dc..0772dcb 100644
--- a/mysite/search/tests.py
+++ b/mysite/search/tests.py
@@ -10,7 +10,6 @@ from mysite.search.models import Project, Bug, HitCountCache, \
 from mysite.search import views
 import lpb2json
 import datetime
-import mysite.search.launchpad_crawl
 import mysite.project.views
 
 import simplejson
@@ -336,117 +335,6 @@ class SearchResults(TwillTests):
         for bug in bugs:
             tc.find(bug.description)
 
-sample_launchpad_data_dump = mock.Mock()
-sample_launchpad_data_dump.return_value = [dict(
-        url=u'', project=u'rose.makesad.us', text=u'', status=u'',
-        importance=u'low', reporter={u'lplogin': 'a',
-                                    'realname': 'b'},
-        tags=[], comments=[], date_updated=time.localtime(),
-        date_reported=time.localtime(),
-        title="Joi's Lab AFS",)]
-
-class AutoCrawlTests(SearchTest):
-    @mock.patch('mysite.search.launchpad_crawl.dump_data_from_project', 
-                sample_launchpad_data_dump)
-    @mock.patch('mysite.search.tasks.PopulateProjectLanguageFromOhloh')
-    def testSearch(self, do_nothing):
-        # Verify that we can't find a bug with the right description
-        self.assertRaises(mysite.search.models.Bug.DoesNotExist,
-                          mysite.search.models.Bug.all_bugs.get,
-                          title="Joi's Lab AFS")
-        # Now get all the bugs about rose
-        mysite.search.launchpad_crawl.grab_lp_bugs(lp_project='rose',
-                                            openhatch_project_name=
-                                            u'rose.makesad.us')
-        # Now see, we have one!
-        b = mysite.search.models.Bug.all_bugs.get(title="Joi's Lab AFS")
-        self.assertEqual(b.project.name, u'rose.makesad.us')
-        # Ta-da.
-        return b
-
-    def test_running_job_twice_does_update(self):
-        b = self.testSearch()
-        b.description = u'Eat more potato starch'
-        b.title = u'Yummy potato paste'
-        b.save()
-
-        new_b = self.testSearch()
-        self.assertEqual(new_b.title, "Joi's Lab AFS") # bug title restored
-        # thanks to fresh import
-
-class LaunchpadImporterTests(SearchTest):
-
-    @mock.patch('mysite.search.tasks.PopulateProjectLanguageFromOhloh')
-    def test_lp_update_handler(self, do_nothing):
-        '''Test the Launchpad import handler with some fake data.'''
-        some_date = datetime.datetime(2009, 4, 1, 2, 2, 2)
-        query_data = dict(project='GNOME-Do',
-                          canonical_bug_link='http://example.com/1')
-        new_data = dict(title='Title', status='Godforsaken',
-                        description='Everything should be better',
-                        importance='High',
-                        people_involved=1000 * 1000,
-                        submitter_username='yourmom',
-                        submitter_realname='Your Mom',
-                        date_reported=some_date,
-                        last_touched=some_date,
-                        last_polled=some_date)
-
-        # Create the bug...
-        mysite.search.launchpad_crawl.handle_launchpad_bug_update(
-                project_name=query_data['project'],
-                canonical_bug_link=query_data['canonical_bug_link'], 
-                new_data=new_data)
-        # Verify that the bug was stored.
-        bug = Bug.all_bugs.get(canonical_bug_link=
-                                       query_data['canonical_bug_link'])
-        for key in new_data:
-            self.assertEqual(getattr(bug, key), new_data[key])
-
-        # Now re-do the update, this time with more people involved
-        new_data['people_involved'] = 1000 * 1000 * 1000
-        # pass the data in...
-        mysite.search.launchpad_crawl.handle_launchpad_bug_update(
-                project_name=query_data['project'],
-                canonical_bug_link=query_data['canonical_bug_link'], 
-                new_data=new_data)
-        # Do a get; this will explode if there's more than one with the
-        # canonical_bug_link, so it tests duplicate finding.
-        bug = Bug.all_bugs.get(canonical_bug_link=
-                                       query_data[u'canonical_bug_link'])
-
-        for key in new_data:
-            self.assertEqual(getattr(bug, key), new_data[key])
-
-    @mock.patch('mysite.search.tasks.PopulateProjectLanguageFromOhloh')
-    def test_lp_data_clean(self, do_nothing):
-        now_t = (2009, 4, 1, 5, 13, 2) # partial time tuple
-        now_d = datetime.datetime(2009, 4, 1, 5, 13, 2)
-        # NOTE: We do not test for time zone correctness.
-        sample_in = dict(project='GNOME-Do', url='http://example.com/1',
-                         title='Title', text='Some long text',
-                         importance=None, status='Ready for take-off',
-                         comments=[{'user': {
-                             'lplogin': 'jones', 'realname': 'Jones'}}],
-                         reporter={'lplogin': 'bob', 'realname': 'Bob'},
-                         date_reported=now_t,
-                         date_updated=now_t,
-                         )
-        sample_out_query = dict(project='GNOME-Do',
-                                canonical_bug_link='http://example.com/1')
-        sample_out_data = dict(title='Title', description='Some long text',
-                               importance='Unknown', status='Ready for take-off',
-                               people_involved=2, submitter_realname='Bob',
-                               submitter_username='bob',
-                               date_reported=now_d,
-                               last_touched=now_d)
-        out_q, out_d = mysite.search.launchpad_crawl.clean_lp_data_dict(sample_in)
-        self.assertEqual(sample_out_query, out_q)
-        # Make sure last_polled is at least in the same year
-        self.assertEqual(out_d['last_polled'].year, datetime.date.today().year)
-        del out_d['last_polled']
-        self.assertEqual(sample_out_data, out_d)
-
 class Recommend(SearchTest):
     fixtures = ['user-paulproteus.json',
             'person-paulproteus.json',
@@ -1206,48 +1094,6 @@ class PublicizeBugTrackerIndex(SearchTest):
                 self.search_page_response.context[0][u'project_count'],
                 self.bug_tracker_count)
 
-class LaunchpadImporterMarksFixedBugsAsClosed(TwillTests):
-    def test(self):
-        '''Start with a bug that is "Fix Released"
-
-        Verify that we set looks_closed to True'''
-        # retry this with committed->released
-        lp_data_dict = {'project': '',
-                        'url': '',
-                        'title': '',
-                        'text': '',
-                        'status': 'Fix Committed',
-                        'importance': '',
-                        'reporter': {'lplogin': '', 'realname': ''},
-                        'comments': '',
-                        'date_updated': datetime.datetime.now().timetuple(),
-                        'date_reported': datetime.datetime.now().timetuple()}
-        # maybe I could have done this with a defaultdict of str with
-        # just the non-str exceptions
-        query_data, new_data = mysite.search.launchpad_crawl.clean_lp_data_dict(
-            lp_data_dict)
-        self.assertTrue(new_data['looks_closed'])
-
-    def test_with_status_missing(self):
-        '''Verify we do not explode if Launchpad gives us a bug with no Status
-
-        Verify that we set looks_closed to True'''
-        # retry this with committed->released
-        lp_data_dict = {'project': '',
-                        'url': '',
-                        'title': '',
-                        'text': '',
-                        'importance': '',
-                        'reporter': {'lplogin': '', 'realname': ''},
-                        'comments': '',
-                        'date_updated': datetime.datetime.now().timetuple(),
-                        'date_reported': datetime.datetime.now().timetuple()}
-        # maybe I could have done this with a defaultdict of str with
-        # just the non-str exceptions
-        query_data, new_data = mysite.search.launchpad_crawl.clean_lp_data_dict(
-            lp_data_dict)
-        self.assertEqual(new_data['status'], 'Unknown')
-
 class TestPotentialMentors(TwillTests):
     fixtures = ['user-paulproteus', 'user-barry', 'person-barry', 'person-paulproteus']
 
-- 
1.7.1

